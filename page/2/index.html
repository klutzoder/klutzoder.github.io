<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Klutzoder'Blog" type="application/atom+xml">






<meta name="description" content="I&apos;m no body!">
<meta name="keywords" content="LeetCode, Linux">
<meta property="og:type" content="website">
<meta property="og:title" content="Klutzoder&#39;Blog">
<meta property="og:url" content="http://www.klutzoder.com/page/2/index.html">
<meta property="og:site_name" content="Klutzoder&#39;Blog">
<meta property="og:description" content="I&apos;m no body!">
<meta property="og:locale" content="chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Klutzoder&#39;Blog">
<meta name="twitter:description" content="I&apos;m no body!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.klutzoder.com/page/2/">





  <title>Klutzoder'Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Klutzoder'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Algorithm/algorithm/dijkstra/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Algorithm/algorithm/dijkstra/" itemprop="url">Dijkstra</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-08T14:34:58+08:00">
                2019-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文基于 <a href="https://www.bilibili.com/video/av25829980?from=search&amp;seid=6605585063459234452" target="_blank" rel="noopener">[Python] BFS和DFS算法（第3讲）—— 从BFS到Dijkstra算法</a> 学习整理后所得。<br>对于 BFS 及 DFS 有所不了解的可以看 <a href="../dfs-bfs">BFS(Breadth First Search) 与 DFS (Depth First Search)</a></p>
<h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><p>Dijkstra 是在 BFS 基础上进行修改而来的，对于 BFS 遍历而言，由于其边的长度只为1，因此只需使用 Queue 即可。但是对于边有权重的图而言，需要考虑每一条边的权重。</p>
<p>因此，对于 Dijkstra 可以考虑使用 PriorityQueue 来代替 Queue，如此每次便可取出距离最短的点。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757897835902.jpg" width="600" alt title></p>
<h2 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h2><p>第一步：将 A:0 放入 PQ<br>第二步：从 PQ 中获取一个节点 A:0， A:0 没有被使用过，且其连接的节点为 B, C。此时将 B:5, C:1 放入 PQ 中，将 A 标记为已使用。<br>第三步：从 PQ 中获取一个节点 C:1 <code>(此时使用优先队列，所以取最近的)</code>，此时与 C 连接的节点为 A, B, D，且 A 被标记使用，需要将 B:3, D:5, E:9 放入 PQ。</p>
<blockquote>
<p>这里最关键的一步是，取出 C 点后，需要将 B:3 再放入 PQ 中，PQ 中的数据将变为 [B:5, B:3, D:5, E:9]</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无向图，注意 u, v 可以相互到达</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[][] uvw, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] c : uvw) &#123;</span><br><span class="line">			map.putIfAbsent(c[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">			map.putIfAbsent(c[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">			map.get(c[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; c[<span class="number">2</span>], c[<span class="number">1</span>] &#125;);</span><br><span class="line">			map.get(c[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; c[<span class="number">2</span>], c[<span class="number">0</span>] &#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		parents[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line">		<span class="comment">// 0: distance, 1: node</span></span><br><span class="line">		PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">		pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">		<span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span>[] cur = pq.poll();</span><br><span class="line">			<span class="keyword">if</span> (used[cur[<span class="number">1</span>]] || !map.containsKey(cur[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">			used[cur[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span>[] next : map.get(cur[<span class="number">1</span>])) &#123;</span><br><span class="line">				<span class="keyword">if</span> (used[next[<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">				parents[next[<span class="number">1</span>]] = cur[<span class="number">1</span>];</span><br><span class="line">				pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>]+next[<span class="number">0</span>], next[<span class="number">1</span>]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Arrays.toString(parents));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Dijkstra().solution(<span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span> &#125;, &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">				&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span> &#125; &#125;, <span class="number">6</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LeetCode-743"><a href="#LeetCode-743" class="headerlink" title="LeetCode 743"></a>LeetCode 743</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] t : times) &#123;</span><br><span class="line">            graph.putIfAbsent(t[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            graph.get(t[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;t[<span class="number">1</span>], t[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0: distance 1: Node</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, K&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (used[cur[<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">            used[cur[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">            res = Math.max(res, cur[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(cur[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] next : graph.get(cur[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[next[<span class="number">0</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>]+next[<span class="number">1</span>], next[<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Algorithm/algorithm/segment-tree-and-fenwick-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Algorithm/algorithm/segment-tree-and-fenwick-tree/" itemprop="url">Segment Tree And Fenwick Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-29T10:12:08+08:00">
                2019-11-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文讲解的 FenwickTree 以及 Segment Tree 主要用于解决可变数组中，高效求解范围和的算法。<br>以 <a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">Leetcode 307. Range Sum Query - Mutable</a> 为例进行分析。<br>学习资料来源于：<a href="https://www.bilibili.com/video/av31200591?from=search&amp;seid=2044302429705113819" target="_blank" rel="noopener">花花酱 Fenwick Tree / Binary Indexed Tree - 刷题找工作 SP3</a>、<a href="https://www.youtube.com/watch?v=rYBtViWXYeI&amp;list=PLLuMmzMTgVK5Hy1qcWYZcd7wVQQ1v0AjX&amp;index=4" target="_blank" rel="noopener">花花酱 Segment Tree 线段树 - 刷题找工作 SP14</a>、<a href="https://www.youtube.com/watch?v=e_bK-dgPvfM&amp;t=2s" target="_blank" rel="noopener">线段树 (segment tree)</a>，并结合自身理解进行整理。</p>
</blockquote>
<h1 id="不可变数组的范围和求解"><a href="#不可变数组的范围和求解" class="headerlink" title="不可变数组的范围和求解"></a>不可变数组的范围和求解</h1><p>对于不可变数组的范围和，我们可以通过预先处理前缀和，然后通过前缀和之间的关系求解。</p>
<p><a href="https://leetcode.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. Range Sum Query - Immutable</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] prefix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        prefix = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == <span class="keyword">null</span> || prefix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> prefix[j] - (i == <span class="number">0</span> ? <span class="number">0</span> : prefix[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对于一个可变的数组如何求解前缀和呢？</p>
<p>譬如有一个数组 <code>[2, 5, -1, 3, 6]</code> 需要实现 <code>update</code> 与 <code>sumRange</code> 函数，此时最简单的实现便是 <code>update</code> 时直接修改 <code>O(1)</code> 时间复杂度， <code>sumRange</code> 时直接遍历计算 <code>O(n)</code> 时间复杂度，这一 naive 的解题思路看着很不错，但实际上在求和时，会有很多的重复解，这便是可以优化的一部分。</p>
<p>一般常见的优化手段有 <code>FenwickTree</code> 以及 <code>SegmentTree</code>，以下就分别对这两种算法进行详细介绍。</p>
<h1 id="FenwickTree"><a href="#FenwickTree" class="headerlink" title="FenwickTree"></a>FenwickTree</h1><p>FenwickTree 又称为 Binary Indexed Tree 这是一种特殊的数据结构，能够高效地修改元素并计算数组中的前缀和。</p>
<p>FenwickTree 一共包含两个函数 <code>update(i, val)</code> 和 <code>query(i)</code>。</p>
<p>可通过点击<a href="https://visualgo.net/en/fenwicktree" target="_blank" rel="noopener">FenwickTree可视化过程</a>链接，查看整个过程。</p>
<h2 id="lowBit"><a href="#lowBit" class="headerlink" title="lowBit"></a>lowBit</h2><p>在代码中如何寻找数字中的最低位，这里有一个特别方便的方法，就是通过位运算求解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int lowBit(int x) &#123;</span><br><span class="line">    return x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 x = 5 而言，其二进制位 0101，-x = ~x + 1 = 1010 + 1 = 1011；对 x &amp; (-x) = 0101 &amp; 1011 = 1即所求的最低位。</p>
<h2 id="update-O-log-n"><a href="#update-O-log-n" class="headerlink" title="update O(log(n))"></a>update O(log(n))</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15756916329768.jpg" width="400" alt title></p>
<p>在 update 过程中，每一个节点的父节点均为 <code>i+lowBit(i)</code>，每次更新 i 节点时候，均要更新该节点的所有父节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sums.length) &#123;</span><br><span class="line">        sums[i] += val;</span><br><span class="line">        i += lowBit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="query-O-log-n"><a href="#query-O-log-n" class="headerlink" title="query O(log(n))"></a>query O(log(n))</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15756919510067.jpg" width="400" alt title></p>
<p>在 query 过程中，每一个节点的父节点均为 <code>i-lowBit(i)</code>，若要求得 [0, i] 的和必须添加对应父节点上所有的解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += sums[i];</span><br><span class="line">        i -= lowBit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode307"><a href="#LeetCode307" class="headerlink" title="LeetCode307"></a>LeetCode307</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FenwickTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            sums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; sums.length) &#123;</span><br><span class="line">                sums[i] += val;</span><br><span class="line">                i += lowBit(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += sums[i];</span><br><span class="line">                i -= lowBit(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> FenwickTree ft;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        ft = <span class="keyword">new</span> FenwickTree(nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ft.update(i+<span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ft.update(i+<span class="number">1</span>, val - nums[i]);</span><br><span class="line">        nums[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ft.query(j+<span class="number">1</span>) - ft.query(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SegmentTree"><a href="#SegmentTree" class="headerlink" title="SegmentTree"></a>SegmentTree</h1><p>Segment Tree 是一个完全二叉树，用于存储区间内对应信息的一种数据结构，该数据结构相较于 FenwickTree 而言，除了处理范围和这一问题，还能解决区间最大、区间最小、区间异或值的处理。</p>
<p>一般 SegmentTree 有两种实现方法，第一种是 Tree 实现，第二种类似堆使用数组。</p>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15756948931435.jpg" width="400" alt title></p>
<h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, nums[i], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (j-i)/<span class="number">2</span> + i;</span><br><span class="line">    Node left = buildSegmentTree(i, mid, nums);</span><br><span class="line">    Node right = buildSegmentTree(mid+<span class="number">1</span>, j, nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, left.sum+right.sum, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == i) &#123;</span><br><span class="line">        node.sum = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= mid) update(node.left, i, val);</span><br><span class="line">    <span class="keyword">else</span> update(node.right, i, val);</span><br><span class="line">    node.sum = node.left.sum + node.right.sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="queryRange"><a href="#queryRange" class="headerlink" title="queryRange"></a>queryRange</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">queryRange</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == j) <span class="keyword">return</span> node.sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= mid) <span class="keyword">return</span> queryRange(node.left, i, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) <span class="keyword">return</span> queryRange(node.right, i, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> queryRange(node.left, i, mid) + queryRange(node.right, mid+<span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode307-1"><a href="#LeetCode307-1" class="headerlink" title="LeetCode307"></a>LeetCode307</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node left, right;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sum, start, end;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span> <span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> sum, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.sum = sum;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        root = buildSegmentTree(<span class="number">0</span>, nums.length-<span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, nums[i], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (j-i)/<span class="number">2</span> + i;</span><br><span class="line">        Node left = buildSegmentTree(i, mid, nums);</span><br><span class="line">        Node right = buildSegmentTree(mid+<span class="number">1</span>, j, nums);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, left.sum+right.sum, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == i) &#123;</span><br><span class="line">            node.sum = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid) update(node.left, i, val);</span><br><span class="line">        <span class="keyword">else</span> update(node.right, i, val);</span><br><span class="line">        node.sum = node.left.sum + node.right.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryRange(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">queryRange</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == j) <span class="keyword">return</span> node.sum;</span><br><span class="line">        <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= mid) <span class="keyword">return</span> queryRange(node.left, i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) <span class="keyword">return</span> queryRange(node.right, i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> queryRange(node.left, i, mid) + queryRange(node.right, mid+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>以数组为蓝本的线段树，相对于上面而言有一个比较不直观的地方，若通过画图显示则可以表示成以下。<br>以 [1,2,3,4,5,6,7,8,9] 作为基础数据。</p>
<h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757009281208.jpg" width="400" alt title></p>
<ol>
<li>新建数组，tree = new int[2*n];</li>
<li>将 nums[i] 数据写到 tree[i+n]</li>
<li>更新每一个数据节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] buildTree(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; n*<span class="number">2</span>; i++, j++) &#123;</span><br><span class="line">        tree[i] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tree[i] = tree[i*<span class="number">2</span>] + tree[i*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757011755538.jpg" width="400" alt title></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    pos += n;</span><br><span class="line">    tree[pos] = val;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = pos, right = pos;</span><br><span class="line">        <span class="keyword">if</span> ((pos % <span class="number">2</span>) == <span class="number">0</span>) &#123; <span class="comment">// pos is left</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// pos is right</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[pos / <span class="number">2</span>] = tree[left] + tree[right];</span><br><span class="line">        pos /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sumRange"><a href="#sumRange" class="headerlink" title="sumRange"></a>sumRange</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757016154110.jpg" width="400" alt title></p>
<p>在求和时候，若 left 为偶数，则可以直接考虑其父节点，若 left 为奇数则需要单独加上该节点。<br>同理，若 right 为奇数，则可以直接考虑其父节点，若 right 为偶数则需要单独加上该节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    left += n; right += n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((left % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            sum += tree[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((right % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        left /= <span class="number">2</span>;</span><br><span class="line">        right /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode-307"><a href="#LeetCode-307" class="headerlink" title="LeetCode 307"></a>LeetCode 307</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        tree = buildTree(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buildTree(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++, j++) &#123;</span><br><span class="line">            tree[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tree[i] = tree[i*<span class="number">2</span>] + tree[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        tree[i] = val;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">0</span>) right++;</span><br><span class="line">            <span class="keyword">else</span> left--;</span><br><span class="line">            tree[i / <span class="number">2</span>] = tree[left] + tree[right];</span><br><span class="line">            i /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        i += n; j+= n;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                sum += tree[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((j % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                sum += tree[j--];</span><br><span class="line">            &#125;</span><br><span class="line">            i /= <span class="number">2</span>;</span><br><span class="line">            j /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Algorithm/algorithm/topological-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Algorithm/algorithm/topological-sort/" itemprop="url">Topological Sort</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-18T23:25:46+08:00">
                2019-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h1><p>Topological Sort 算法用于解决有向无环图 (DAG, directed acyclic graph) 中的依赖解析问题。<br>在一系列有先后顺序的任务中，运用 Topological Sort 可以得到满足执行顺序限制条件的一系列任务所需执行的先后顺序。</p>
<p>参考文档:</p>
<p><a href="https://www.geeksforgeeks.org/topological-sorting/" target="_blank" rel="noopener">Topological Sort(DFS)</a><br><a href="https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/" target="_blank" rel="noopener">Topological Sort(Kahn’s)</a><br><a href="https://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/" target="_blank" rel="noopener">All Topological Sorts</a></p>
<p><a href="https://github.com/klutzoder/leetcodeLab/blob/master/mycode/TopoSorted.java" target="_blank" rel="noopener">参考代码</a></p>
<h2 id="DAG-说明"><a href="#DAG-说明" class="headerlink" title="DAG 说明"></a>DAG 说明</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15743254823090.jpg" width="400" alt title></p>
<p>上图是一个典型的 DAG，可以使用 Graph 类进行存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// vertex，顶点数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; adj[]; <span class="comment">// edges, 边</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> List&lt;Integer&gt;[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[v].add(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph g = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="基于-DFS-的拓扑排序"><a href="#基于-DFS-的拓扑排序" class="headerlink" title="基于 DFS 的拓扑排序"></a>基于 DFS 的拓扑排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">topoSortByDFS</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.V];</span><br><span class="line">    Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(g.V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) dfs(i, g, visited, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(g.V);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) res.add(stack.pop());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, Graph g, <span class="keyword">boolean</span>[] visited, Deque&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : g.ajd[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) dfs(i, g, visited, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kahn’s-Topological-Sort"><a href="#Kahn’s-Topological-Sort" class="headerlink" title="Kahn’s Topological Sort"></a>Kahn’s Topological Sort</h2><ol>
<li>入度: 设 DAG 有一个节点 v, 入度即为当前所有从其他节点出发，终点为 v 的边的数目。</li>
<li>出度: 设 DAG 有一个节点 v, 出度即为从 v 出发，到所有其他节点的边的数。</li>
<li>Kahn 算法核心思想为不断寻找入度为 0 的节点，入度为 0 表示当前节点不依赖其他节点或者当前节点依赖的节点已完成相应操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">topoSortByKahn</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.V; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[v]) &#123;</span><br><span class="line">            inDegree[w]++; <span class="comment">// 每个节点的入度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.V; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) queue.offer(v);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">        res.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[v]) &#123;</span><br><span class="line">            inDegree[w]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[w] == <span class="number">0</span>) queue.offer(w);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Find-all-TopoSort-of-DAG"><a href="#Find-all-TopoSort-of-DAG" class="headerlink" title="Find all TopoSort of DAG"></a>Find all TopoSort of DAG</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; findAllTopoSort(Graph g) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; g.V; u++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[u]) inDegree[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.V];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findAllTopoSortOrder(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), g, inDegree, visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAllTopoSortOrder</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, Graph g, <span class="keyword">int</span>[] inDegree, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; g.V; u++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[u] != <span class="number">0</span> || visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[u]) inDegree[w]--;</span><br><span class="line">        temp.add(u);</span><br><span class="line">        visited[u] = <span class="keyword">true</span>;</span><br><span class="line">        findAllTopoSortOrder(res, temp, g, inDegree, visited);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w  : g.adj[u]) inDegree[w]++;</span><br><span class="line">        visited[u] = <span class="keyword">false</span>;</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp.size() == g.V) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="LeetCode-207"><a href="#LeetCode-207" class="headerlink" title="LeetCode 207"></a>LeetCode 207</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            map.putIfAbsent(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">            inDegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : map.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">                inDegree[j]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[j] == <span class="number">0</span>) queue.offer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode-210"><a href="#LeetCode-210" class="headerlink" title="LeetCode 210"></a>LeetCode 210</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            map.putIfAbsent(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">            inDegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            res[size++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : map.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">                inDegree[j]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[j] == <span class="number">0</span>) queue.offer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span> ? res : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode-269"><a href="#LeetCode-269" class="headerlink" title="LeetCode 269"></a>LeetCode 269</h2><p>该题目看懂题目很重要！！！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length() &amp;&amp; j &lt; words[i + <span class="number">1</span>].length(); j++) &#123;</span><br><span class="line">                <span class="comment">//如果字符相同，比较下一个</span></span><br><span class="line">                <span class="keyword">char</span> u = words[i].charAt(j), w = words[i + <span class="number">1</span>].charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (u == w) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//保存第一个不同的字符顺序</span></span><br><span class="line">                graph.putIfAbsent(u, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                graph.get(u).add(w);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(inDegree, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[c-<span class="string">'a'</span>] == -<span class="number">1</span>) count++;</span><br><span class="line">                inDegree[c-<span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : graph.keySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> next : graph.get(c)) &#123;</span><br><span class="line">                inDegree[next-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[c-<span class="string">'a'</span>] == <span class="number">0</span>) queue.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Character c = queue.poll();</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">for</span> (Character next : graph.getOrDefault(c, <span class="keyword">new</span> HashSet&lt;&gt;())) &#123;</span><br><span class="line">                inDegree[next-<span class="string">'a'</span>]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[next-<span class="string">'a'</span>] == <span class="number">0</span>) queue.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(count);</span></span><br><span class="line">        <span class="comment">// System.out.println(sb.toString());</span></span><br><span class="line">        <span class="keyword">return</span> sb.length() == count ? sb.toString() : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LeetCode-1203"><a href="#LeetCode-1203" class="headerlink" title="LeetCode 1203"></a>LeetCode 1203</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortItems(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[] group, List&lt;List&lt;Integer&gt;&gt; beforeItems) &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; itemGraph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; itemInDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) itemGraph.putIfAbsent(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; groupGraph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; groupInDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : group) groupGraph.putIfAbsent(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> after = <span class="number">0</span>; after &lt; n; after++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> before : beforeItems.get(after)) &#123;</span><br><span class="line">                itemGraph.get(before).add(after);</span><br><span class="line">                itemInDegree.put(after, itemInDegree.getOrDefault(after, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> gbefore = group[before];</span><br><span class="line">                <span class="keyword">int</span> gafter = group[after];</span><br><span class="line">                <span class="keyword">if</span> (gbefore != gafter &amp;&amp; groupGraph.get(gbefore).add(gafter)) &#123;</span><br><span class="line">                    groupInDegree.put(gafter, groupInDegree.getOrDefault(gafter, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; itemList = topologicalSort(itemGraph, itemInDegree);</span><br><span class="line">        List&lt;Integer&gt; groupList = topologicalSort(groupGraph, groupInDegree);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(itemList.toArray()));</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(groupList.toArray()));</span></span><br><span class="line">        <span class="keyword">if</span> (itemList.size() == <span class="number">0</span> || groupList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : itemList) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = group[item];</span><br><span class="line">            map.putIfAbsent(g, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(g).add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> g : groupList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> item : map.get(g)) &#123;</span><br><span class="line">                res[i++] = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">topologicalSort</span><span class="params">(Map&lt;Integer, Set&lt;Integer&gt;&gt; graph, Map&lt;Integer, Integer&gt; inDegree)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : graph.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree.getOrDefault(i, <span class="number">0</span>) == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> item = queue.poll();</span><br><span class="line">            res.add(item);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(item)) &#123;</span><br><span class="line">                inDegree.put(next, inDegree.getOrDefault(next, <span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(next) == <span class="number">0</span>) queue.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size() == graph.size() ? res : <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Algorithm/algorithm/union-find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Algorithm/algorithm/union-find/" itemprop="url">Union Find</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-09T15:25:58+08:00">
                2019-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><p>并查集原理，主要参考：<br><a href="https://www.youtube.com/watch?v=YKE4Vd1ysPI&amp;t=6s" target="_blank" rel="noopener">并查集（Disjoint-set union）第1讲</a><br><a href="https://www.youtube.com/watch?v=gpmOaSBcbYA" target="_blank" rel="noopener">并查集（Disjoint-set union）第2讲</a><br><a href="https://www.youtube.com/watch?v=VJnUwsE4fWA&amp;t=4s" target="_blank" rel="noopener">花花酱 Disjoint-set/Union-find Forest</a></p>
<p>学习整理后完成。</p>
<h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15732880108758.jpg" width="400" alt title></p>
<p>对于一个无向图，我们要如何才能找到是否存在环。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15732880663166.jpg" width="400" alt title></p>
<p>由图可知，我们通过构建 parent 数组，将各个节点关系使用有向图的形式进行构建。当遇到无法 union 的时候，表示两个节点具有相同的父节点，即寻找到环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parents = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        Arrays.fill(<span class="keyword">this</span>.parents, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = x;</span><br><span class="line">        <span class="keyword">while</span> (parents[root] != -<span class="number">1</span>) &#123;   </span><br><span class="line">            root = parents[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = findRoot(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = findRoot(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        parents[xRoot] = yRoot;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>以上不难看出，当数据量较大时候， <code>findRoot</code> 函数，将执行许多遍，并且都是无效的查找。如果我们在查找过程中，直接将其指向根节点，使得树深度变低，能够很好的加快查询效率。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15732885647780.jpg" width="400" alt title></p>
<p>此时对上面代码作出修改，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parents = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = x;</span><br><span class="line">        <span class="keyword">while</span> (parents[root] != root) &#123;   </span><br><span class="line">            parents[root] = parents[parents[root]];</span><br><span class="line">            root = parents[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = findRoot(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = findRoot(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        parents[xRoot] = yRoot;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="LeetCode-547-Friend-Circles"><a href="#LeetCode-547-Friend-Circles" class="headerlink" title="LeetCode 547 Friend Circles"></a>LeetCode 547 Friend Circles</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = M.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) set.add(uf.findRoot(i));</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-684-Redundant-Connection"><a href="#LeetCode-684-Redundant-Connection" class="headerlink" title="LeetCode 684 Redundant Connection"></a>LeetCode 684 Redundant Connection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = edges.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uf.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LeetCode-733-Sentence-Similarity-II"><a href="#LeetCode-733-Sentence-Similarity-II" class="headerlink" title="LeetCode 733 Sentence Similarity II"></a>LeetCode 733 Sentence Similarity II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (words1.length != words2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : words1) map.putIfAbsent(s, size++);</span><br><span class="line">    <span class="keyword">for</span> (String s : words2) map.putIfAbsent(s, size++);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ls : pairs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : ls) map.putIfAbsent(s, size++);</span><br><span class="line">    &#125;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(size);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ls : pairs) &#123;</span><br><span class="line">        uf.union(map.get(ls.get(<span class="number">0</span>)), map.get(ls.get(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = uf.findRoot(map.get(words1[i]));</span><br><span class="line">        <span class="keyword">int</span> root2 = uf.findRoot(map.get(words2[i]));</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Leetcode/leetcode/leetcode-Minimax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Leetcode/leetcode/leetcode-Minimax/" itemprop="url">leetcode Minimax (486, 877)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-07T22:32:53+08:00">
                2019-11-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode-486-877"><a href="#Leetcode-486-877" class="headerlink" title="Leetcode 486, 877"></a>Leetcode 486, 877</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 233, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。</span><br><span class="line">最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15731385926484.jpg" width="400" alt title></p>
<h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> score(s, <span class="number">0</span>, n-<span class="number">1</span>) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">score</span><span class="params">(s, l, r)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l &gt; r : return 0</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l </span>== r : <span class="keyword">return</span> s[l]</span><br><span class="line">    <span class="keyword">return</span> max(s[l] - score(s,l+<span class="number">1</span>,r), </span><br><span class="line">                s[r] - score(s,l,r-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>以上函数是最直观的认识，每一次都取最大的分数。<br>该算法时间复杂度 $O(2^n)$，空间复杂度为$O(n)$。</p>
<h3 id="Recursive-Memory"><a href="#Recursive-Memory" class="headerlink" title="Recursive + Memory"></a>Recursive + Memory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> score(s, <span class="number">0</span>, n-<span class="number">1</span>) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">score</span><span class="params">(s, l, r, m)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l &gt; r : return 0</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l </span>== r : <span class="keyword">return</span> s[l]</span><br><span class="line">    <span class="keyword">if</span> m[l][r] : <span class="keyword">return</span> m[l][r]</span><br><span class="line">    <span class="keyword">return</span> max(s[l] - score(s,l+<span class="number">1</span>,r), </span><br><span class="line">                s[r] - score(s,l,r-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>dp[i][j] 表示 i~j 最好的分数。</p>
<script type="math/tex; mode=display">
dp[i][j] = max\begin{cases}
nums[i]-dp[i+1][j]\\
nums[j]-dp[i][j-1]\\
\end{cases}
,i = n\to 0, j = i+1 \to n</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(nums[i] - dp[i+<span class="number">1</span>][j],</span><br><span class="line">                                nums[j] - dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Linux/linux/stack-and-pc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Linux/linux/stack-and-pc/" itemprop="url">Stack And PC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-03T15:10:23+08:00">
                2019-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>知识得来终觉浅，因此还是应该将收获的知识记录下来比较有用。<br>本文主要在 X86 体系结构下，函数栈调用的过程以及 PC 变化过程，以此对 C/C++、Java 等高级语言中的函数有一个深刻的认识。<br>本文使用 64 位编译器进行编译。主要讲函数栈调用及 PC 变化过程，其他基础知识仅提及而不深入讲解。</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://heamon7.gitbooks.io/cscw2-newly-to-assembly/content/" target="_blank" rel="noopener">C程序的汇编</a></li>
<li><a href="https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf" target="_blank" rel="noopener">Introduction_to_x64_Assembly</a></li>
</ol>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h2><p>X64 提供了 16 个通用寄存器，分别为 <code>%rax，%rbx，%rcx，%rdx，%rsi，%rdi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15</code>。<br>在 C 语言调用时输入参数前6位依次使用 <code>rdi, rsi, rdx, rcx, r8, r9</code> 寄存器，后面的参数压栈使用。<br>在 C 语言中返回结果一律记在 <code>rax</code> 中进行返回。</p>
<blockquote>
<p>caller register: <code>rax, rcx, rdx, r8, r9, r10, r11</code><br>callee register: <code>rbx, rbp, rdi, rsi, rsp, r12, r13, r14</code></p>
</blockquote>
<p>关键寄存器说明，以下三个指针在程序运行过程中起着关键的作用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>寄存器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>rbp</td>
<td>基指针</td>
</tr>
<tr>
<td>rsp</td>
<td>栈指针</td>
</tr>
<tr>
<td>rip</td>
<td>程序计数器</td>
</tr>
</tbody>
</table>
</div>
<h2 id="GDB-基础命令"><a href="#GDB-基础命令" class="headerlink" title="GDB 基础命令"></a>GDB 基础命令</h2><p>以下只给出部分实验中需要使用到的命令，具体命令可查看相应的手册。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>i r a</td>
<td>info register all，查看所有寄存器中数据</td>
</tr>
<tr>
<td>i r rax</td>
<td>info register rax， 查看指定寄存器数据</td>
</tr>
<tr>
<td>n</td>
<td>next 执行下一条指令，函数直接执行而不进入</td>
</tr>
<tr>
<td>s</td>
<td>step 进入函数内部调试</td>
</tr>
<tr>
<td>b func/34</td>
<td>breakpoint 断点</td>
</tr>
<tr>
<td>r</td>
<td>run 运行</td>
</tr>
<tr>
<td>disas</td>
<td>disassem 反汇编，将机器码转为汇编便于阅读</td>
</tr>
<tr>
<td>si，ni</td>
<td>针对汇编</td>
</tr>
</tbody>
</table>
</div>
<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><ol>
<li><p>编译，将 C 语言编译为汇编代码。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S add.c -o add.s</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g add.c -o add</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关参数</p>
<ul>
<li>-o：指定生成的输出文件；</li>
<li>-E：仅执行编译预处理；</li>
<li>-S：将C代码转换为汇编代码；</li>
<li>-Wall：显示警告信息；</li>
<li>-c：仅执行编译操作，不进行连接操作。</li>
<li>-g：表示在生成的目标文件中带调试信息</li>
</ul>
</li>
</ol>
<h2 id="Linux-X64-内存空间结构"><a href="#Linux-X64-内存空间结构" class="headerlink" title="Linux X64 内存空间结构"></a>Linux X64 内存空间结构</h2><p>在 X64 系统架构中，只使用 48 根地址线，虚拟内存空间划分时将 <code>0xFFFF0000~00000000——0xFFFFFFFF~FFFFFFFF</code> 划分给内核使用，<code>0x00000000~00000000——0x0000FFFF~FFFFFFFF</code> 划分给进程使用。</p>
<p>进程分布图如下所示：</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727708191411.jpg" width="600" alt title></p>
<h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><blockquote>
<p>实验均在 Linux 系统中进行</p>
</blockquote>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = sub(a, b);</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, res;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    res = add(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h2><p>通过调用 <code>gcc -S add.c -o add.s</code> 可获得相应的汇编代码如下所示。</p>
<blockquote>
<p>去除无关对齐代码后！！！自己编译后的代码有很多的对齐代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.file <span class="string">"add.c"</span></span><br><span class="line">.text</span><br><span class="line">.globl sub</span><br><span class="line">.type sub, @function</span><br><span class="line">sub:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq %rsp, %rbp</span><br><span class="line">    movl %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    subl <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    popq %rbp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl add</span><br><span class="line">.type add, @function</span><br><span class="line">add:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq %rsp, %rbp</span><br><span class="line">    subq $<span class="number">8</span>, %rsp</span><br><span class="line">    movl %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    movl %edx, %esi</span><br><span class="line">    movl %eax, %edi</span><br><span class="line">    call sub</span><br><span class="line">    movl %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl %edx, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl main</span><br><span class="line">.type main, @function</span><br><span class="line">main:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq %rsp, %rbp</span><br><span class="line">    subq $<span class="number">32</span>, %rsp</span><br><span class="line">    movl %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">    movq $rsi, <span class="number">-32</span>(%rbp)</span><br><span class="line">    movl $<span class="number">3</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl $<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl %edx, %esi</span><br><span class="line">    movl %eax, %edi</span><br><span class="line">    call add</span><br><span class="line">    movl %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl $<span class="number">0</span>, %eax</span><br><span class="line">    leav</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h2 id="C-与汇编联合编译"><a href="#C-与汇编联合编译" class="headerlink" title="C 与汇编联合编译"></a>C 与汇编联合编译</h2><blockquote>
<p>实验所需要的三个文件在下面提供下载，可直接点击下载，并在同一个文件夹中。以便实验室用。</p>
</blockquote>
<p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/main.c" target="_blank" rel="noopener">main.c 点击下载</a></p>
<p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/add.s" target="_blank" rel="noopener">add.s 点击下载</a></p>
<p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/makefile" target="_blank" rel="noopener">makefile 点击下载</a></p>
<h1 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h1><ol>
<li>下载 main.c, add.s, makefile 到同一文件夹中。</li>
<li>执行 <code>make</code> 命令完成代码编译链接，生产 test 执行文件。ps: <code>make clean</code> 用于清理。</li>
</ol>
<h2 id="运行到-add-函数调用前"><a href="#运行到-add-函数调用前" class="headerlink" title="运行到 add 函数调用前"></a>运行到 add 函数调用前</h2><ol>
<li>gdb --tui ./test</li>
<li>b main</li>
<li>r</li>
<li>b 16</li>
<li>c</li>
<li>disas 查看当前运行到的汇编位置，并用 ni 执行一条汇编，一点点执行，直到运行到 <code>0x000000000040054d &lt;+39&gt;: callq 0x400582 &lt;add&gt;</code></li>
</ol>
<p>此时查看堆栈寄存器 <code>rbp, rsp</code> 数据以及 程序计数器(pc)寄存器 <code>rip</code> 数据。</p>
<ul>
<li><p>查看 rbp, <code>i r rbp</code></p>
<p> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727700739966.jpg" width="600" alt title></p>
</li>
<li><p>查看 rsp, <code>i r rsp</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727700466006.jpg" width="600" alt title></p>
</li>
<li><p>查看 rip, <code>i r rip</code><br>   <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727722408396.jpg" width="600" alt title></p>
</li>
<li><p>查看当前上下文汇编代码, <code>disas</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">        0x0000000000400526 &lt;+0&gt;:     push   %rbp</span><br><span class="line">        0x0000000000400527 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">        0x000000000040052a &lt;+4&gt;:     sub    $0x20,%rsp</span><br><span class="line">        0x000000000040052e &lt;+8&gt;:     mov    %edi,-0x14(%rbp)</span><br><span class="line">        0x0000000000400531 &lt;+11&gt;:    mov    %rsi,-0x20(%rbp)</span><br><span class="line">        0x0000000000400535 &lt;+15&gt;:    movl   $0x3,-0xc(%rbp)</span><br><span class="line">        0x000000000040053c &lt;+22&gt;:    movl   $0x2,-0x8(%rbp)</span><br><span class="line">        0x0000000000400543 &lt;+29&gt;:    mov    -0x8(%rbp),%edx</span><br><span class="line">        0x0000000000400546 &lt;+32&gt;:    mov    -0xc(%rbp),%eax</span><br><span class="line">        0x0000000000400549 &lt;+35&gt;:    mov    %edx,%esi</span><br><span class="line">        0x000000000040054b &lt;+37&gt;:    mov    %eax,%edi</span><br><span class="line">    =&gt;  0x000000000040054d &lt;+39&gt;:    callq  0x400582 &lt;add&gt;</span><br><span class="line">        0x0000000000400552 &lt;+44&gt;:    mov    %eax,-0x4(%rbp)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从上面查到的几个信息中，我们可以看到 rbp=0x00007fffffffe460; rsp=0x00007fffffffe440; rip=0x000000000040054d<br>这与我们认知的程序的代码分布一致。栈由高地址空间0x0000FFFFFFFFFFFF 向下扩展，代码段由低地址空间向上排列。<br>在这里为何 rsp 比 rbp 小0x20，这与 <code>sub $0x20, %rsp</code> 这一指令相关，该指令通过计算当前栈帧所需栈大小从而预留使用空间，当然此时 0x20 是要大于实际所需要空间大小的。<br>通过计算实际 main 函数中，只有 a(int)、b(int)、res(int)、argc(int)、argv(char <em>)，int 使用 4 bytes，char </em> 使用 8 bytes，实际只需要 24 bytes即可，但此时却分配 32 bytes，这与<code>内存对齐</code>有关，如果对 Cache 相关知识有一定理解的话，应该能够明白是怎么回事。</p>
<p>此时有必要将当前整个栈结构画出来，可以通过 <code>x/20x 0x00007fffffffe440</code> 查看相应的内存数据。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727731848845.jpg" width="600" alt title></p>
<p>画成栈图如下所示：</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727730260019.jpg" width="300" alt title></p>
<ol>
<li>当前 rip: 400543, 下一条pc是 400552。<code>要注意调用 call 函数后是如何压栈的！！！！！记住400552这条数据！！！！</code></li>
<li>各个参数对应的内存位置在图中已标出，很明显能够发现有部分空余空间没事使用。验证之前提到的，为了内存对齐存在内存浪费。</li>
</ol>
<h2 id="调用-callq-add，进入-add-函数"><a href="#调用-callq-add，进入-add-函数" class="headerlink" title="调用 callq add，进入 add 函数"></a>调用 callq add，进入 add 函数</h2><ol>
<li>s </li>
</ol>
<p>此时，我们重新看一下栈内存的数据，栈指针信息，以及 pc 信息。</p>
<ul>
<li><p>查看 rbp, <code>i r rbp</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727736800515.jpg" width="600" alt title></p>
</li>
<li><p>查看 rsp, <code>i r rsp</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727736963729.jpg" width="600" alt title></p>
</li>
<li><p>查看 rip, <code>i r rip</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727737126609.jpg" width="600" alt title></p>
</li>
<li><p>查看栈内存数据, <code>x/20x 0x00007fffffffe430</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727737676013.jpg" width="600" alt title></p>
</li>
</ul>
<p>画成栈图如下所示：</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727739632434.jpg" width="300" alt title></p>
<ol>
<li>callq add, 相当于执行 pushq nextpc; jmp add</li>
<li>callq add, 将下一条需要执行的 PC 压入栈中！！</li>
</ol>
<h2 id="add-栈帧初始化"><a href="#add-栈帧初始化" class="headerlink" title="add 栈帧初始化"></a>add 栈帧初始化</h2><p>所谓 add 栈帧初始化，就是将 rbp、rsp 进行整理，为 add 函数执行做准备。主要指令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp      <span class="comment">// 将rbp压栈</span></span><br><span class="line">movq %rsp, %rbp <span class="comment">// rsp 与 rbp 指向同一地址</span></span><br><span class="line">subq $<span class="number">8</span>, %rsp   <span class="comment">// 计算 add 所需内存空间</span></span><br></pre></td></tr></table></figure>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727747048766.jpg" width="600" alt title></p>
<p>执行完以上三条指令后，新的栈图如下：</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727747316115.jpg" width="300" alt title></p>
<h2 id="运行到-sub-函数运行前"><a href="#运行到-sub-函数运行前" class="headerlink" title="运行到 sub 函数运行前"></a>运行到 sub 函数运行前</h2><ol>
<li>b 26</li>
<li>c</li>
</ol>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727750724409.jpg" width="600" alt title></p>
<p>新的栈图如下：</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727751660036.jpg" width="300" alt title></p>
<h2 id="调用-callq-sub-进入-sub-函数"><a href="#调用-callq-sub-进入-sub-函数" class="headerlink" title="调用 callq sub, 进入 sub 函数"></a>调用 callq sub, 进入 sub 函数</h2><ol>
<li>s</li>
</ol>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727754090560.jpg" width="600" alt title></p>
<p>新的栈图如下：</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727756659616.jpg" width="300" alt title></p>
<h2 id="sub-栈帧初始化"><a href="#sub-栈帧初始化" class="headerlink" title="sub 栈帧初始化"></a>sub 栈帧初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp      <span class="comment">// 将rbp压栈</span></span><br><span class="line">movq %rsp, %rbp <span class="comment">// rsp 与 rbp 指向同一地址</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里有一点要特别注意，在 add 中，我们会使用 <code>subq $8, %rsp</code> 初始化一个栈空间，但在这里没有进行这一操作，原因在于 add 函数中需要调用 sub 函数，而 sub 函数中不需要调用任何函数。</p>
</blockquote>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727759037491.jpg" width="600" alt title></p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727759536263.jpg" width="300" alt title></p>
<h2 id="运行到-sub-popq-rbp-之前"><a href="#运行到-sub-popq-rbp-之前" class="headerlink" title="运行到 sub popq %rbp 之前"></a>运行到 sub popq %rbp 之前</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727762610279.jpg" width="600" alt title></p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727762661166.jpg" width="300" alt title></p>
<h2 id="popq-rbp"><a href="#popq-rbp" class="headerlink" title="(*) popq %rbp"></a>(*) popq %rbp</h2><p>由于当前 rsp, rbp 都指向 0x00007fff~ffffe418，此时调用 <code>popq %rbp</code> 相当于执行 以下两条指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq +8(%rsp), %rbp</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727767223708.jpg" width="300" alt title></p>
<h2 id="ret-退出-sub-函数"><a href="#ret-退出-sub-函数" class="headerlink" title="(*) ret 退出 sub 函数"></a>(*) ret 退出 sub 函数</h2><p>ret 实际做的就是恢复 rip 指向原函数需要执行的代码。相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq +8(%rsp), %rip</span><br><span class="line">addq $8, %rsp</span><br><span class="line">jmp %rip</span><br></pre></td></tr></table></figure>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727770628739.jpg" width="300" alt title></p>
<p>此时 <code>rsp, rbp</code> 恢复到调用 sub 函数之前的状态。</p>
<h2 id="leaveq"><a href="#leaveq" class="headerlink" title="(*) leaveq"></a>(*) leaveq</h2><p>leaveq 相当于以下两条指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq %rbp, %rsp</span><br><span class="line">popq %rbp</span><br></pre></td></tr></table></figure></p>
<p>与上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp</span><br><span class="line">movq %rsp, %rbp</span><br></pre></td></tr></table></figure></p>
<p>对应。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727776222080.jpg" width="300" alt title></p>
<h2 id="ret-退出-add-函数"><a href="#ret-退出-add-函数" class="headerlink" title="(*) ret 退出 add 函数"></a>(*) ret 退出 add 函数</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727788240846.jpg" width="300" alt title></p>
<h1 id="实验整体过程"><a href="#实验整体过程" class="headerlink" title="实验整体过程"></a>实验整体过程</h1><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727788811916.jpg" alt title></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可能以上的过程写的比较繁杂，但是如果细细看，并且能够将最后整个栈过程完整画出来的话，应该能够对函数调用有一个十分深刻的印象。<br>PS：如果需要的话，后期我可以录制一个视频，详细讲解下相关的知识，以做备份。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Linux/linux/computer-cpu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Linux/linux/computer-cpu/" itemprop="url">Computer CPU</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-02T21:57:04+08:00">
                2019-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文主要介绍 CPU 如何一步一步进行优化，最终成为当前这样的体系架构。<br>本文知识主要来源于 <a href="https://time.geekbang.org/column/article/91427" target="_blank" rel="noopener">深入浅出计算机组成原理</a> 、<code>计算机体系结构（量化研究方法）</code> 、<code>计算机组成与设计硬件/软件接口</code>。</p>
</blockquote>
<h1 id="CPU-性能与功耗"><a href="#CPU-性能与功耗" class="headerlink" title="CPU 性能与功耗"></a>CPU 性能与功耗</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol>
<li>响应时间（执行时间），表示程序运行所需要的时间，体现了 CPU 运行速度。</li>
<li>吞吐率（带宽），表示程序运行能够处理的数据，体现了 CPU 处理数据的能力。</li>
</ol>
<p><code>响应时间</code>可以由以下公式决定：</p>
<script type="math/tex; mode=display">
CPU时间 = 指令数 \times  CPI \times  时钟频率</script><ul>
<li>指令数：Instruction Num，由编译器以及程序员决定。</li>
<li>CPI(Cycles Per Instruction)：每个指令周期，通过 PipeLine、超流水线 等技术使得一条指令所需 CPU Cycle 尽可能地低。<em>对 CPI 的优化是计算机体系结构中最重要的一环</em>。</li>
<li>时钟频率：Clock Cycle Time，由计算机主频决定。</li>
</ul>
<p><code>吞掉量</code>通过超标量(Superscalar)、超线程、SIMD 等技术在不改变<code>响应时间</code>基础上，使得系统在相同时间内能够处理更多的数据。</p>
<h2 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h2><p>我们的 CPU，一般被被叫做超大规模集成电路(Very Large Scale Integration, VLSI)，CPU 实际是由大量的集成电路组成。<code>功耗</code>公式如下:</p>
<script type="math/tex; mode=display">
功耗  \approx 1/2 \times 负载电容 \times 电压^{2} \times 晶体管数量</script><p>提高 CPU 主频则需要加大电压、增加晶体管，这将导致功耗不断上升，所有元器件均有熔点，因此我们不能不断地增大功耗。这就是<code>功耗墙</code>的来源。</p>
<p>既然，我们无法通过不断增加频率来提高 CPU 的“响应时间”，因此有人就提出了提高“吞吐率”使 CPU 在相同时间内能够处理更多的数据，即<code>通过并行提升性能</code>。</p>
<p>但是程序的并行度也不是能够一直提升的，这就涉及到 <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank" rel="noopener">Amdahl’s Law</a>，即优化后的执行时间也是有上限的，该部分主要受无法并行化的代码所花费时间的影响。</p>
<script type="math/tex; mode=display">
优化后的执行时间 = 受优化影响的执行时间/加倍速度 + 不受影响的执行时间</script><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728507499351.jpg" width="400" alt title></p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728508178762.jpg" width="400" alt title></p>
<h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><h1 id="CPU-的优化"><a href="#CPU-的优化" class="headerlink" title="CPU 的优化"></a>CPU 的优化</h1><h2 id="单指令周期-CPU"><a href="#单指令周期-CPU" class="headerlink" title="单指令周期 CPU"></a>单指令周期 CPU</h2><p>对于 CPU 而言，每次都需要处理一条指令，该部分指令由时钟频率驱动，一个 Cycle 即执行一条指令。由于不同指令所需实际执行时间不同，浮点数乘法所消耗的时间一定大于简单的移动指令。<br>因此单指令周期的 CPU，都需要等待满一个时钟周期，浪费了等待时间，同时限制了时钟频率的提升。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728512154282.jpg" width="400" alt title></p>
<h2 id="PipeLine"><a href="#PipeLine" class="headerlink" title="PipeLine"></a>PipeLine</h2><p>为了提高 CPU 的时钟频率，通过将指令按照不同的小步骤进行拆分，即形成了<code>流水线</code>工作。</p>
<p>此时不再需要确保最复杂的那条指令在一个时钟周期内完成，而只需要保证最复杂的<code>流水线级</code>的操作在一个时钟周期内完成即可。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728514408821.jpg" width="400" alt title></p>
<p>通过 PipeLine 处理后，可以大大提升 CPU 主频，提升运行速度。现代的 ARM 或者 Intel 的 CPU，流水线级数可以到14级。</p>
<blockquote>
<p>超长流水线瓶颈，增加流水线深度，其实是有性能成本，在读写流水线寄存器时，会有开销。同时还会带来<strong>结构冒险、数据冒险、控制冒险等其他依赖问题</strong>。<br>为了应付各类冒险问题，采用<strong>乱序执行、分支预测</strong>等解决方案。<br>流水线越长，这一类冒险问题就更难解决。</p>
</blockquote>
<h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><p>所谓结构冒险，就是在访问内存和取指令的时候，都需要操作程序内存，但是我们只有<em>一个地址译码器</em>，此时便会产生资源冲突。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728518021525.jpg" width="400" alt title></p>
<p>为了解决该冲突，可以将内存分为两部分，一个用于存放<code>指令</code>，另一个存放<code>数据</code>。</p>
<p>把内存拆成两部分的解决方案，被称为<strong>哈佛架构</strong>，我们使用的<strong>冯·诺依曼体系结构</strong>又叫<strong>普林斯顿架构</strong>，该体系结构没有拆分内存，而是在高速缓存部分分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728519505058.jpg" width="400" alt title></p>
<h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><ul>
<li><p>先写后读，数据依赖</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 先写1 再读1</span></span><br><span class="line">    a = a + <span class="number">2</span>;</span><br><span class="line">    b = a + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先读后写，反依赖</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    a = b + a;</span><br><span class="line">    <span class="comment">// 若下面早于上面完成</span></span><br><span class="line">    b = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写后再读，输出依赖</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先写1 再写1</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>使用 nop 保证有数据依赖的执行在上一条执行后继续。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728523442480.jpg" width="400" alt title></p>
</li>
<li><p>操作数转发，将前一条指令执行结果直接作为后一条指令的输入。减少 nop。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728524636993.jpg" width="400" alt title></p>
</li>
<li><p>由于不同指令不存在依赖关系，可以通过乱序执行，将没有依赖关系的指令提前，减少 nop 时间。乱序执行，有点类似于 <strong>线程池</strong>。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728579747159.jpg" width="300" alt title></p>
</li>
</ol>
<h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p>以上假设都是基于代码都是顺序执行的，<code>取指令</code> 和 <code>指令译码</code> 不会遇到任何停顿，当遇到跳转指令时，为了保证争取，不得不等待造成延迟。</p>
<p>当有判断或跳转时，便于要分支预测的来提高运行效率，否则就需要通过 nop 直至此时判断完成。</p>
<ol>
<li><p>分支预测，便是假装分支不发生，即<strong>静态预测</strong>成功率在50%，当发现错误时，就将不要的数据丢弃。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728583136389.jpg" width="400" alt title></p>
</li>
<li><p>动态分支预测，即今天下雨，就猜明天也下雨。即用1比特保存当前预测结果，并用该结果作为下一次分支比较。还可以用2比特预测，叫<strong>双模态预测</strong>。</p>
</li>
</ol>
<blockquote>
<p>注意在不改变代码基础上，将循环少的放在外面。</p>
</blockquote>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728584085043.jpg" width="400" alt title></p>
<h2 id="Superscalar-和-VLIW使得-CPU-吞吐率大于1"><a href="#Superscalar-和-VLIW使得-CPU-吞吐率大于1" class="headerlink" title="Superscalar 和 VLIW使得 CPU 吞吐率大于1"></a>Superscalar 和 VLIW使得 CPU 吞吐率大于1</h2><h3 id="Superscalar"><a href="#Superscalar" class="headerlink" title="Superscalar"></a>Superscalar</h3><p>超标量(Superscalar)，即多发射的结构，是在原有 PipeLine 基础上，通过增加多条流水线，达到一次取多条指令执行。如此并能使得 CPU 吞吐率高于 1。</p>
<p>此时需要增加的只有两个部分：修改取指令一次多个；增加多个译码器。译码完成的代码即可分发器被分发到各个执行 ALU 单元。</p>
<p>通过指令多发射设计，可以得到超标量，即并行执行多条指令。</p>
<p> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728597977989.jpg" width="400" alt title></p>
<p> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728598026707.jpg" width="400" alt title></p>
<h3 id="VLIW"><a href="#VLIW" class="headerlink" title="VLIW"></a>VLIW</h3><p>VLIW(Very Long Instruction Word)，通过将指令打包，使得一次执行时能够执行多条指令，从而提升吞吐率。</p>
<blockquote>
<p>但是该方法由于无法向前兼容，最后导致失败。</p>
</blockquote>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728599785703.jpg" width="400" alt title></p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728599874568.jpg" width="400" alt title></p>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超长流水线，意味着在流水线中指令越多，相互依赖关系越多，不得不面临冒险。2002 年底，Intel 在的 3.06GHz 主频的 Pentium 4 CPU上，第一次引入了超线程技术。<br>超线程技术，就是在CPU中同时执行多个程序的指令。<br>增加一份PC寄存器、指令寄存器、条件码寄存器。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728604457643.jpg" width="400" alt title></p>
<h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>SIMD，Single Instruction Multiple Data。<br>SIMD 在获取数据和执行指令时，都做到了并行，一方面，再从内存读取数据的时候，SIMD是一次性读取多个数据，在SSE指令集中，CPU添加了8个16Bytes的寄存器，一个寄存器一次性可以加载4个整数。</p>
<p>Numpy，使用 SIMD 技术。</p>
<p>基于 SIMD 的向量计算指令，被称为 MMX（Matrix Math eXtensions） 指令集，即矩阵数学扩展。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728604706569.jpg" width="400" alt title></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>单指令周期 CPU 需要保证最耗时的指令在一个时钟周期内完成，限制主频发展。因此改进成 PipeLine。</p>
</li>
<li><p>PipeLine 可以分为 <code>IF、ID、EX、MEM、WB</code>， 只需要保证最复杂的<code>流水线级</code>的操作在一个时钟周期内完成即可，极大提升了主频发展。<br>但是 PipeLine 会导致 <code>结构冒险、数据冒险、控制冒险</code> 等。<br>结构冒险，通过 <code>D-L1 Cache、I-L1 Cache</code> 防止冲突。<br>数据冒险，通过增加 <code>nop、数据转发、乱序执行</code> 等手段防止冒险出现。<br>控制冒险，通过 <code>分支预测</code> 防止。</p>
</li>
<li><p>为了使 CPU 吞吐率高于 1，采用 Superscalar 和 VLIW 技术。<br>Superscalar 利用 IF 一次取多条指令，并由多个 ID 译码，并分发给 ALU，从而达到多条流水线同时执行的效率。<br>VLIW 将多个指令打包成一个指令，从而在执行时，同时执行多条，但是由于无法向前兼容最终淘汰。</p>
</li>
<li><p>Superscalar 导致多条流水线间的依赖关系过于复杂，不得不面临冒险。为减少冲突因此提出超线程手段，通过增加一份 <code>PC寄存器、指令寄存器、条件码寄存器</code> 使得一个 CPU 可以同时运行两个无关的线程代码。</p>
</li>
<li><p>SIMD，Single Instruction Multiple Data。通过一条指令操作多条数据，从而增加吞吐率，该技术也促使了 GPU 相关的发展。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Leetcode/leetcode/leetcode-The-Skyline-Problem-218/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Leetcode/leetcode/leetcode-The-Skyline-Problem-218/" itemprop="url">leetcode The Skyline Problem 218</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-27T21:02:12+08:00">
                2019-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode-218-The-Skyline-Problem"><a href="#Leetcode-218-The-Skyline-Problem" class="headerlink" title="Leetcode 218. The Skyline Problem"></a>Leetcode 218. The Skyline Problem</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15721814780081.jpg" width="300" height="200" alt title></p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15721814871884.jpg" width="300" height="200" alt title></p>
<p>每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。</p>
<p>例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。</p>
<p>输出是以 [ [x1,y1], [x2, y2], [x3, y3], … ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p>例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。</p>
<p>说明:</p>
<p>任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。<br>输入列表已经按左 x 坐标 Li  进行升序排列。<br>输出列表必须按 x 位排序。<br>输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15721815671065.jpg" width="600" height="300" alt title></p>
<ol>
<li>将 [2,9,10] 转化为 [2,-10], [9,10]</li>
<li>从左往右排序</li>
<li>从左往右扫描线，每次从 PriorityQueue 中取出当前最高的点，与前一个点比较，如果是新的点则加入，否则下一次循环。</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; heights = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] build: buildings) &#123;</span><br><span class="line">        heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;build[<span class="number">0</span>], -build[<span class="number">2</span>]&#125;);</span><br><span class="line">        heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;build[<span class="number">1</span>], build[<span class="number">2</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(heights, (a,b)-&gt; a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    pq.offer(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] h: heights) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pq.offer(-h[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pq.remove(h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.peek();</span><br><span class="line">        <span class="keyword">if</span> (cur != prev) &#123;</span><br><span class="line">            res.add(Arrays.asList(h[<span class="number">0</span>], cur));</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Leetcode/leetcode/leetcode-house-rob-198-213-337/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Leetcode/leetcode/leetcode-house-rob-198-213-337/" itemprop="url">leetcode house rob 198, 213, 337</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-24T21:57:42+08:00">
                2019-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode-198-House-Rob-I"><a href="#Leetcode-198-House-Rob-I" class="headerlink" title="Leetcode 198. House Rob I"></a>Leetcode 198. House Rob I</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15719260481158.jpg" width="600" height="400" alt="HouseRobI" title="HouseRobI"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> notRob = <span class="number">0</span>, curRob = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> preRob = Math.max(notRob, curRob);</span><br><span class="line">        curRob = notRob + num;</span><br><span class="line">        notRob = preRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(curRob, notRob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-213-House-Rob-II"><a href="#Leetcode-213-House-Rob-II" class="headerlink" title="Leetcode 213. House Rob II"></a>Leetcode 213. House Rob II</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15719265087693.jpg" width="600" height="400" alt="HouseRobII" title="HouseRobII"></p>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> notRob = <span class="number">0</span>, curRob = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preRob = Math.max(notRob, curRob);</span><br><span class="line">        curRob = notRob + nums[i];</span><br><span class="line">        notRob = preRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(curRob, notRob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-337-House-Rob-III"><a href="#Leetcode-337-House-Rob-III" class="headerlink" title="Leetcode 337. House Rob III"></a>Leetcode 337. House Rob III</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p>输入: [3,2,3,null,3,null,1]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15719272795222.jpg" width="600" height="400" alt="HouseRobI" title="HouseRobI"></p>
<h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = helper(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] helper(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] left = helper(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = helper(root.right);</span><br><span class="line">    <span class="keyword">int</span> notRob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> curRob = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;notRob, curRob&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/Leetcode/leetcode/leetcode-best-time-to-buy-and-sell-stock-121-122-123-188/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/Leetcode/leetcode/leetcode-best-time-to-buy-and-sell-stock-121-122-123-188/" itemprop="url">leetcode best time to buy and sell stock 121,122,123,188,714</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-20T21:05:27+08:00">
                2019-10-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">股票相关解答说明</a></p>
</blockquote>
<h1 id="Leetcode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#Leetcode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Leetcode 121. Best Time to Buy and Sell Stock"></a>Leetcode 121. Best Time to Buy and Sell Stock</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>[7,1,5,3,6,4]<br>5</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于只能买卖一次，因此每次都减去至今为止最小的买入价格就行。<br>[7, 1, 5, 3, 6, 4] - [7, 1, 1, 1, 1, 1]<br>至今最小可以使用一个变量 curMin 进行记录。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMin = prices[<span class="number">0</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        res = Math.max(res, prices[i]-curMin);</span><br><span class="line">        curMin = Math.min(curMin, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Leetcode 122. Best Time to Buy and Sell Stock II"></a>Leetcode 122. Best Time to Buy and Sell Stock II</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>[7,1,5,3,6,4]<br>7</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于没有买卖次数限制，因此只要后面比前面大就进行交易即可。</p>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        res += prices[i] &gt; prices[i-<span class="number">1</span>] ? prices[i]-prices[i-<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>参考188</p>
<h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[k][i] = max(dp[k][i-1], dp[k-1][j] + prices[i] - prices[j]) j from 0 to i-1</span></span><br><span class="line"><span class="comment">// dp[k][i] = max(dp[k][i-1], tempMax + prices[i]), tempMax = dp[k-1][j]-prices[j] </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][prices.length];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempMax = dp[k-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[k][i] = Math.max(dp[k][i-<span class="number">1</span>], prices[i] + tempMax);</span><br><span class="line">            tempMax = Math.max(tempMax, dp[k-<span class="number">1</span>][i] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>][prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Leetcode-188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Leetcode 188. Best Time to Buy and Sell Stock IV"></a>Leetcode 188. Best Time to Buy and Sell Stock IV</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;t=1332s" target="_blank" rel="noopener">Buy/Sell Stock With K transactions To Maximize Profit Dynamic Programming</a></p>
<script type="math/tex; mode=display">
dp[k][i], k 表示交易次数，i 表示第几天。
\\
dp[k][i] = max\begin{cases}
dp[k][i-1] \qquad & 在第 i 天没有交易 \\
prices[i]-prices[j]+dp[k-1][j] \qquad & 在第 j 天进行交易， j := 0 to i-1
\end{cases} \\</script><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15715799404340.jpg" width="300" alt title></p>
<p>可以将上面的动态规划公式进行修改得到：</p>
<script type="math/tex; mode=display">
dp[k][i] = max\begin{cases}
dp[k][i-1] \qquad & 在第 i 天没有交易 \\
max(dp[k-1][j]-prices[j]) + prices[i] \qquad & 在第 j 天进行交易， j := 0 to i-1
\end{cases} \\</script><h2 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[k][i] = j不买 dp[k][i-1]</span></span><br><span class="line"><span class="comment">//          = j买  max(dp[k-1][j] + p[i] - p[j]) j = 0..i-1</span></span><br><span class="line"><span class="comment">//          = j买  max(dp[k-1][j] - p[j]) + p[i] j = 0..i-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][prices.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">1</span>; kk &lt;= k; kk++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp[kk-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;       </span><br><span class="line">            dp[kk][i] = Math.max(dp[kk][i-<span class="number">1</span>], temp+prices[i]);</span><br><span class="line">            temp = Math.max(temp, dp[kk-<span class="number">1</span>][i] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with Cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with Cooldown</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是对 <a href="#Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II">LeetCode 122</a> 的扩展。</p>
<h2 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h2><h1 id="Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee"></a>Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是对 <a href="#Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II">LeetCode 122</a> 的扩展。</p>
<h2 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h2><blockquote>
<p>cash 表示未持有股票的现金部分。<br>hold 表示持有股票。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        cash = Math.max(cash, hold+prices[i]-fee);</span><br><span class="line">        hold = Math.max(hold, cash-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">klutzoder</p>
              <p class="site-description motion-element" itemprop="description">I'm no body!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">klutzoder</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
