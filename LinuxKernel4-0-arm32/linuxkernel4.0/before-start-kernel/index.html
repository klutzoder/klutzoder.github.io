<!DOCTYPE html>
<html lang="chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.klutzoder.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Qemu 调试 详见 《奔跑吧 Linux内核》，有详细的 Qemu 调试内核的过程。  Qemu 调试配置123456789101112131415161718192021222324# 准备环境$ sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential git gdb-arm-none-ea">
<meta name="keywords" content="LinuxKernel4.0-arm32">
<meta property="og:type" content="article">
<meta property="og:title" content="一 Before start kernel">
<meta property="og:url" content="http://www.klutzoder.com/LinuxKernel4-0-arm32/linuxkernel4.0/before-start-kernel/index.html">
<meta property="og:site_name" content="Klutzoder&#39;Blog">
<meta property="og:description" content="Qemu 调试 详见 《奔跑吧 Linux内核》，有详细的 Qemu 调试内核的过程。  Qemu 调试配置123456789101112131415161718192021222324# 准备环境$ sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential git gdb-arm-none-ea">
<meta property="og:locale" content="chinese">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15808044320368.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811402462093.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811406851839.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811426560522.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811429476484.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811474554381.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811475656613.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">
<meta property="og:updated_time" content="2021-01-02T03:37:23.773Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一 Before start kernel">
<meta name="twitter:description" content="Qemu 调试 详见 《奔跑吧 Linux内核》，有详细的 Qemu 调试内核的过程。  Qemu 调试配置123456789101112131415161718192021222324# 准备环境$ sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential git gdb-arm-none-ea">
<meta name="twitter:image" content="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15808044320368.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10">

<link rel="canonical" href="http://www.klutzoder.com/LinuxKernel4-0-arm32/linuxkernel4.0/before-start-kernel/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'chinese'
  };
</script>

  <title>一 Before start kernel | Klutzoder'Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f9da22b88ec7dbab09a41dacfefb5043";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Klutzoder'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="chinese">
    <link itemprop="mainEntityOfPage" href="http://www.klutzoder.com/LinuxKernel4-0-arm32/linuxkernel4.0/before-start-kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="klutzoder">
      <meta itemprop="description" content="I'm no body!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Klutzoder'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一 Before start kernel
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-03 19:40:11" itemprop="dateCreated datePublished" datetime="2020-02-03T19:40:11+08:00">2020-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-02 11:37:23" itemprop="dateModified" datetime="2021-01-02T11:37:23+08:00">2021-01-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/LinuxKernel4-0-arm32/" itemprop="url" rel="index"><span itemprop="name">LinuxKernel4.0-arm32</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Qemu-调试"><a href="#Qemu-调试" class="headerlink" title="Qemu 调试"></a>Qemu 调试</h1><blockquote>
<p>详见 《奔跑吧 Linux内核》，有详细的 Qemu 调试内核的过程。</p>
</blockquote>
<h2 id="Qemu-调试配置"><a href="#Qemu-调试配置" class="headerlink" title="Qemu 调试配置"></a>Qemu 调试配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 准备环境</span><br><span class="line">$ sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential git gdb-arm-none-eabi</span><br><span class="line"># 下载仓库</span><br><span class="line">$ git clone git@github.com:figozhang/runninglinuxkernel_4<span class="number">.0</span>.git</span><br><span class="line">$ git checkout rlk_basic</span><br><span class="line"># 编译内核</span><br><span class="line">$ cd runninglinuxkernel<span class="number">-4.0</span></span><br><span class="line">$ <span class="keyword">export</span> ARCH=arm</span><br><span class="line">$ <span class="keyword">export</span> CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line">$ make vexpress_defconfig</span><br><span class="line">$ make menuconfig</span><br><span class="line"># 在 _install_arm32/dev 下创建设备节点</span><br><span class="line">$ cd _install_arm32</span><br><span class="line">$ mkdir dev</span><br><span class="line">$ cd dev</span><br><span class="line">$ sudo mknod console c <span class="number">5</span> <span class="number">1</span></span><br><span class="line"># 开始编译</span><br><span class="line">$ make bzImage -j4</span><br><span class="line">$ make dtbs</span><br><span class="line"></span><br><span class="line"># 一个 session 打开 ， 退出 ctrl+a+x, killall qemu-system-arm</span><br><span class="line">$ ./run.sh arm32 debug </span><br><span class="line"></span><br><span class="line"># 另一个 session 调试</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Qemu-调试-mmu-之前"><a href="#Qemu-调试-mmu-之前" class="headerlink" title="Qemu 调试 mmu 之前"></a>Qemu 调试 mmu 之前</h2><p>在 Qemu 调试过程中分为两个阶段: mmu 启动前; mmu启动后。因此，必须要了解<strong>链接地址</strong>与<strong>装载地址</strong>之间的差别。<br>对于<code>vexpress</code>板子而言，其dts文件在<code>arch/arm/boot/dts/vexpress-v2p-ca9.dts</code>，其物理内存从0x6000_0000开始。</p>
<p>因此，为了能够调试 mmu 启动前的代码，需要将符号表加载到能够访问的物理地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arm-none-eabi-gdb --tui 启动调试</span></span><br><span class="line">$ target remote localhost:<span class="number">1234</span></span><br><span class="line">$ load vmlinux <span class="number">-0x60000000</span></span><br><span class="line">$ add-symbol-file vmlinux <span class="number">0x60008280</span> -s .head.text <span class="number">0x60008000</span> -s .rodata <span class="number">0x60b18000</span> </span><br><span class="line"><span class="comment">// 通过 arm-none-eabi-readelf -S vmlinux 查看对应的 .text off: 008280; .head.text off: 008000; .rodata off: b18000。</span></span><br><span class="line">$ <span class="built_in">set</span> $pc=<span class="number">0x60008000</span></span><br><span class="line">$ <span class="built_in">set</span> $r2=<span class="number">0x63200000</span>  <span class="comment">// 调试 dtb 时使用</span></span><br><span class="line">$ b stext</span><br><span class="line">$ c</span><br></pre></td></tr></table></figure>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>为什么需要关闭 MMU? 内核需要自己创建页表，在创建页表前，内核实际运行在物理地址，必须关闭 MMU。<br>为什么 D-cache 关闭？因为内核运行到 stext 时，若 D-cache 开始，则会从 cache 中获取数据，可能缓存 uboot 或 解压时留下的数据，这部分数据是无效的，可能导致数据异常。</p>
</blockquote>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15808044320368.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p>
<blockquote>
<p>此时系统满足的条件</p>
<ul>
<li>MMU=off, D-cache=off, C-cache=don’t care</li>
<li>r0=0, r1=machine nr, r2=atags or dtb pointer</li>
</ul>
</blockquote>
<p>内核装载后，pc 指向 stext 所在物理地址 0x6000_8000，执行内核代码。此时，内核页表、c程序执行的堆栈、必要硬件配置还未设置完成，因此无法使用 c 语言程序，且只能使用地址无关的汇编代码(bl等)。</p>
<h1 id="开启-SVC-关闭中断"><a href="#开启-SVC-关闭中断" class="headerlink" title="开启 SVC 关闭中断"></a>开启 SVC 关闭中断</h1><p><a href="https://developer.arm.com/docs/ddi0595/b/aarch32-system-registers/cpsr" target="_blank" rel="noopener">cpsr 寄存器</a></p>
<h2 id="hyp-stub-install"><a href="#hyp-stub-install" class="headerlink" title="__hyp_stub_install"></a>__hyp_stub_install</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/hyp-stup.S:40</span></span><br><span class="line">.macro	store_primary_cpu_mode reg1, reg2, reg3</span><br><span class="line">mrs	\reg1, cpsr</span><br><span class="line"><span class="keyword">and</span>	\reg1, \reg1, #MODE_MASK @ MODE_MASK=<span class="number">1f</span>, 获取 cpsr低<span class="number">5</span>位数据</span><br><span class="line">adr	\reg2, .L__boot_cpu_mode_offset @     读取 .L__boot_cpu_mode_offset 所在内存地址</span><br><span class="line">ldr	\reg3, [\reg2] @ __boot_cpu_mode 存放地址</span><br><span class="line">str	\reg1, [\reg2, \reg3] @ 将当前运行模式保存到 __boot_cpu_mode 之中</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>由上面代码分析可知，<code>store_primary_cpu_mode</code>所要做的事情便是从 <code>cpsr</code> 状态寄存器中读取 <code>boot</code> 启动后的运行模式，然后将其存储到 <code>__boot_cpu_mode</code> 变量中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/hyp-stup.S:54</span></span><br><span class="line">.macro	compare_cpu_mode_with_primary mode, reg1, reg2, reg3</span><br><span class="line">adr	\reg2, .L__boot_cpu_mode_offset</span><br><span class="line">ldr	\reg3, [\reg2]</span><br><span class="line">ldr	\reg1, [\reg2, \reg3]</span><br><span class="line">cmp	\mode, \reg1		@ matches primary CPU boot mode?</span><br><span class="line">orrne	\reg1, \reg1, #BOOT_CPU_MODE_MISMATCH @ 不等</span><br><span class="line">strne	\reg1, [\reg2, \reg3]	@ record what happened <span class="keyword">and</span> give up</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<p>比较运行模式是否与 __boot_cpu_mode 一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/hyp-stup.S:87</span></span><br><span class="line">ENTRY(__hyp_stub_install)</span><br><span class="line">    store_primary_cpu_mode r4, r5, r6</span><br><span class="line">ENDPROC(__hyp_stub_install)</span><br><span class="line">ENTRY(__hyp_stub_install_secondary)</span><br><span class="line">	mrs	r4, cpsr</span><br><span class="line">	<span class="keyword">and</span>	r4, r4, #MODE_MASK</span><br><span class="line">	compare_cpu_mode_with_primary	r4, r5, r6, r7 @ 比较运行模式是否与 __boot_cpu_mode 一致</span><br><span class="line">	retne	lr</span><br><span class="line">	cmp	r4, #HYP_MODE</span><br><span class="line">	retne	lr			@ give up <span class="keyword">if</span> the CPU is <span class="keyword">not</span> in HYP mode, 默认是 svc 模式，若当前为 HYP_MODE 则继续运行，但是在本案例中，默认启动为 svc</span><br></pre></td></tr></table></figure>
<p>综上，该函数做了两件事情：</p>
<ol>
<li>通过 <code>store_primary_cpu_mode</code> 设置 <code>__boot_cpu_mode</code> 变量</li>
<li>对比当前运行模式是否为 <code>__boot_cpu_mode</code></li>
</ol>
<h2 id="safe-svcmode-maskall"><a href="#safe-svcmode-maskall" class="headerlink" title="safe_svcmode_maskall"></a>safe_svcmode_maskall</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/asm/assembler.h</span></span><br><span class="line">.macro safe_svcmode_maskall reg:req</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 6 &amp;&amp; !defined(CONFIG_CPU_V7M)</span></span><br><span class="line">	mrs	\reg , cpsr</span><br><span class="line">	eor	\reg, \reg, #HYP_MODE</span><br><span class="line">	tst	\reg, #MODE_MASK</span><br><span class="line">	bic	\reg , \reg , #MODE_MASK @ 清<span class="number">0</span>位</span><br><span class="line">	orr	\reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE @ 设置 svc 模式以及关闭中断</span><br><span class="line">THUMB(	orr	\reg , \reg , #PSR_T_BIT	)</span><br><span class="line">	bne	<span class="number">1f</span></span><br><span class="line">	orr	\reg, \reg, #PSR_A_BIT</span><br><span class="line">	adr	lr, BSYM(<span class="number">2f</span>)</span><br><span class="line">	msr	spsr_cxsf, \reg</span><br><span class="line">	__MSR_ELR_HYP(<span class="number">14</span>)</span><br><span class="line">	__ERET</span><br><span class="line"><span class="number">1</span>:	msr	cpsr_c, \reg @ 写入状态寄存器</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/uapi/asm/ptrace.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SVC_MODE    0x00000013</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSR_F_BIT   0x00000040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSR_I_BIT   0x00000080</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最开始的两个函数，确保了程序运行在 svc 模式，并且关闭了中断。</p>
<p>其核心代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrs	\reg , cpsr</span><br><span class="line">bic	\reg , \reg , #MODE_MASK @ 清<span class="number">0</span>位</span><br><span class="line">orr	\reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE @ 设置 svc 模式以及关闭中断</span><br><span class="line">msr	cpsr_c, \reg @ 写入状态寄</span><br></pre></td></tr></table></figure></p>
<h1 id="获取-proc-info"><a href="#获取-proc-info" class="headerlink" title="获取 proc info"></a>获取 proc info</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/head.S: 98</span></span><br><span class="line">	mrc	p15, <span class="number">0</span>, r9, c0, c0		@ get processor id, r9 记录 cpu 的信息</span><br><span class="line">	bl	__lookup_processor_type		@ r5 = procinfo cpuid arch/arm/include/<span class="keyword">asm</span>/procinfo.h  struct proc_info_list 描述 cpu 信息, 定义在 arch/arm/mm/proc-v7.S</span><br><span class="line">	movs	r10, r5				@ invalid processor (r5=<span class="number">0</span>)?</span><br><span class="line"> THUMB( it	eq )		@ force fixup-able <span class="keyword">long</span> branch encoding</span><br><span class="line">	beq	__error_p			@ yes, error <span class="string">'p'</span></span><br></pre></td></tr></table></figure>
<h2 id="procinfo-前提知识"><a href="#procinfo-前提知识" class="headerlink" title="procinfo 前提知识"></a>procinfo 前提知识</h2><ol>
<li><p>说明<br>procinfo 使用<code>proc_info_list</code>结构体，用于说明一个 cpu 的信息，包括 cpu 的 ID 号，对应的内核数据映射区的 MMU 标志等。</p>
</li>
<li><p>数据结构定义<br>arch/arm/include/asm/procinfo.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	 cpu_val; <span class="comment">// cpu id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	 cpu_mask; <span class="comment">// cpu id 掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	 __cpu_mm_mmu_flags;	<span class="comment">/* used by head.S 临时页表映射的内核空间 MMU 标识 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	 __cpu_io_mmu_flags;	<span class="comment">/* used by head.S IO 映射区的 MMU 标识 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>	 __cpu_flush; <span class="comment">/* used by head.S CPU setup 函数的地址，后续在打开 MMU 过程中使用 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	         *arch_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	         *elf_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>         elf_hwcap;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>	         *cpu_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">processor</span>     *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span>   *<span class="title">tlb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span>  *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span> *<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存放地址<br>对于本案例而言数据存储在 <code>arch/arm/mm/proc-v7.S:503</code>文件中，为 Cortex A9 处理器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">465</span>:	.section <span class="string">".proc.info.init"</span>, <span class="meta">#alloc, #execinstr</span></span><br><span class="line"></span><br><span class="line"><span class="number">467</span>: 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">468: 	 * Standard v7 proc info content</span></span><br><span class="line"><span class="comment">469: 	 */</span></span><br><span class="line"><span class="number">470</span>: .macro __v7_proc initfunc, mm_mmuflags = <span class="number">0</span>, io_mmuflags = <span class="number">0</span>, hwcaps = <span class="number">0</span>, proc_fns = v7_processor_functions</span><br><span class="line"><span class="number">471</span>: 	ALT_SMP(.<span class="keyword">long</span>	PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line"><span class="number">472</span>: 			PMD_SECT_AF | PMD_FLAGS_SMP | \mm_mmuflags)</span><br><span class="line"><span class="number">473</span>:  	ALT_UP(.<span class="keyword">long</span>	PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line"><span class="number">474</span>: 			PMD_SECT_AF | PMD_FLAGS_UP | \mm_mmuflags)</span><br><span class="line"><span class="number">475</span>: 	.<span class="keyword">long</span>	PMD_TYPE_SECT | PMD_SECT_AP_WRITE | \</span><br><span class="line"><span class="number">476</span>: 		PMD_SECT_AP_READ | PMD_SECT_AF | \io_mmuflags</span><br><span class="line"><span class="number">477</span>: 	W(b)	\initfunc</span><br><span class="line"><span class="number">478</span>: 	.<span class="keyword">long</span>	cpu_arch_name</span><br><span class="line"><span class="number">479</span>: 	.<span class="keyword">long</span>	cpu_elf_name</span><br><span class="line"><span class="number">480</span>: 	.<span class="keyword">long</span>	HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | \</span><br><span class="line"><span class="number">481</span>: 		HWCAP_EDSP | HWCAP_TLS | \hwcaps</span><br><span class="line"><span class="number">482</span>: 	.<span class="keyword">long</span>	cpu_v7_name</span><br><span class="line"><span class="number">483</span>: 	.<span class="keyword">long</span>	\proc_fns</span><br><span class="line"><span class="number">484</span>: 	.<span class="keyword">long</span>	v7wbi_tlb_fns</span><br><span class="line"><span class="number">485</span>: 	.<span class="keyword">long</span>	v6_user_fns</span><br><span class="line"><span class="number">486</span>: 	.<span class="keyword">long</span>	v7_cache_fns</span><br><span class="line"><span class="number">487</span>: .endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">500</span>: 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">501: 	 * ARM Ltd. Cortex A9 processor.</span></span><br><span class="line"><span class="comment">502: 	 */</span></span><br><span class="line"><span class="number">503</span>: 	.type   __v7_ca9mp_proc_info, #object</span><br><span class="line"><span class="number">504</span>: __v7_ca9mp_proc_info:</span><br><span class="line"><span class="number">505</span>: 	.<span class="keyword">long</span>	<span class="number">0x410fc090</span></span><br><span class="line"><span class="number">506</span>: 	.<span class="keyword">long</span>	<span class="number">0xff0ffff0</span></span><br><span class="line"><span class="number">507</span>: 	__v7_proc __v7_ca9mp_setup, proc_fns = ca9mp_processor_functions</span><br><span class="line"><span class="number">508</span>: 	.size	__v7_ca9mp_proc_info, . - __v7_ca9mp_proc_info</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接<br>arch/arm/kernel/vmlinux.lds.S会将arch/arm/mm/proc-*.S中所有相关数据都编译到同一段中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span>: <span class="meta">#<span class="meta-keyword">define</span> PROC_INFO					\	</span></span><br><span class="line"><span class="number">26</span>: 	. = ALIGN(<span class="number">4</span>);							\</span><br><span class="line"><span class="number">27</span>: 	VMLINUX_SYMBOL(__proc_info_begin) = .;				\</span><br><span class="line"><span class="number">28</span>:	*(.proc.info.init)						\</span><br><span class="line"><span class="number">29</span>:	VMLINUX_SYMBOL(__proc_info_end) = .;</span><br><span class="line"></span><br><span class="line"><span class="number">203</span>:	.init.proc.info : &#123;</span><br><span class="line"><span class="number">204</span>:		ARM_CPU_DISCARD(PROC_INFO)</span><br><span class="line"><span class="number">205</span>:	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接后结构<br>通过查看 System.map 文件查看链接地址，可以看到 .init.proc.info 段放了所有相关 cpu 的 procinfo。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c0b17c04 T __proc_info_begin</span><br><span class="line">c0b17c04 t __v7_ca5mp_proc_info</span><br><span class="line">c0b17c38 t __v7_ca9mp_proc_info</span><br><span class="line">c0b17c6c t __v7_cr7mp_proc_info</span><br><span class="line">c0b17ca0 t __v7_ca7mp_proc_info</span><br><span class="line">c0b17cd4 t __v7_ca12mp_proc_info</span><br><span class="line">c0b17d08 t __v7_ca15mp_proc_info</span><br><span class="line">c0b17d3c t __v7_b15mp_proc_info</span><br><span class="line">c0b17d70 t __v7_ca17mp_proc_info</span><br><span class="line">c0b17da4 t __krait_proc_info</span><br><span class="line">c0b17dd8 t __v7_proc_info</span><br><span class="line">c0b17e0c T __proc_info_end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="获取-CPU-ID"><a href="#获取-CPU-ID" class="headerlink" title="获取 CPU ID"></a>获取 CPU ID</h2><p>arm 中将 CPU ID 存放在 cp15 的 c0 寄存器</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mrc p15(cp15协处理器), 0(cp15必须为0), r9(写入寄存器), c0(cp15上c0寄存器), c0(默认使用), &#123;,opcode_2(默认为0)&#125;</span><br></pre></td></tr></table></figure>
<p>opcode_2=0时访问处理器标识符寄存器。<br>opcode_2=1时访问cache类型标识符寄存器。</p>
<p>运行完成后获取 <code>r9=0x410fc090</code></p>
<h2 id="获取procinfo"><a href="#获取procinfo" class="headerlink" title="获取procinfo"></a>获取procinfo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/head-common.S:152</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	r9 = cpuid</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *	r3, r4, r6 corrupted</span></span><br><span class="line"><span class="comment"> *	r5 = proc_info pointer in physical address space</span></span><br><span class="line"><span class="comment"> *	r9 = cpuid (preserved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__lookup_processor_type:</span><br><span class="line">	adr	r3, __lookup_processor_type_data	@ r3 = __lookup_processor_type_data 所在的物理地址</span><br><span class="line">	ldmia	r3, &#123;r4 - r6&#125;	</span><br><span class="line">	@ r4 = __lookup_processor_type_data 所在虚拟地址 r5 = __proc_info_begin 虚拟地址, r6 = __proc_info_end 虚拟地址</span><br><span class="line">	sub	r3, r3, r4			@ get offset between virt&amp;phys</span><br><span class="line">	add	r5, r5, r3			@ convert virt addresses to, r5 = __proc_info_begin 物理地址</span><br><span class="line">	add	r6, r6, r3			@ physical address space, r6 = __proc_info_end 物理地址</span><br><span class="line"><span class="number">1</span>:	ldmia	r5, &#123;r3, r4&#125;			@ value, mask</span><br><span class="line">	<span class="keyword">and</span>	r4, r4, r9			@ mask wanted bits</span><br><span class="line">	teq	r3, r4</span><br><span class="line">	beq	<span class="number">2f</span></span><br><span class="line">	add	r5, r5, #PROC_INFO_SZ		@ <span class="keyword">sizeof</span>(proc_info_list)</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	blo	<span class="number">1b</span></span><br><span class="line">	mov	r5, #<span class="number">0</span>				@ unknown processor</span><br><span class="line"><span class="number">2</span>:	ret	lr</span><br><span class="line">ENDPROC(__lookup_processor_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look in &lt;asm/procinfo.h&gt; for information about the __proc_info structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	.align	<span class="number">2</span></span><br><span class="line">	.type	__lookup_processor_type_data, %object</span><br><span class="line">__lookup_processor_type_data:</span><br><span class="line">	.<span class="keyword">long</span>	.</span><br><span class="line">	.<span class="keyword">long</span>	__proc_info_begin</span><br><span class="line">	.<span class="keyword">long</span>	__proc_info_end</span><br><span class="line">	.size	__lookup_processor_type_data, . - __lookup_processor_type_data</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol>
<li>proc info 是如何获取的？<br>通过读取 cp15 中的 cpu id 信息，然后与 __proc_info_begin 段中的所有 cpu_val 进行比较，如果与当前 cpu 一致，则找到对应的 procinfo 数据。</li>
<li>为何需要提前获取？<br>有初始化必要的参数，譬如临时页表所需的 mmu 标识，在打开 mmu 之前需要配置临时内核页表。</li>
</ol>
<h1 id="DTB-校验-以及-fixup"><a href="#DTB-校验-以及-fixup" class="headerlink" title="DTB 校验 以及 fixup"></a>DTB 校验 以及 fixup</h1><h2 id="DTB-校验"><a href="#DTB-校验" class="headerlink" title="DTB 校验"></a>DTB 校验</h2><p>DTB 的校验工作其实很简单就是从 DTB 文件读取 magic 进行比较，如果一致则认为 DTB 有效。</p>
<p>DTB 这部分数据的话会在 start_kernel 的时候使用，所以必须保证是一个有效的数据块。</p>
<p>DTB 数据会被加载到 <code>0x6320_0000</code> 这一地址。DTB 文件在编译后的 arch/arm/boot/dts。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arch/arm/boot/dts</span><br><span class="line">$ hexdump -C vexpress-v2p-ca9.dtb | head</span><br><span class="line"></span><br><span class="line">00000000  d0 0d fe ed 00 00 36 e0  00 00 00 38 00 00 33 3c  |......6....8..3&lt;|</span><br><span class="line">00000010  00 00 00 28 00 00 00 11  00 00 00 10 00 00 00 00  |...(............|</span><br><span class="line">00000020  00 00 03 a4 00 00 33 04  00 00 00 00 00 00 00 00  |......3.........|</span><br><span class="line">00000030  00 00 00 00 00 00 00 00  00 00 00 01 00 00 00 00  |................|</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/head-common.S:47</span></span><br><span class="line"></span><br><span class="line">__vet_atags:</span><br><span class="line">	tst	r2, #<span class="number">0x3</span>			@ aligned? 保证 dtb 地址是<span class="number">4</span>字节对齐的</span><br><span class="line">	bne	<span class="number">1f</span></span><br><span class="line"></span><br><span class="line">	ldr	r5, [r2, #<span class="number">0</span>]		@ 获取 dtb 前四个字节，存放在 r5 寄存器中</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF_FLATTREE</span></span><br><span class="line">	ldr	r6, =OF_DT_MAGIC		@ is it a DTB?</span><br><span class="line">	cmp	r5, r6</span><br><span class="line">	beq	<span class="number">2f</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:	ret	lr				@ atag/dtb pointer is ok</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:	mov	r2, #<span class="number">0</span></span><br><span class="line">	ret	lr</span><br></pre></td></tr></table></figure>
<h2 id="fixup"><a href="#fixup" class="headerlink" title="fixup"></a>fixup</h2><blockquote>
<p>该部分感觉并非特别重要，且与具体 cpu 相关，放弃阅读。</p>
</blockquote>
<h1 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h1><blockquote>
<p>页表创建是在 start_kernel 最关键也是比较难以理解的一个部分，尤其是对计算机硬件了解不深，对 MMU、TLB 没有认识的人而言更加难以理解整个过程。<br>本节将简单的介绍一下 MMU，并通过一个简单的例子来说明虚拟地址是如何转化到物理地址上的。对 MMU 有一个比较深刻的认识。<br>了解完 MMU 后，才能够继续讲解 <strong>create_page_tables，因为 </strong>create_page_tables 函数就是基于 MMU 特性所做的一个操作。</p>
</blockquote>
<h2 id="MMU-介绍"><a href="#MMU-介绍" class="headerlink" title="MMU 介绍"></a>MMU 介绍</h2><p>MMU 是 Memory Management Unit（内存管理单元），开启 MMU 后就可以通过虚拟地址管理内存，完成硬件进行虚拟地址到物理地址的转化，提供硬件的内存访问授权。</p>
<h3 id="Arm32-MMU-一级描述符的格式"><a href="#Arm32-MMU-一级描述符的格式" class="headerlink" title="Arm32 MMU 一级描述符的格式"></a>Arm32 MMU 一级描述符的格式</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811402462093.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p>
<p>最后两位用于表示当前使用的是哪一种类型：</p>
<ul>
<li>0b00: Fault, 表示无效或错误。</li>
<li>0b01: Page table, 表示使用页表。</li>
<li>0b10: Section or Supersection, 表示当前使用段管理，或者超级段（在32位中访问大于4G内存）。若是 Supersection 则 Bit[18] 必须为 1, Section 为 0。</li>
</ul>
<h3 id="Section-段管理"><a href="#Section-段管理" class="headerlink" title="Section 段管理"></a>Section 段管理</h3><blockquote>
<p>因为在 __create_page_tables 中使用的是最简单的段管理，因此这里详细讲解下 Section。参考 ARMv7 手册 p.1320。</p>
</blockquote>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811406851839.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p>
<ul>
<li>Bit[1:0] 描述类型，必须为 10</li>
<li>TEX[2:0] + CB 用于表示 cache 的运行模式，例如：001 + 11 表示 Outer and Inner Write-Back，Write-Allocate。这部分需要有 cpu cache 前置知识，需要知道 cache 有直写和写回两种方法，Write-Allocate 是要求在写 cache 中没有的数据时，不能直接写内存，而是先把内存数据加载到 cache，然后写 cache。</li>
<li>Domain 控制域。</li>
<li>AP[2:0] 访问权限控制，若是 011 则表示 Full access。</li>
<li>NS 表示 Non-secure bit. 表示转化 PA 是否在 secure address map。</li>
<li>nG 表示 not global bit.</li>
<li>S 表示 shareable bit.</li>
</ul>
<h3 id="MMU-如何工作"><a href="#MMU-如何工作" class="headerlink" title="MMU 如何工作"></a>MMU 如何工作</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811426560522.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p>
<p>MMU 的工作实质就是将虚拟地址转化为物理地址，其步骤如下：</p>
<ol>
<li>从 TTBR0(translation table base register) 获取基础地址。</li>
<li>通过虚拟地址的 Table Index 查找到相应的页表所在地址。</li>
<li>从页表所在地址中读取出相应物理页表数据，完成虚拟页表到物理页表的转化。</li>
<li>在获取的物理页表上加上对应的指令偏移则获取到最后的物理地址。</li>
</ol>
<p>下面举一个实际的例子：</p>
<p>该例子中，TTBR0 保存的基地址是 0x6000_4000，并且从 0x6000_4000~0x6000_8000 这一个 16k 的内存中建立了相应的页表数据，此时需要获取虚拟地址 0xc000_8130 的 物理地址。</p>
<p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811429476484.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p>
<p>步骤：</p>
<ol>
<li>根据从 TTBR0 中获取的 0x6000_4000 以及对应虚拟地址 0xc000_8130 计算得到 对应的描述符物理地址为 0x6000_7000。</li>
<li>从描述符锁在物理地址 0x6000_7000 可以得到 section 信息为 0x6001_1c0e。</li>
<li>通过 0x6001_1c0e 的 Section Base address + Section Index 即获取最后的物理地址为 0x8000_8130。</li>
</ol>
<blockquote>
<p>为何说内核是线性映射的，因为内核虚拟地址在 0xc000<em>0000 向上位置，其对于的物理地址刚好是 0x6000_0000 向上，这部分映射的话直接映射即可。0xc00</em> -&gt; 0x600_</p>
</blockquote>
<p>MMU 做的工作如上所述，但是这一工作的前提是必须要由我们来创建页表信息。页表是需要人为维护的，这也是 __create_page_tables 所做的工作。</p>
<h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个物理地址与虚拟地址一致的映射</span></span><br><span class="line"><span class="comment"> * 为了打开 MMU 时候需要一个临时的页表。</span></span><br><span class="line"><span class="comment"> * __create_page_tables 做了两件事情:</span></span><br><span class="line"><span class="comment"> *	1. 打开 mmu 把打开 mmu 代码对应到段映射到 1m 大小的地方。创建一个恒等的映射。虚拟地址=物理地址</span></span><br><span class="line"><span class="comment"> *  2. 把内核的 image 代码映射到内核到虚拟空间中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Setup the initial page tables.  We only setup the barest</span></span><br><span class="line"><span class="comment"> * amount which are required to get the kernel running, which</span></span><br><span class="line"><span class="comment"> * generally means mapping in the kernel code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * r8 = phys_offset, r9 = cpuid, r10 = procinfo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *  r0, r3, r5-r7 corrupted</span></span><br><span class="line"><span class="comment"> *  r4 = page table (see ARCH_PGD_SHIFT in asm/memory.h)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__create_page_tables:</span><br><span class="line">	pgtbl	r4, r8				@ page table address, r4 设置成页表的基地址, phys_offset + TEXT_OFFSET(<span class="number">0x8000</span>) - PG_DIR_SIZE(<span class="number">0x4000</span>), 即为内核位置下方的 <span class="number">16</span>k</span><br><span class="line">	@ r4 = <span class="number">0x6000</span>_4000 r8 = <span class="number">0x6000</span>_8000</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Clear the swapper page table</span></span><br><span class="line"><span class="comment">	 * 清除 0x6000_4000 - 0x6000_8000 这段内存数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r4					@ r0 = r4</span><br><span class="line">	mov	r3, #<span class="number">0</span>					@ r3 = <span class="number">0</span></span><br><span class="line">	add	r6, r0, #PG_DIR_SIZE	@ r6 = 页表基地址 + <span class="number">16</span>k，即页表的尾地址</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">4</span>			@ str 移动的是 <span class="number">32</span> 位的数据, 将 r3 的值写入 r0 为地址的内存, 并设置 r0 = r0 + <span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	str	r3, [r0], #<span class="number">4</span></span><br><span class="line">	teq	r0, r6					@ 判断是否到页表到尾地址</span><br><span class="line">	bne	<span class="number">1b</span></span><br><span class="line">	</span><br><span class="line">	ldr	r7, [r10, #PROCINFO_MM_MMUFLAGS] @ mm_mmuflags 设置 mmu 标志位</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create identity mapping to cater for __enable_mmu.</span></span><br><span class="line"><span class="comment">	 * This identity mapping will be removed by paging_init().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	adr	r0, __turn_mmu_on_loc	@ r0 = __turn_mmu_on_loc 地址 </span><br><span class="line">	ldmia	r0, &#123;r3, r5, r6&#125;	@ 将 r0 中的数据 弹出到 r3, r5, r6</span><br><span class="line">	sub	r0, r0, r3			@ virt-&gt;phys offset, r0 为物理地址, r3, r5, r6 为虚拟地址，此时需要将虚拟地址转化为物理地址, r0 与 r3 是 __turn_mmu_on_loc 对应的物理与虚拟地址</span><br><span class="line">	add	r5, r5, r0			@ phys __turn_mmu_on</span><br><span class="line">	add	r6, r6, r0			@ phys __turn_mmu_on_end</span><br><span class="line">	mov	r5, r5, lsr #SECTION_SHIFT	@ r5 = r5 &gt;&gt; <span class="number">20</span>, 取高<span class="number">12</span>位</span><br><span class="line">	mov	r6, r6, lsr #SECTION_SHIFT	@ r6 = r6 &gt;&gt; <span class="number">20</span>, 取高<span class="number">12</span>位</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:	orr	r3, r7, r5, lsl #SECTION_SHIFT	@ flags + kernel base r3 = r7 | (r5 &lt;&lt; <span class="number">20</span>) 得到页表需要设置的数据</span><br><span class="line">	str	r3, [r4, r5, lsl #PMD_ORDER]	@ identity mapping [r4 + r5 &lt;&lt; <span class="number">2</span>] = r3, 将 __turn_mmu_on 设置到 对应的一级页表中</span><br><span class="line">	cmp	r5, r6							@ 是否在同一段，若不是则继续映射</span><br><span class="line">	addlo	r5, r5, #<span class="number">1</span>					@ next section</span><br><span class="line">	blo	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Map our RAM from the start to the end of the kernel .bss section.</span></span><br><span class="line"><span class="comment">	 * 下面这部分其实是为了将内核部分数据映射</span></span><br><span class="line"><span class="comment">	 * 内核虚拟地址为		0xc000_0000 - 0xc112_23d7</span></span><br><span class="line"><span class="comment">	 * 内核物理地址为       0x6000_0000 - 0x6112_23d7</span></span><br><span class="line"><span class="comment">	 * 进行计算后对应段为   0x6000_7000 - 0x6000_7044</span></span><br><span class="line"><span class="comment">	 * 0x6000_7000 如何计算: L1 基地址为 0x6000_4000 + 0xc000_0000 &gt;&gt; 18</span></span><br><span class="line"><span class="comment">	 * 0x6000_7044 如何计算: L1 基地址为 0x6000_4000 + 0xc112_23d7 &gt;&gt; 18</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	add	r0, r4, #PAGE_OFFSET &gt;&gt; (SECTION_SHIFT - PMD_ORDER)	@ r0 = r4 + <span class="number">0xc000</span>_0000 &gt;&gt; <span class="number">18</span>, r0 = <span class="number">0x6000</span>_7000</span><br><span class="line">	ldr	r6, =(_end - <span class="number">1</span>)										@ ldr 伪指令, r6 = kernel_end - <span class="number">1</span> r6 = <span class="number">0xc112</span>_23d7	</span><br><span class="line">	orr	r3, r8, r7											@ r3 = r8 | r7, r8 为 phys_offset <span class="number">0x6000</span>_0000</span><br><span class="line">	add	r6, r4, r6, lsr #(SECTION_SHIFT - PMD_ORDER)		@ r6 = r4 + r6 &gt;&gt; <span class="number">18</span>, 与之前设置 __turn_mmu_on 段过程一样</span><br><span class="line"><span class="number">1</span>:	str	r3, [r0], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	add	r3, r3, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	cmp	r0, r6</span><br><span class="line">	bls	<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * dtb 所在两个段的映射</span></span><br><span class="line"><span class="comment">	 * Then map boot params address in r2 if specified.</span></span><br><span class="line"><span class="comment">	 * We map 2 sections in case the ATAGs/DTB crosses a section boundary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mov	r0, r2, lsr #SECTION_SHIFT			@ 将 r2=dtb dtb 左移，存放到 r0</span><br><span class="line">	movs	r0, r0, lsl #SECTION_SHIFT		@ 再将 r0 右移获取物理内存段地址</span><br><span class="line">	subne	r3, r0, r8						@ 计算 r0 对应DARM起始地址r8偏移</span><br><span class="line">	addne	r3, r3, #PAGE_OFFSET</span><br><span class="line">	addne	r3, r4, r3, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">	orrne	r6, r7, r0</span><br><span class="line">	strne	r6, [r3], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">	addne	r6, r6, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">	strne	r6, [r3]</span><br><span class="line"></span><br><span class="line">	ret	lr</span><br><span class="line">ENDPROC(__create_page_tables)</span><br><span class="line">	.ltorg</span><br><span class="line">	.align</span><br><span class="line">__turn_mmu_on_loc:</span><br><span class="line">	.<span class="keyword">long</span>	.</span><br><span class="line">	.<span class="keyword">long</span>	__turn_mmu_on</span><br><span class="line">	.<span class="keyword">long</span>	__turn_mmu_on_end</span><br></pre></td></tr></table></figure>
<h2 id="运行完成后内存结构"><a href="#运行完成后内存结构" class="headerlink" title="运行完成后内存结构"></a>运行完成后内存结构</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811474554381.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol>
<li>为何 __turn_mmu_on 这部分需要做一个直接映射？因为在开启 MMU 完成后 pc 指针指向的还是物理地址，但此时对 MMU 而言该地址是个虚拟地址，需要查页表，若不建立这一块直接映射，则无法继续执行。</li>
<li>MMU flags 03x11C0E 表示什么？是从arch/arm/mm/proc-v7.S:503这里获取的。<br><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811475656613.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title><br>AP=011可读性，TEXCB=00111表示Outer and Inner Write-Back，Write-Allocate。</li>
<li>TEXT_OFFSET 在那个文件指定？arch/arm/Makefile, 0x8000</li>
<li>PG_DIR_SIZE 在哪个文件指定？arch/arm/kernel/head.S, 0x4000</li>
<li>PAGE_OFFSET 表示内核的开始虚拟地址, 0xc000_000<h1 id="ARM-汇编指令说明"><a href="#ARM-汇编指令说明" class="headerlink" title="ARM 汇编指令说明"></a>ARM 汇编指令说明</h1></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mrs r4, cpsr</td>
<td style="text-align:center">状态寄存器到通用寄存器的传送指令</td>
</tr>
<tr>
<td style="text-align:center">msr cpsr, r4</td>
<td style="text-align:center">通用寄存器到状态寄存器的传送指令</td>
</tr>
<tr>
<td style="text-align:center">adr r0, .test</td>
<td style="text-align:center">相当于 add r0, pc, #4 小范围地址读取伪指令</td>
</tr>
<tr>
<td style="text-align:center">ldr</td>
<td style="text-align:center">大范围地址读取伪指令</td>
</tr>
<tr>
<td style="text-align:center">str r0, [r1, #8]</td>
<td style="text-align:center">将r0中的字写入r1+8为地址的存储中</td>
</tr>
<tr>
<td style="text-align:center">cmp r0, r1</td>
<td style="text-align:center">相当于 r0-r1</td>
</tr>
<tr>
<td style="text-align:center">eor</td>
<td style="text-align:center">异或指令</td>
</tr>
<tr>
<td style="text-align:center">MCR{&lt;cond&gt;} &lt;p&gt;,&lt;opcode_1&gt;,&lt;Rd&gt;,&lt;CRn&gt;,&lt;CRm&gt;{,&lt;opcode_2&gt;}</td>
<td style="text-align:center">将arm寄存器数据传递到协处理器</td>
</tr>
<tr>
<td style="text-align:center">MRC{&lt;cond&gt;} &lt;p&gt;,&lt;opcode_1&gt;,&lt;Rd&gt;,&lt;CRn&gt;,&lt;CRm&gt;{,&lt;opcode_2&gt;}</td>
<td style="text-align:center">将协处理器数据传递到arm寄存器</td>
</tr>
<tr>
<td style="text-align:center">LDMIA R1!,{R0,R4-R6}</td>
<td style="text-align:center">从左到右加载,相当于 LDR R0,10000000  LDR R4,10000004… …，!表示最后地址是否写回到R1</td>
</tr>
<tr>
<td style="text-align:center">STMIB R1,{R4-R6}</td>
<td style="text-align:center">从左到右加载,相当于STR [R4],0X10000004    STR [R5],0X10000008 …..</td>
</tr>
</tbody>
</table>
</div>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文在大量参考已有知识，并通过自己调试总结后完成。</p>
<p><a href="https://static.docs.arm.com/ddi0406/c/DDI0406C_C_arm_architecture_reference_manual.pdf" target="_blank" rel="noopener">ARMv7 手册</a><br><a href="https://item.jd.com/12152745.html" target="_blank" rel="noopener">奔跑吧 Linux 内核</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52690132" target="_blank" rel="noopener">[kernel 启动流程] 前篇——vmlinux.lds分析</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52710290" target="_blank" rel="noopener">[kernel 启动流程] （第一章）概述</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52779230" target="_blank" rel="noopener">[kernel 启动流程] （第二章）第一阶段之——设置SVC、关闭中断</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52791202" target="_blank" rel="noopener">[kernel 启动流程] （第三章）第一阶段之——proc info的获取</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52797211" target="_blank" rel="noopener">[kernel 启动流程] （第四章）第一阶段之——dtb的验证</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52850433" target="_blank" rel="noopener">[kernel 启动流程] （第五章）第一阶段之——临时内核页表的创建</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52860186" target="_blank" rel="noopener">[kernel 启动流程] （第六章）第一阶段之——打开MMU</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52861681" target="_blank" rel="noopener">[kernel 启动流程] （第七章）第一阶段之——跳转到start_kernel</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LinuxKernel4-0-arm32/" rel="tag"># LinuxKernel4.0-arm32</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Linux/linux/cpu-info/" rel="prev" title="深入浅出计算机组成原理">
      <i class="fa fa-chevron-left"></i> 深入浅出计算机组成原理
    </a></div>
      <div class="post-nav-item">
    <a href="/RocketMQ/middleware/rocketmq-01/" rel="next" title="RocketMQ 01 - 基础介绍">
      RocketMQ 01 - 基础介绍 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NDc4Ni8yMTMwNw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Qemu-调试"><span class="nav-number">1.</span> <span class="nav-text">Qemu 调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Qemu-调试配置"><span class="nav-number">1.1.</span> <span class="nav-text">Qemu 调试配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Qemu-调试-mmu-之前"><span class="nav-number">1.2.</span> <span class="nav-text">Qemu 调试 mmu 之前</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开启-SVC-关闭中断"><span class="nav-number">3.</span> <span class="nav-text">开启 SVC 关闭中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#hyp-stub-install"><span class="nav-number">3.1.</span> <span class="nav-text">__hyp_stub_install</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#safe-svcmode-maskall"><span class="nav-number">3.2.</span> <span class="nav-text">safe_svcmode_maskall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#获取-proc-info"><span class="nav-number">4.</span> <span class="nav-text">获取 proc info</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#procinfo-前提知识"><span class="nav-number">4.1.</span> <span class="nav-text">procinfo 前提知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取-CPU-ID"><span class="nav-number">4.2.</span> <span class="nav-text">获取 CPU ID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取procinfo"><span class="nav-number">4.3.</span> <span class="nav-text">获取procinfo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">4.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DTB-校验-以及-fixup"><span class="nav-number">5.</span> <span class="nav-text">DTB 校验 以及 fixup</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DTB-校验"><span class="nav-number">5.1.</span> <span class="nav-text">DTB 校验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fixup"><span class="nav-number">5.2.</span> <span class="nav-text">fixup</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建页表"><span class="nav-number">6.</span> <span class="nav-text">创建页表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MMU-介绍"><span class="nav-number">6.1.</span> <span class="nav-text">MMU 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Arm32-MMU-一级描述符的格式"><span class="nav-number">6.1.1.</span> <span class="nav-text">Arm32 MMU 一级描述符的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Section-段管理"><span class="nav-number">6.1.2.</span> <span class="nav-text">Section 段管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MMU-如何工作"><span class="nav-number">6.1.3.</span> <span class="nav-text">MMU 如何工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码解读"><span class="nav-number">6.2.</span> <span class="nav-text">代码解读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行完成后内存结构"><span class="nav-number">6.3.</span> <span class="nav-text">运行完成后内存结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点"><span class="nav-number">6.4.</span> <span class="nav-text">重点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ARM-汇编指令说明"><span class="nav-number">7.</span> <span class="nav-text">ARM 汇编指令说明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="klutzoder" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">klutzoder</p>
  <div class="site-description" itemprop="description">I'm no body!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">klutzoder</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">343k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">5:12</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
