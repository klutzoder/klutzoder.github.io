<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RocketMQ 03 - 源码分析</title>
      <link href="RocketMQ/middleware/rocketmq-03/"/>
      <url>RocketMQ/middleware/rocketmq-03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：本文档由《黑马程序员》整理，本人只是为了方便才整理到自己博客！！<br>相应视频资料：<a href="https://www.bilibili.com/video/BV1L4411y7mn?from=search&amp;seid=10733892066736275631" target="_blank" rel="noopener">RocketMQ系统精讲</a></p></blockquote><a id="more"></a><h1 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h1><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p>分布式队列因为有高可靠性的要求，所以数据要进行持久化存储。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-cun-chu-fang-shi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ol><li>消息生成者发送消息</li><li>MQ收到消息，将消息进行持久化，在存储中新增一条记录</li><li>返回ACK给生产者</li><li>MQ push 消息给对应的消费者，然后等待消费者返回ACK</li><li>如果消息消费者在指定时间内成功返回ack，那么MQ认为消息消费成功，在存储中删除消息，即执行第6步；如果MQ在指定时间内没有收到ACK，则认为消息消费失败，会尝试重新push消息,重复执行4、5、6步骤</li><li>MQ删除消息</li></ol><h3 id="存储介质"><a href="#存储介质" class="headerlink" title="存储介质"></a>存储介质</h3><ul><li>关系型数据库DB</li></ul><p>Apache下开源的另外一款MQ—ActiveMQ（默认采用的KahaDB做消息存储）可选用JDBC的方式来做消息持久化，通过简单的xml配置信息即可实现JDBC消息存储。由于，普通关系型数据库（如Mysql）在单表数据量达到千万级别的情况下，其IO读写性能往往会出现瓶颈。在可靠性方面，该种方案非常依赖DB，如果一旦DB出现故障，则MQ的消息就无法落盘存储会导致线上故障</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mysql.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="300" alt title></p><ul><li><p>文件系统</p><p>目前业界较为常用的几款产品（RocketMQ/Kafka/RabbitMQ）均采用的是消息刷盘至所部署虚拟机/物理机的文件系统来做持久化（刷盘一般可以分为异步刷盘和同步刷盘两种模式）。消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。除非部署MQ机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。</p></li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/ci-pan.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="300" alt title></p><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>文件系统&gt;关系型数据库DB</p><h3 id="消息的存储和发送"><a href="#消息的存储和发送" class="headerlink" title="消息的存储和发送"></a>消息的存储和发送</h3><h4 id="消息存储-1"><a href="#消息存储-1" class="headerlink" title="消息存储"></a>消息存储</h4><p>磁盘如果使用得当，磁盘的速度完全可以匹配上网络 的数据传输速度。目前的高性能磁盘，顺序写速度可以达到600MB/s， 超过了一般网卡的传输速度。但是磁盘随机写的速度只有大概100KB/s，和顺序写的性能相差6000倍！因为有如此巨大的速度差别，好的消息队列系统会比普通的消息队列系统速度快多个数量级。RocketMQ的消息用顺序写,保证了消息存储的速度。</p><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>Linux操作系统分为【用户态】和【内核态】，文件操作、网络操作需要涉及这两种形态的切换，免不了进行数据复制。</p><p>一台服务器 把本机磁盘文件的内容发送到客户端，一般分为两个步骤：</p><p>1）read；读取本地文件内容； </p><p>2）write；将读取的内容通过网络发送出去。</p><p>这两个看似简单的操作，实际进行了4 次数据复制，分别是：</p><ol><li>从磁盘复制数据到内核态内存；</li><li>从内核态内存复 制到用户态内存；</li><li>然后从用户态 内存复制到网络驱动的内核态内存；</li><li>最后是从网络驱动的内核态内存复 制到网卡中进行传输。</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/wen-jian-cao-zuo-he-wang-luo-cao-zuo.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>通过使用mmap的方式，可以省去向用户态的内存复制，提高速度。这种机制在Java中是通过MappedByteBuffer实现的</p><p>RocketMQ充分利用了上述特性，也就是所谓的“零拷贝”技术，提高消息存盘和网络发送的速度。</p><blockquote><p>这里需要注意的是，采用MappedByteBuffer这种内存映射的方式有几个限制，其中之一是一次只能映射1.5~2G 的文件至用户态的虚拟内存，这也是为何RocketMQ默认设置单个CommitLog日志数据文件为1G的原因了</p></blockquote><h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成 的，消息真正的物理存储文件是CommitLog，ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的是指向物理存储的地址。每 个Topic下的每个Message Queue都有一个对应的ConsumeQueue文件。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-cun-chu-jie-gou.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li>CommitLog：存储消息的元数据</li><li>ConsumerQueue：存储消息在CommitLog的索引</li><li>IndexFile：为了消息查询提供了一种通过key或时间区间来查询消息的方法，这种通过IndexFile来查找消息的方法不影响发送与消费消息的主流程</li></ul><h3 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/tong-bu-shua-pan-he-yi-bu-shua-pan.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h4 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p><h4 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p><h2 id="高可用性机制"><a href="#高可用性机制" class="headerlink" title="高可用性机制"></a>高可用性机制</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/rocketmq-jiao-se.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p><p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p><p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p><h3 id="消息消费高可用"><a href="#消息消费高可用" class="headerlink" title="消息消费高可用"></a>消息消费高可用</h3><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p><h3 id="消息发送高可用"><a href="#消息发送高可用" class="headerlink" title="消息发送高可用"></a>消息发送高可用</h3><p>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-fa-song-gao-ke-yong-she-ji.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h3 id="消息主从复制"><a href="#消息主从复制" class="headerlink" title="消息主从复制"></a>消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p><h4 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h4><p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p><p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p><p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/fu-zhi-shua-pan.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘 方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="Producer负载均衡"><a href="#Producer负载均衡" class="headerlink" title="Producer负载均衡"></a>Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/producer-fu-zai-jun-heng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p><h3 id="Consumer负载均衡"><a href="#Consumer负载均衡" class="headerlink" title="Consumer负载均衡"></a>Consumer负载均衡</h3><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p><p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p><p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/consumer-fu-zai-jun-heng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/consumer-fu-zai-jun-heng2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p><p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p><p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p><h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p><p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/consumer-fu-zai-jun-heng3.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h2><h3 id="顺序消息的重试"><a href="#顺序消息的重试" class="headerlink" title="顺序消息的重试"></a>顺序消息的重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p><h3 id="无序消息的重试"><a href="#无序消息的重试" class="headerlink" title="无序消息的重试"></a>无序消息的重试</h3><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p><p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p><h4 id="重试次数"><a href="#重试次数" class="headerlink" title="重试次数"></a>重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第几次重试</th><th style="text-align:center">与上次重试的间隔时间</th><th style="text-align:center">第几次重试</th><th style="text-align:center">与上次重试的间隔时间</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">10 秒</td><td style="text-align:center">9</td><td style="text-align:center">7 分钟</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">30 秒</td><td style="text-align:center">10</td><td style="text-align:center">8 分钟</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1 分钟</td><td style="text-align:center">11</td><td style="text-align:center">9 分钟</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">2 分钟</td><td style="text-align:center">12</td><td style="text-align:center">10 分钟</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">3 分钟</td><td style="text-align:center">13</td><td style="text-align:center">20 分钟</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">4 分钟</td><td style="text-align:center">14</td><td style="text-align:center">30 分钟</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">5 分钟</td><td style="text-align:center">15</td><td style="text-align:center">1 小时</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">6 分钟</td><td style="text-align:center">16</td><td style="text-align:center">2 小时</td></tr></tbody></table></div><p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p><p><strong>注意：</strong> 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p><strong>消费失败后，重试配置方式</strong></p><p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p><ul><li>返回 Action.ReconsumeLater （推荐）</li><li>返回 Null</li><li>抛出异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理消息</span></span><br><span class="line">        doConsumeMessage(message);</span><br><span class="line">        <span class="comment">//方式1：返回 Action.ReconsumeLater，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> Action.ReconsumeLater;</span><br><span class="line">        <span class="comment">//方式2：返回 null，消息将重试</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//方式3：直接抛出异常， 消息将重试</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Consumer Message exceotion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费失败后，不重试配置方式</strong></p><p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doConsumeMessage(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span></span><br><span class="line">            <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理正常，直接返回 Action.CommitMessage;</span></span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义消息最大重试次数</strong></p><p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p><ul><li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li><li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//配置对应 Group ID 的最大消息重试次数为 20 次</span></span><br><span class="line">properties.put(PropertyKeyConst.MaxReconsumeTimes,<span class="string">"20"</span>);</span><br><span class="line">Consumer consumer =ONSFactory.createConsumer(properties);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p></blockquote><ul><li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li><li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li><li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li></ul><p><strong>获取消息重试次数</strong></p><p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerImpl</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取消息的重试次数</span></span><br><span class="line">        System.out.println(message.getReconsumeTimes());</span><br><span class="line">        <span class="keyword">return</span> Action.CommitMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p><h3 id="死信特性"><a href="#死信特性" class="headerlink" title="死信特性"></a>死信特性</h3><p>死信消息具有以下特性</p><ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li></ul><p>死信队列具有以下特性：</p><ul><li>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li></ul><h3 id="查看死信信息"><a href="#查看死信信息" class="headerlink" title="查看死信信息"></a>查看死信信息</h3><ol><li>在控制台查询出现死信队列的主题信息</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/si-xin-dui-lie-zhu-ti.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ol><li>在消息界面根据主题查询死信消息</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/si-xin-dui-lie-zhu-ti2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ol><li>选择重新发送消息</li></ol><p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p><h2 id="消费幂等"><a href="#消费幂等" class="headerlink" title="消费幂等"></a>消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p><h3 id="消费幂等的必要性"><a href="#消费幂等的必要性" class="headerlink" title="消费幂等的必要性"></a>消费幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p><ul><li><p>发送时消息重复</p><p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p></li><li><p>投递时消息重复</p><p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p></li><li><p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p><p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p></li></ul><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p>因为 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">message.setKey(<span class="string">"ORDERID_100"</span>);</span><br><span class="line">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure><p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(<span class="string">"ons_test"</span>, <span class="string">"*"</span>, <span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Action <span class="title">consume</span><span class="params">(Message message, ConsumeContext context)</span> </span>&#123;</span><br><span class="line">        String key = message.getKey()</span><br><span class="line">        <span class="comment">// 根据业务唯一标识的 key 做幂等处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>依赖工具</p><ul><li>JDK ：1.8+</li><li>Maven</li><li>IntelliJ IDEA</li></ul><h3 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h3><p>从官方仓库 <a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">https://github.com/apache/rocketmq</a> <code>clone</code>或者<code>download</code>源码。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma1.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong>源码目录结构：</strong></p><ul><li><p>broker: broker 模块（broke 启动进程） </p></li><li><p>client ：消息客户端，包含消息生产者、消息消费者相关类 </p></li><li>common ：公共包 </li><li>dev ：开发者信息（非源代码） </li><li>distribution ：部署实例文件夹（非源代码） </li><li>example: RocketMQ 例代码 </li><li><p>filter ：消息过滤相关基础类</p></li><li><p>filtersrv：消息过滤服务器实现相关类（Filter启动进程）</p></li><li>logappender：日志实现相关类</li><li>namesrv：NameServer实现相关类（NameServer启动进程）</li><li>openmessageing：消息开放标准</li><li>remoting：远程通信模块，给予Netty</li><li>srcutil：服务工具类</li><li>store：消息存储实现相关类</li><li>style：checkstyle相关实现</li><li>test：测试相关类</li><li>tools：工具类，监控命令相关实现类</li></ul><h3 id="导入IDEA"><a href="#导入IDEA" class="headerlink" title="导入IDEA"></a>导入IDEA</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong>执行安装</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>创建<code>conf</code>配置文件夹,从<code>distribution</code>拷贝<code>broker.conf</code>和<code>logback_broker.xml</code>和<code>logback_namesrv.xml</code></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma6.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h4 id="启动NameServer"><a href="#启动NameServer" class="headerlink" title="启动NameServer"></a>启动NameServer</h4><ul><li>展开namesrv模块，右键NamesrvStartup.java</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma3.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li>配置<strong>ROCKETMQ_HOME</strong></li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma4.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma5.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li><p>重新启动</p><p>控制台打印结果</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Name Server boot success. serializeType=JSON</span><br></pre></td></tr></table></figure><h4 id="启动Broker"><a href="#启动Broker" class="headerlink" title="启动Broker"></a>启动Broker</h4><ul><li><code>broker.conf</code>配置文件内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = 0</span><br><span class="line"># namesrvAddr地址</span><br><span class="line">namesrvAddr=127.0.0.1:9876</span><br><span class="line">deleteWhen = 04</span><br><span class="line">fileReservedTime = 48</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line"></span><br><span class="line"># 存储路径</span><br><span class="line">storePathRootDir=E:\\RocketMQ\\data\\rocketmq\\dataDir</span><br><span class="line"># commitLog路径</span><br><span class="line">storePathCommitLog=E:\\RocketMQ\\data\\rocketmq\\dataDir\\commitlog</span><br><span class="line"># 消息队列存储路径</span><br><span class="line">storePathConsumeQueue=E:\\RocketMQ\\data\\rocketmq\\dataDir\\consumequeue</span><br><span class="line"># 消息索引存储路径</span><br><span class="line">storePathIndex=E:\\RocketMQ\\data\\rocketmq\\dataDir\\index</span><br><span class="line"># checkpoint文件路径</span><br><span class="line">storeCheckpoint=E:\\RocketMQ\\data\\rocketmq\\dataDir\\checkpoint</span><br><span class="line"># abort文件存储路径</span><br><span class="line">abortFile=E:\\RocketMQ\\data\\rocketmq\\dataDir\\abort</span><br></pre></td></tr></table></figure><ul><li>创建数据文件夹<code>dataDir</code></li><li>启动<code>BrokerStartup</code>,配置<code>broker.conf</code>和<code>ROCKETMQ_HOME</code></li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma7.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yuan-ma8.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><ul><li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li><li>指定Namesrv地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br></pre></td></tr></table></figure><ul><li>运行<code>main</code>方法，发送消息</li></ul><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><ul><li>进入example模块的<code>org.apache.rocketmq.example.quickstart</code></li><li>指定Namesrv地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line">consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br></pre></td></tr></table></figure><ul><li>运行<code>main</code>方法，消费消息</li></ul><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>消息中间件的设计思路一般是基于主题订阅发布的机制，消息生产者（Producer）发送某一个主题到消息服务器，消息服务器负责将消息持久化存储，消息消费者（Consumer）订阅该兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（Push模式）或者消费者主动向消息服务器拉去（Pull模式），从而实现消息生产者与消息消费者解耦。为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那消息生产者如何知道消息要发送到哪台消息服务器呢？如果某一台消息服务器宕机了，那么消息生产者如何在不重启服务情况下感知呢？</p><p>NameServer就是为了解决以上问题设计的。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/rocketmq-jiao-se.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>Broker消息服务器在启动的时向所有NameServer注册，消息生产者（Producer）在发送消息时之前先从NameServer获取Broker服务器地址列表，然后根据负载均衡算法从列表中选择一台服务器进行发送。NameServer与每台Broker保持长连接，并间隔30S检测Broker是否存活，如果检测到Broker宕机，则从路由注册表中删除。但是路由变化不会马上通知消息生产者。这样设计的目的是为了降低NameServer实现的复杂度，在消息发送端提供容错机制保证消息发送的可用性。</p><p>NameServer本身的高可用是通过部署多台NameServer来实现，但彼此之间不通讯，也就是NameServer服务器之间在某一个时刻的数据并不完全相同，但这对消息发送并不会造成任何影响，这也是NameServer设计的一个亮点，总之，RocketMQ设计追求简单高效。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/nameserver-qi-dong-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>启动类：<code>org.apache.rocketmq.namesrv.NamesrvStartup</code></p><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>解析配置文件，填充NameServerConfig、NettyServerConfig属性值，并创建NamesrvController</p><p><strong><em>代码：NamesrvController#createNamesrvController</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建NamesrvConfig</span></span><br><span class="line"><span class="keyword">final</span> NamesrvConfig namesrvConfig = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line"><span class="comment">//创建NettyServerConfig</span></span><br><span class="line"><span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line"><span class="comment">//设置启动端口号</span></span><br><span class="line">nettyServerConfig.setListenPort(<span class="number">9876</span>);</span><br><span class="line"><span class="comment">//解析启动-c参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'c'</span>)) &#123;</span><br><span class="line">    String file = commandLine.getOptionValue(<span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(in);</span><br><span class="line">        MixAll.properties2Object(properties, namesrvConfig);</span><br><span class="line">        MixAll.properties2Object(properties, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">        namesrvConfig.setConfigStorePath(file);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"load config properties file OK, %s%n"</span>, file);</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析启动-p参数</span></span><br><span class="line"><span class="keyword">if</span> (commandLine.hasOption(<span class="string">'p'</span>)) &#123;</span><br><span class="line">    InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME);</span><br><span class="line">    MixAll.printObjectProperties(console, namesrvConfig);</span><br><span class="line">    MixAll.printObjectProperties(console, nettyServerConfig);</span><br><span class="line">    System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将启动参数填充到namesrvConfig,nettyServerConfig</span></span><br><span class="line">MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建NameServerController</span></span><br><span class="line"><span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</span><br></pre></td></tr></table></figure><p><u><strong>NamesrvConfig属性</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String rocketmqHome = System.getProperty(MixAll.ROCKETMQ_HOME_PROPERTY, System.getenv(MixAll.ROCKETMQ_HOME_ENV));</span><br><span class="line"><span class="keyword">private</span> String kvConfigPath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"kvConfig.json"</span>;</span><br><span class="line"><span class="keyword">private</span> String configStorePath = System.getProperty(<span class="string">"user.home"</span>) + File.separator + <span class="string">"namesrv"</span> + File.separator + <span class="string">"namesrv.properties"</span>;</span><br><span class="line"><span class="keyword">private</span> String productEnvName = <span class="string">"center"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> clusterTest = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> orderMessageEnable = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p><strong>rocketmqHome：</strong>rocketmq主目录</p><p><strong>kvConfig：</strong>NameServer存储KV配置属性的持久化路径</p><p><strong>configStorePath：</strong>nameServer默认配置文件路径</p><p><strong>orderMessageEnable：</strong>是否支持顺序消息</p><p><u><strong>NettyServerConfig属性</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketSndBufSize = NettySystemConfig.socketSndbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSocketRcvBufSize = NettySystemConfig.socketRcvbufSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> serverPooledByteBufAllocatorEnable = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> useEpollNativeSelector = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p><strong>listenPort：</strong>NameServer监听端口，该值默认会被初始化为9876<br><strong>serverWorkerThreads：</strong>Netty业务线程池线程个数<br><strong>serverCallbackExecutorThreads：</strong>Netty public任务线程池线程个数，Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等。如果该业务类型未注册线程池，则由public线程池执行。<br><strong>serverSelectorThreads：</strong>IO线程池个数，主要是NameServer、Broker端解析请求、返回相应的线程个数，这类线程主要是处理网路请求的，解析请求包，然后转发到各个业务线程池完成具体的操作，然后将结果返回给调用方;<br><strong>serverOnewaySemaphoreValue：</strong>send oneway消息请求并发读（Broker端参数）;<br><strong>serverAsyncSemaphoreValue：</strong>异步消息发送最大并发度;<br><strong>serverChannelMaxIdleTimeSeconds ：</strong>网络连接最大的空闲时间，默认120s。<br><strong>serverSocketSndBufSize：</strong>网络socket发送缓冲区大小。<br><strong>serverSocketRcvBufSize：</strong> 网络接收端缓存区大小。<br><strong>serverPooledByteBufAllocatorEnable：</strong>ByteBuffer是否开启缓存;<br><strong>useEpollNativeSelector：</strong>是否启用Epoll IO模型。</p><h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>根据启动属性创建NamesrvController实例，并初始化该实例。NameServerController实例为NameServer核心控制器</p><p><strong><em>代码：NamesrvController#initialize</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//加载KV配置</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line"><span class="comment">//创建NettyServer网络处理对象</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line"><span class="comment">//开启定时任务:每隔10s扫描一次Broker,移除不活跃的Broker</span></span><br><span class="line">    <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">        Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">    <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">//开启定时任务:每隔10min打印一次KV配置</span></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>在JVM进程关闭之前，先将线程池关闭，及时释放资源</p><p><strong><em>代码：NamesrvStartup#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册JVM钩子函数代码</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        controller.shutdown();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h3 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h3><p>NameServer的主要作用是为消息的生产者和消息消费者提供关于主题Topic的路由信息，那么NameServer需要存储路由的基础信息，还要管理Broker节点，包括路由注册、路由删除等。</p><h4 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h4><p><strong><em>代码：RouteInfoManager</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/lu-you-shi-ti-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong>topicQueueTable：</strong>Topic消息队列路由信息，消息发送时根据路由表进行负载均衡</p><p><strong>brokerAddrTable：</strong>Broker基础信息，包括brokerName、所属集群名称、主备Broker地址</p><p><strong>clusterAddrTable：</strong>Broker集群信息，存储集群中所有Broker名称</p><p><strong>brokerLiveTable：</strong>Broker状态信息，NameServer每次收到心跳包是会替换该信息</p><p><strong>filterServerTable：</strong>Broker上的FilterServer列表，用于类模式消息过滤。</p><blockquote><p>RocketMQ基于定于发布机制，一个Topic拥有多个消息队列，一个Broker为每一个主题创建4个读队列和4个写队列。多个Broker组成一个集群，集群由相同的多台Broker组成Master-Slave架构，brokerId为0代表Master，大于0为Slave。BrokerLiveInfo中的lastUpdateTimestamp存储上次收到Broker心跳包的时间。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/shi-ti-shu-ju-shi-li.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/shi-ti-shu-ju-shi-li2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h4 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h4><h5 id="发送心跳包"><a href="#发送心跳包" class="headerlink" title="发送心跳包"></a>发送心跳包</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/lu-you-zhu-ce.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>RocketMQ路由注册是通过Broker与NameServer的心跳功能实现的。Broker启动时向集群中所有的NameServer发送心跳信息，每隔30s向集群中所有NameServer发送心跳包，NameServer收到心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdataTimeStamp信息，然后NameServer每隔10s扫描brokerLiveTable，如果连续120S没有收到心跳包，NameServer将移除Broker的路由信息同时关闭Socket连接。</p><p><strong><em>代码：BrokerController#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Broker信息</span></span><br><span class="line"><span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//每隔30s上报Broker信息到NameServer</span></span><br><span class="line"><span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), </span><br><span class="line">                                                  TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p><strong><em>代码：BrokerOuterAPI#registerBrokerAll</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得nameServer地址信息</span></span><br><span class="line">List&lt;String&gt; nameServerAddressList = <span class="keyword">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line"><span class="comment">//遍历所有nameserver列表</span></span><br><span class="line"><span class="keyword">if</span> (nameServerAddressList != <span class="keyword">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装请求头</span></span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader = <span class="keyword">new</span> RegisterBrokerRequestHeader();</span><br><span class="line">    requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">    requestHeader.setBrokerId(brokerId);</span><br><span class="line">    requestHeader.setBrokerName(brokerName);</span><br><span class="line">    requestHeader.setClusterName(clusterName);</span><br><span class="line">    requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">    requestHeader.setCompressed(compressed);</span><br><span class="line"><span class="comment">//封装请求体</span></span><br><span class="line">    RegisterBrokerBody requestBody = <span class="keyword">new</span> RegisterBrokerBody();</span><br><span class="line">    requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">    requestBody.setFilterServerList(filterServerList);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = requestBody.encode(compressed);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyCrc32 = UtilAll.crc32(body);</span><br><span class="line">    requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nameServerAddressList.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">        brokerOuterExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//分别向NameServer注册</span></span><br><span class="line">                    RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        registerBrokerResultList.add(result);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"register broker[&#123;&#125;]to name server &#123;&#125; OK"</span>, brokerId, namesrvAddr);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(<span class="string">"registerBroker Exception, &#123;&#125;"</span>, namesrvAddr, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：BrokerOutAPI#registerBroker</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.remotingClient.invokeOneway(namesrvAddr, request, timeoutMills);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingTooMuchRequestException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(namesrvAddr, request, timeoutMills);</span><br></pre></td></tr></table></figure><h5 id="处理心跳包"><a href="#处理心跳包" class="headerlink" title="处理心跳包"></a>处理心跳包</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/nameserver-chu-li-lu-you-zhu-ce.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="500" alt title></p><p><code>org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor</code>网路处理类解析请求类型，如果请求类型是为<strong><em>REGISTER_BROKER</em></strong>，则将请求转发到<code>RouteInfoManager#regiesterBroker</code></p><p><strong><em>代码：DefaultRequestProcessor#processRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是注册Broker信息</span></span><br><span class="line"><span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line"><span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注册Broker信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultRequestProcessor#registerBroker</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">    requestHeader.getClusterName(),</span><br><span class="line">    requestHeader.getBrokerAddr(),</span><br><span class="line">    requestHeader.getBrokerName(),</span><br><span class="line">    requestHeader.getBrokerId(),</span><br><span class="line">    requestHeader.getHaServerAddr(),</span><br><span class="line">    topicConfigWrapper,</span><br><span class="line">    <span class="keyword">null</span>,</span><br><span class="line">    ctx.channel()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong><em>代码：RouteInfoManager#registerBroker</em></strong></p><p>维护路由信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line">Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">    brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">&#125;</span><br><span class="line">brokerNames.add(brokerName);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line">BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line"><span class="comment">//第一次注册,则创建brokerData</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">    registerFirst = <span class="keyword">true</span>;</span><br><span class="line">    brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">    <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非第一次注册,更新Broker</span></span><br><span class="line">Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || </span><br><span class="line">        registerFirst) &#123;</span><br><span class="line">        ConcurrentMap&lt;String, TopicConfig&gt; tcTable = topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">        <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：RouteInfoManager#createAndUpdateQueueData</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建QueueData</span></span><br><span class="line">QueueData queueData = <span class="keyword">new</span> QueueData();</span><br><span class="line">queueData.setBrokerName(brokerName);</span><br><span class="line">queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</span><br><span class="line">queueData.setReadQueueNums(topicConfig.getReadQueueNums());</span><br><span class="line">queueData.setPerm(topicConfig.getPerm());</span><br><span class="line">queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</span><br><span class="line"><span class="comment">//获得topicQueueTable中队列集合</span></span><br><span class="line">List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topicConfig.getTopicName());</span><br><span class="line">    <span class="comment">//topicQueueTable为空,则直接添加queueData到队列集合</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == queueDataList) &#123;</span><br><span class="line">    queueDataList = <span class="keyword">new</span> LinkedList&lt;QueueData&gt;();</span><br><span class="line">    queueDataList.add(queueData);</span><br><span class="line">    <span class="keyword">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</span><br><span class="line">    log.info(<span class="string">"new topic registered, &#123;&#125; &#123;&#125;"</span>, topicConfig.getTopicName(), queueData);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是新的队列</span></span><br><span class="line">    <span class="keyword">boolean</span> addNewOne = <span class="keyword">true</span>;</span><br><span class="line">    Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        QueueData qd = it.next();</span><br><span class="line">            <span class="comment">//如果brokerName相同,代表不是新的队列</span></span><br><span class="line">        <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (qd.equals(queueData)) &#123;</span><br><span class="line">                addNewOne = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;"</span>, topicConfig.getTopicName(), qd,</span><br><span class="line">                        queueData);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果是新的队列,则添加队列到queueDataList</span></span><br><span class="line">        <span class="keyword">if</span> (addNewOne) &#123;</span><br><span class="line">            queueDataList.add(queueData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerLiveTable</span></span><br><span class="line">BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,<span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">    System.currentTimeMillis(),</span><br><span class="line">    topicConfigWrapper.getDataVersion(),</span><br><span class="line">    channel,</span><br><span class="line">    haServerAddr));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护filterServerList</span></span><br><span class="line"><span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">    String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">    <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">        <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">            result.setMasterAddr(masterAddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**RocketMQ有两个触发点来删除路由信息**：</span><br><span class="line"></span><br><span class="line">* NameServer定期扫描brokerLiveTable检测上次心跳包与当前系统的时间差，如果时间超过120s，则需要移除broker。</span><br><span class="line">* Broker在正常关闭的情况下，会执行unregisterBroker指令</span><br><span class="line"></span><br><span class="line">这两种方式路由删除的方法都是一样的，就是从相关路由表中删除与该broker相关的信息。</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/lu-you-shan-chu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10&quot; width=&quot;600&quot; alt=&quot;&quot; title=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">***代码：NamesrvController#initialize***</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//每隔10s扫描一次为活跃Broker</span><br><span class="line">this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        NamesrvController.this.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 5, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p><strong><em>代码：RouteInfoManager#scanNotActiveBroker</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scanNotActiveBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得brokerLiveTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class="keyword">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历brokerLiveTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class="line">        <span class="keyword">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class="line">        <span class="comment">//如果收到心跳包的时间距当时时间是否超过120s</span></span><br><span class="line">        <span class="keyword">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class="line">            <span class="comment">//移除broker</span></span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="comment">//维护路由表</span></span><br><span class="line">            <span class="keyword">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：RouteInfoManager#onChannelDestroy</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请写锁,根据brokerAddress从brokerLiveTable和filterServerTable移除</span></span><br><span class="line"><span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"><span class="keyword">this</span>.brokerLiveTable.remove(brokerAddrFound);</span><br><span class="line"><span class="keyword">this</span>.filterServerTable.remove(brokerAddrFound);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护brokerAddrTable</span></span><br><span class="line">String brokerNameFound = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> removeBrokerName = <span class="keyword">false</span>;</span><br><span class="line">Iterator&lt;Entry&lt;String, BrokerData&gt;&gt; itBrokerAddrTable =<span class="keyword">this</span>.brokerAddrTable.entrySet().iterator();</span><br><span class="line"><span class="comment">//遍历brokerAddrTable</span></span><br><span class="line"><span class="keyword">while</span> (itBrokerAddrTable.hasNext() &amp;&amp; (<span class="keyword">null</span> == brokerNameFound)) &#123;</span><br><span class="line">    BrokerData brokerData = itBrokerAddrTable.next().getValue();</span><br><span class="line">    <span class="comment">//遍历broker地址</span></span><br><span class="line">    Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerData.getBrokerAddrs().entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;Long, String&gt; entry = it.next();</span><br><span class="line">        Long brokerId = entry.getKey();</span><br><span class="line">        String brokerAddr = entry.getValue();</span><br><span class="line">        <span class="comment">//根据broker地址移除brokerAddr</span></span><br><span class="line">        <span class="keyword">if</span> (brokerAddr.equals(brokerAddrFound)) &#123;</span><br><span class="line">            brokerNameFound = brokerData.getBrokerName();</span><br><span class="line">            it.remove();</span><br><span class="line">            log.info(<span class="string">"remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</span><br><span class="line">                brokerId, brokerAddr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果当前主题只包含待移除的broker,则移除该topic</span></span><br><span class="line">    <span class="keyword">if</span> (brokerData.getBrokerAddrs().isEmpty()) &#123;</span><br><span class="line">        removeBrokerName = <span class="keyword">true</span>;</span><br><span class="line">        itBrokerAddrTable.remove();</span><br><span class="line">        log.info(<span class="string">"remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed"</span>,</span><br><span class="line">            brokerData.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护clusterAddrTable</span></span><br><span class="line"><span class="keyword">if</span> (brokerNameFound != <span class="keyword">null</span> &amp;&amp; removeBrokerName) &#123;</span><br><span class="line">    Iterator&lt;Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = <span class="keyword">this</span>.clusterAddrTable.entrySet().iterator();</span><br><span class="line">    <span class="comment">//遍历clusterAddrTable</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();</span><br><span class="line">        <span class="comment">//获得集群名称</span></span><br><span class="line">        String clusterName = entry.getKey();</span><br><span class="line">        <span class="comment">//获得集群中brokerName集合</span></span><br><span class="line">        Set&lt;String&gt; brokerNames = entry.getValue();</span><br><span class="line">        <span class="comment">//从brokerNames中移除brokerNameFound</span></span><br><span class="line">        <span class="keyword">boolean</span> removed = brokerNames.remove(brokerNameFound);</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            log.info(<span class="string">"remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed"</span>,</span><br><span class="line">                brokerNameFound, clusterName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brokerNames.isEmpty()) &#123;</span><br><span class="line">                log.info(<span class="string">"remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster"</span>,</span><br><span class="line">                    clusterName);</span><br><span class="line">                <span class="comment">//如果集群中不包含任何broker,则移除该集群</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维护topicQueueTable队列</span></span><br><span class="line"><span class="keyword">if</span> (removeBrokerName) &#123;</span><br><span class="line">    <span class="comment">//遍历topicQueueTable</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, List&lt;QueueData&gt;&gt;&gt; itTopicQueueTable =</span><br><span class="line">        <span class="keyword">this</span>.topicQueueTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (itTopicQueueTable.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, List&lt;QueueData&gt;&gt; entry = itTopicQueueTable.next();</span><br><span class="line">        <span class="comment">//主题名称</span></span><br><span class="line">        String topic = entry.getKey();</span><br><span class="line">        <span class="comment">//队列集合</span></span><br><span class="line">        List&lt;QueueData&gt; queueDataList = entry.getValue();</span><br><span class="line"><span class="comment">//遍历该主题队列</span></span><br><span class="line">        Iterator&lt;QueueData&gt; itQueueData = queueDataList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (itQueueData.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//从队列中移除为活跃broker信息</span></span><br><span class="line">            QueueData queueData = itQueueData.next();</span><br><span class="line">            <span class="keyword">if</span> (queueData.getBrokerName().equals(brokerNameFound)) &#123;</span><br><span class="line">                itQueueData.remove();</span><br><span class="line">                log.info(<span class="string">"remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed"</span>,</span><br><span class="line">                    topic, queueData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果该topic的队列为空,则移除该topic</span></span><br><span class="line">        <span class="keyword">if</span> (queueDataList.isEmpty()) &#123;</span><br><span class="line">            itTopicQueueTable.remove();</span><br><span class="line">            log.info(<span class="string">"remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed"</span>,</span><br><span class="line">                topic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放写锁</span></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h4><p>RocketMQ路由发现是非实时的，当Topic路由出现变化后，NameServer不会主动推送给客户端，而是由客户端定时拉取主题最新的路由。</p><p><strong><em>代码：DefaultRequestProcessor#getRouteInfoByTopic</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line"><span class="comment">//调用RouteInfoManager的方法,从路由表topicQueueTable、brokerAddrTable、filterServerTable中分别填充TopicRouteData的List&lt;QueueData&gt;、List&lt;BrokerData&gt;、filterServer</span></span><br><span class="line">    TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line"><span class="comment">//如果找到主题对应你的路由信息并且该主题为顺序消息，则从NameServer KVConfig中获取关于顺序消息相关的配置填充路由信息</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">            String orderTopicConf =</span><br><span class="line">                <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                    requestHeader.getTopic());</span><br><span class="line">            topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">        response.setBody(content);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">    response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</span><br><span class="line">        + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/nameserver-xiao-jie.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>消息生产者的代码都在client模块中，相对于RocketMQ来讲，消息生产者就是客户端，也是消息的提供者。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/defaultmqproducer-lei-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="方法和属性"><a href="#方法和属性" class="headerlink" title="方法和属性"></a>方法和属性</h3><h4 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mqadmin.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建主题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTopic</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String newTopic, <span class="keyword">final</span> <span class="keyword">int</span> queueNum)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据时间戳从队列中查找消息偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">searchOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span></span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找消息队列中最大的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">maxOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找消息队列中最小的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">minOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span></span></span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据偏移量查找消息</span></span><br><span class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(<span class="keyword">final</span> String offsetMsgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span></span><br><span class="line"><span class="function">        InterruptedException, MQClientException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据条件查找消息</span></span><br><span class="line"><span class="function">QueryResult <span class="title">queryMessage</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum, <span class="keyword">final</span> <span class="keyword">long</span> begin,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> end)</span> <span class="keyword">throws</span> MQClientException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据消息ID和主题查找消息</span></span><br><span class="line"><span class="function">MessageExt <span class="title">viewMessage</span><span class="params">(String topic,String msgId)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException</span>;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mqproducer.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找该主题下所有消息</span></span><br><span class="line"><span class="function">List&lt;MessageQueue&gt; <span class="title">fetchPublishMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> <span class="keyword">throws</span> MQClientException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,</span></span><br><span class="line"><span class="function">        InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步超时发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">        RemotingException, MQBrokerException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">        RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步超时发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送单向消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(<span class="keyword">final</span> Message msg)</span> <span class="keyword">throws</span> MQClientException, RemotingException,</span></span><br><span class="line"><span class="function">    InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择指定队列同步发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">    RemotingException, MQBrokerException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择指定队列异步发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> SendCallback sendCallback)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择指定队列单项发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOneway</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> MessageQueue mq)</span> <span class="keyword">throws</span> MQClientException,</span></span><br><span class="line"><span class="function">    RemotingException, InterruptedException</span>;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量发送消息</span></span><br><span class="line"><span class="function">SendResult <span class="title">send</span><span class="params">(<span class="keyword">final</span> Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException,InterruptedException</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/defaultmqproducer-shu-xing.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">producerGroup：生产者所属组</span><br><span class="line">createTopicKey：默认Topic</span><br><span class="line">defaultTopicQueueNums：默认主题在每一个Broker队列数量</span><br><span class="line">sendMsgTimeout：发送消息默认超时时间，默认<span class="number">3</span>s</span><br><span class="line">compressMsgBodyOverHowmuch：消息体超过该值则启用压缩，默认<span class="number">4</span>k</span><br><span class="line">retryTimesWhenSendFailed：同步方式发送消息重试次数，默认为<span class="number">2</span>，总共执行<span class="number">3</span>次</span><br><span class="line">retryTimesWhenSendAsyncFailed：异步方法发送消息重试次数，默认为<span class="number">2</span></span><br><span class="line">retryAnotherBrokerWhenNotStoreOK：消息重试时选择另外一个Broker时，是否不等待存储结果就返回，默认为<span class="keyword">false</span></span><br><span class="line">maxMessageSize：允许发送的最大消息长度，默认为<span class="number">4</span>M</span><br></pre></td></tr></table></figure><h3 id="启动流程-1"><a href="#启动流程-1" class="headerlink" title="启动流程"></a>启动流程</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/sheng-chan-zhe-qi-dong-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查生产者组是否满足要求</span></span><br><span class="line"><span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="comment">//更改当前instanceName为进程ID</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得MQ客户端实例</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br></pre></td></tr></table></figure><blockquote><p>整个JVM中只存在一个MQClientManager实例，维护一个MQClientInstance缓存表</p><p>ConcurrentMap<string * clientid , mqclientinstance> factoryTable = new ConcurrentHashMap<string,mqclientinstance>();</string,mqclientinstance></string></p><p>同一个clientId只会创建一个MQClientInstance。</p><p>MQClientInstance封装了RocketMQ网络处理API，是消息生产者和消息消费者与NameServer、Broker打交道的网络通道</p></blockquote><p><strong><em>代码：MQClientManager#getAndCreateMQClientInstance</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MQClientInstance <span class="title">getAndCreateMQClientInstance</span><span class="params">(<span class="keyword">final</span> ClientConfig clientConfig, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                     RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建客户端ID</span></span><br><span class="line">    String clientId = clientConfig.buildMQClientId();</span><br><span class="line">    <span class="comment">//根据客户端ID或者客户端实例</span></span><br><span class="line">    MQClientInstance instance = <span class="keyword">this</span>.factoryTable.get(clientId);</span><br><span class="line">    <span class="comment">//实例如果为空就创建新的实例,并添加到实例表中</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        instance =</span><br><span class="line">            <span class="keyword">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class="line">                <span class="keyword">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class="line">        MQClientInstance prev = <span class="keyword">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = prev;</span><br><span class="line">            log.warn(<span class="string">"Returned Previous MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Created new MQClientInstance for clientId:[&#123;&#125;]"</span>, clientId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMQProducerImpl#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册当前生产者到到MQClientInstance管理中,方便后续调用网路请求</span></span><br><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">        <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动生产者</span></span><br><span class="line"><span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">    mQClientFactory.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-fa-song.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：DefaultMQProducerImpl#send(Message msg)</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> send(msg, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMQProducerImpl#send(Message msg,long timeout)</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送消息,默认超时时间为3s</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Message msg,<span class="keyword">long</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.SYNC, <span class="keyword">null</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验消息</span></span><br><span class="line">Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br></pre></td></tr></table></figure><h4 id="验证消息"><a href="#验证消息" class="headerlink" title="验证消息"></a>验证消息</h4><p><strong><em>代码：Validators#checkMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(Message msg, DefaultMQProducer defaultMQProducer)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验主题</span></span><br><span class="line">    Validators.checkTopic(msg.getTopic());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验消息体</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == msg.getBody()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == msg.getBody().length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL, <span class="string">"the message body length is zero"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getBody().length &gt; defaultMQProducer.getMaxMessageSize()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(ResponseCode.MESSAGE_ILLEGAL,</span><br><span class="line">            <span class="string">"the message body size over max value, MAX: "</span> + defaultMQProducer.getMaxMessageSize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找路由"><a href="#查找路由" class="headerlink" title="查找路由"></a>查找路由</h4><p><strong><em>代码：DefaultMQProducerImpl#tryToFindTopicPublishInfo</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获得主题的路由信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">//路由信息为空,则从NameServer获取路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果未找到当前主题的路由信息,则用默认主题继续查找</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/topic-lu-you-xin-xi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：TopicPublishInfo</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;<span class="comment">//是否是顺序消息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();<span class="comment">//该主题消息队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();<span class="comment">//每选择一次消息队列,该值+1</span></span><br><span class="line">    <span class="keyword">private</span> TopicRouteData topicRouteData;<span class="comment">//关联Topic路由元信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="comment">//使用默认主题从NameServer获取路由信息</span></span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//使用指定主题从NameServer获取路由信息</span></span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断路由是否需要更改</span></span><br><span class="line">TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line"><span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line"><span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">    changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQClientInstance#updateTopicRouteInfoFromNameServer</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    <span class="comment">//将topicRouteData转换为发布队列</span></span><br><span class="line">    TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">    publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//遍历生产</span></span><br><span class="line">    Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">        MQProducerInner impl = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//生产者不为空时,更新publishInfo信息</span></span><br><span class="line">            impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQClientInstance#topicRouteData2TopicPublishInfo</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建TopicPublishInfo对象</span></span><br><span class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">    <span class="comment">//关联topicRoute</span></span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line">    <span class="comment">//顺序消息,更新TopicPublishInfo</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非顺序消息更新TopicPublishInfo</span></span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);</span><br><span class="line">            <span class="comment">//遍历topic队列信息</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="comment">//是否是写队列</span></span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//遍历写队列Broker</span></span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="comment">//根据名称获得读队列对应的Broker</span></span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                        brokerData = bd;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//封装TopicPublishInfo写队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回TopicPublishInfo对象</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择队列"><a href="#选择队列" class="headerlink" title="选择队列"></a>选择队列</h4><ul><li>默认不启用Broker故障延迟机制</li></ul><p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue(lastBrokerName)</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次选择队列</span></span><br><span class="line">    <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//sendWhichQueue</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">        <span class="comment">//遍历消息队列集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//sendWhichQueue自增后取模</span></span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//规避上次Broker队列</span></span><br><span class="line">            MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">            <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果以上情况都不满足,返回sendWhichQueue取模后的队列</span></span><br><span class="line">        <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：TopicPublishInfo#selectOneMessageQueue()</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次选择队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//sendWhichQueue自增</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">    <span class="comment">//对队列大小取模</span></span><br><span class="line">    <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//返回对应的队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启用Broker故障延迟机制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Broker故障延迟机制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对sendWhichQueue自增</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="comment">//对消息队列轮询获取一个队列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//验证该队列是否可用</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="comment">//可用</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="comment">//获得Broker的写队列集合</span></span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获得一个队列,指定broker和队列ID并返回</span></span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/broker-gu-zhang-yan-chi-ji-zhi-he-xin-lei.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li>延迟机制接口规范</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LatencyFaultTolerance</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//更新失败条目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> T name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span></span>;</span><br><span class="line"><span class="comment">//判断Broker是否可用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(<span class="keyword">final</span> T name)</span></span>;</span><br><span class="line"><span class="comment">//移除Fault条目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> T name)</span></span>;</span><br><span class="line"><span class="comment">//尝试从规避的Broker中选择一个可用的Broker</span></span><br><span class="line">    <span class="function">T <span class="title">pickOneAtLeast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FaultItem：失败条目</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//条目唯一键,这里为brokerName</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="comment">//本次消息发送延迟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> currentLatency;</span><br><span class="line">    <span class="comment">//故障规避开始时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTimestamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息失败策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQFaultStrategy</span> </span>&#123;</span><br><span class="line">   <span class="comment">//根据currentLatency本地消息发送延迟,从latencyMax尾部向前找到第一个比currentLatency小的索引,如果没有找到,返回0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line">    <span class="comment">//根据这个索引从notAvailableDuration取出对应的时间,在该时长内,Broker设置为不可用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><strong><em>原理分析</em></strong></u></p><p><strong><em>代码：DefaultMQProducerImpl#sendDefaultImpl</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, </span><br><span class="line">                                 mq, </span><br><span class="line">                                 communicationMode, </span><br><span class="line">                                 sendCallback, </span><br><span class="line">                                 topicPublishInfo, </span><br><span class="line">                                 timeout - costTime);</span><br><span class="line">endTimestamp = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>如果上述发送过程出现异常，则调用<code>DefaultMQProducerImpl#updateFaultItem</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数一：broker名称</span></span><br><span class="line">    <span class="comment">//参数二:本次消息发送延迟时间</span></span><br><span class="line">    <span class="comment">//参数三:是否隔离</span></span><br><span class="line">    <span class="keyword">this</span>.mqFaultStrategy.updateFaultItem(brokerName, currentLatency, isolation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQFaultStrategy#updateFaultItem</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="comment">//计算broker规避的时长</span></span><br><span class="line">        <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="comment">//更新该FaultItem规避时长</span></span><br><span class="line">        <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQFaultStrategy#computeNotAvailableDuration</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历latencyMax</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//找到第一个比currentLatency的latencyMax值</span></span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到则返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：LatencyFaultToleranceImpl#updateFaultItem</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得原FaultItem</span></span><br><span class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="comment">//为空新建faultItem对象,设置规避时长和开始时间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//更新规避时长和开始时间</span></span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h4><p>消息发送API核心入口<strong><em>DefaultMQProducerImpl#sendKernelImpl</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Message msg,//待发送消息</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue mq,//消息发送队列</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> CommunicationMode communicationMode,//消息发送内模式</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> SendCallback sendCallback,pp//异步消息回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,//主题路由信息</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeout//超时时间</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得broker网络地址信息</span></span><br><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">    <span class="comment">//没有找到从NameServer更新broker网络地址信息</span></span><br><span class="line">    tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">    brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为消息分类唯一ID</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> topicWithNamespace = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">    msg.setInstanceId(<span class="keyword">this</span>.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">    topicWithNamespace = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消息大小超过4K,启用消息压缩</span></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">    msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是事务消息,设置消息标记MessageSysFlag.TRANSACTION_PREPARED_TYPE</span></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了消息发送钩子函数,在执行消息发送前的增强逻辑</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">    context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">    context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    context.setCommunicationMode(communicationMode);</span><br><span class="line">    context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">    context.setBrokerAddr(brokerAddr);</span><br><span class="line">    context.setMessage(msg);</span><br><span class="line">    context.setMq(mq);</span><br><span class="line">    context.setNamespace(<span class="keyword">this</span>.defaultMQProducer.getNamespace());</span><br><span class="line">    String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：SendMessageHook</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendMessageHook</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hookName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(<span class="keyword">final</span> SendMessageContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMQProducerImpl#sendKernelImpl</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息发送请求包</span></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line"><span class="comment">//生产者组</span></span><br><span class="line">requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line"><span class="comment">//主题</span></span><br><span class="line">requestHeader.setTopic(msg.getTopic());</span><br><span class="line"><span class="comment">//默认创建主题Key</span></span><br><span class="line">requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line"><span class="comment">//该主题在单个Broker默认队列树</span></span><br><span class="line">requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line"><span class="comment">//队列ID</span></span><br><span class="line">requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line"><span class="comment">//消息系统标记</span></span><br><span class="line">requestHeader.setSysFlag(sysFlag);</span><br><span class="line"><span class="comment">//消息发送时间</span></span><br><span class="line">requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line"><span class="comment">//消息标记</span></span><br><span class="line">requestHeader.setFlag(msg.getFlag());</span><br><span class="line"><span class="comment">//消息扩展信息</span></span><br><span class="line">requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"><span class="comment">//消息重试次数</span></span><br><span class="line">requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line"><span class="comment">//是否是批量消息等</span></span><br><span class="line">requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line"><span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">    String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">    <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">    <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ASYNC:<span class="comment">//异步发送</span></span><br><span class="line">    Message tmpMessage = msg;</span><br><span class="line">    <span class="keyword">boolean</span> messageCloned = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">        messageCloned = <span class="keyword">true</span>;</span><br><span class="line">        msg.setBody(prevBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicWithNamespace) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!messageCloned) &#123;</span><br><span class="line">            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">            messageCloned = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), </span><br><span class="line">                                                    <span class="keyword">this</span>.defaultMQProducer.getNamespace()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">        brokerAddr,</span><br><span class="line">        mq.getBrokerName(),</span><br><span class="line">        tmpMessage,</span><br><span class="line">        requestHeader,</span><br><span class="line">        timeout - costTimeAsync,</span><br><span class="line">        communicationMode,</span><br><span class="line">        sendCallback,</span><br><span class="line">        topicPublishInfo,</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">        context,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ONEWAY:</span><br><span class="line"><span class="keyword">case</span> SYNC:<span class="comment">//同步发送</span></span><br><span class="line">    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout - costTimeSync,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果注册了钩子函数,则发送完毕后执行钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/fa-song-pi-liang-xiao-xi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>批量消息发送是将同一个主题的多条消息一起打包发送到消息服务端，减少网络调用次数，提高网络传输效率。当然，并不是在同一批次中发送的消息数量越多越好，其判断依据是单条消息的长度，如果单条消息内容比较长，则打包多条消息发送会影响其他线程发送消息的响应时间，并且单批次消息总长度不能超过DefaultMQProducer#maxMessageSize。</p><p>批量消息发送要解决的问题是如何将这些消息编码以便服务端能够正确解码出每条消息的消息内容。</p><p><strong><em>代码：DefaultMQProducer#send</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">send</span><span class="params">(Collection&lt;Message&gt; msgs)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//压缩消息集合成一条消息,然后发送出去</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.send(batch(msgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMQProducer#batch</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MessageBatch <span class="title">batch</span><span class="params">(Collection&lt;Message&gt; msgs)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    MessageBatch msgBatch;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将集合消息封装到MessageBatch</span></span><br><span class="line">        msgBatch = MessageBatch.generateFromList(msgs);</span><br><span class="line">        <span class="comment">//遍历消息集合,检查消息合法性,设置消息ID,设置Topic</span></span><br><span class="line">        <span class="keyword">for</span> (Message message : msgBatch) &#123;</span><br><span class="line">            Validators.checkMessage(message, <span class="keyword">this</span>);</span><br><span class="line">            MessageClientIDSetter.setUniqID(message);</span><br><span class="line">            message.setTopic(withNamespace(message.getTopic()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压缩消息,设置消息body</span></span><br><span class="line">        msgBatch.setBody(msgBatch.encode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"Failed to initiate the MessageBatch"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置msgBatch的topic</span></span><br><span class="line">    msgBatch.setTopic(withNamespace(msgBatch.getTopic()));</span><br><span class="line">    <span class="keyword">return</span> msgBatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息存储-2"><a href="#消息存储-2" class="headerlink" title="消息存储"></a>消息存储</h2><h3 id="消息存储核心类"><a href="#消息存储核心类" class="headerlink" title="消息存储核心类"></a>消息存储核心类</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/defaultmessagestore.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageStoreConfig messageStoreConfig;<span class="comment">//消息配置属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CommitLog commitLog;<span class="comment">//CommitLog文件存储的实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, ConcurrentMap&lt;Integer<span class="comment">/* queueId */</span>, ConsumeQueue&gt;&gt; consumeQueueTable;<span class="comment">//消息队列存储缓存表,按照消息主题分组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> FlushConsumeQueueService flushConsumeQueueService;<span class="comment">//消息队列文件刷盘线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanCommitLogService cleanCommitLogService;<span class="comment">//清除CommitLog文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CleanConsumeQueueService cleanConsumeQueueService;<span class="comment">//清除ConsumerQueue队列文件服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IndexService indexService;<span class="comment">//索引实现类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;<span class="comment">//MappedFile分配服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReputMessageService reputMessageService;<span class="comment">//CommitLog消息分发,根据CommitLog文件构建ConsumerQueue、IndexFile文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HAService haService;<span class="comment">//存储HA机制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScheduleMessageService scheduleMessageService;<span class="comment">//消息服务调度线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StoreStatsService storeStatsService;<span class="comment">//消息存储服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransientStorePool transientStorePool;<span class="comment">//消息堆外内存缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerStatsManager brokerStatsManager;<span class="comment">//Broker状态管理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MessageArrivingListener messageArrivingListener;<span class="comment">//消息拉取长轮询模式消息达到监听器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BrokerConfig brokerConfig;<span class="comment">//Broker配置类</span></span><br><span class="line"><span class="keyword">private</span> StoreCheckpoint storeCheckpoint;<span class="comment">//文件刷盘监测点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;CommitLogDispatcher&gt; dispatcherList;<span class="comment">//CommitLog文件转发请求</span></span><br></pre></td></tr></table></figure><h3 id="消息存储流程"><a href="#消息存储流程" class="headerlink" title="消息存储流程"></a>消息存储流程</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-cun-chu-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>消息存储入口：DefaultMessageStore#putMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断Broker角色如果是从节点,则无需写入</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> ((value % <span class="number">50000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"message store is slave mode, so putMessage is forbidden "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前写入状态如果是正在写入,则不能继续</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.runningFlags.isWriteable()) &#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="keyword">this</span>.printTimes.getAndIncrement();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.printTimes.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息主题长度是否超过最大限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getTopic().length() &gt; Byte.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message topic length too long "</span> + msg.getTopic().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断消息属性长度是否超过限制</span></span><br><span class="line"><span class="keyword">if</span> (msg.getPropertiesString() != <span class="keyword">null</span> &amp;&amp; msg.getPropertiesString().length() &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message properties length too long "</span> + msg.getPropertiesString().length());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断系统PageCache缓存去是否占用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息写入CommitLog文件</span></span><br><span class="line">PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br></pre></td></tr></table></figure><p><strong><em>代码：CommitLog#putMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录消息存储时间</span></span><br><span class="line">msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果mappedFile如果为空或者已满,创建新的mappedFile文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">    mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果创建失败,直接返回</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">    log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入消息到mappedFile中</span></span><br><span class="line">result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br></pre></td></tr></table></figure><p><strong><em>代码：MappedFile#appendMessagesInner</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得文件的写入指针</span></span><br><span class="line"><span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指针大于文件大小则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">    <span class="comment">//通过writeBuffer.slice()创建一个与MappedFile共享的内存区,并设置position为当前指针</span></span><br><span class="line">    ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">    byteBuffer.position(currentPos);</span><br><span class="line">    AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">       <span class="comment">//通过回调方法写入</span></span><br><span class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">        result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">    <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：CommitLog#doAppend</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件写入位置</span></span><br><span class="line"><span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"><span class="comment">//设置消息ID</span></span><br><span class="line"><span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line">String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得该消息在消息队列中的偏移量</span></span><br><span class="line">keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">keyBuilder.append(msgInner.getTopic());</span><br><span class="line">keyBuilder.append(<span class="string">'-'</span>);</span><br><span class="line">keyBuilder.append(msgInner.getQueueId());</span><br><span class="line">String key = keyBuilder.toString();</span><br><span class="line">Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line">    queueOffset = <span class="number">0L</span>;</span><br><span class="line">    CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息属性长度</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">    log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息主题大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得消息体大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"><span class="comment">//计算消息总长度</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br></pre></td></tr></table></figure><p><strong><em>代码：CommitLog#calMsgLength</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMsgLength</span><span class="params">(<span class="keyword">int</span> bodyLength, <span class="keyword">int</span> topicLength, <span class="keyword">int</span> propertiesLength)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = <span class="number">4</span> <span class="comment">//TOTALSIZE</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//MAGICCODE  </span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//BODYCRC</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//QUEUEID</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//FLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//QUEUEOFFSET</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//SYSFLAG</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//BORNHOST</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STORETIMESTAMP</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//STOREHOSTADDRESS</span></span><br><span class="line">        + <span class="number">4</span> <span class="comment">//RECONSUMETIMES</span></span><br><span class="line">        + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset</span></span><br><span class="line">        + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY</span></span><br><span class="line">        + <span class="number">1</span> + topicLength <span class="comment">//TOPIC</span></span><br><span class="line">        + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength</span></span><br><span class="line">        + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> msgLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：CommitLog#doAppend</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息长度不能超过4M</span></span><br><span class="line"><span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line">    CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</span><br><span class="line">        + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息是如果没有足够的存储空间则新创建CommitLog文件</span></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">    <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">        queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息存储到ByteBuffer中,返回AppendMessageResult</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line">AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, </span><br><span class="line">                                                     msgLen, msgId,msgInner.getStoreTimestamp(), </span><br><span class="line">                                                     queueOffset, </span><br><span class="line">                                                     CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() </span><br><span class="line">                                                     -beginTimeMills);</span><br><span class="line"><span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">    <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="comment">//更新消息队列偏移量</span></span><br><span class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：CommitLog#putMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">putMessageLock.unlock();</span><br><span class="line"><span class="comment">//刷盘</span></span><br><span class="line">handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"><span class="comment">//执行HA主从同步</span></span><br><span class="line">handleHA(result, putMessageResult, msg);</span><br></pre></td></tr></table></figure><h3 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h3><p><img src="../%E6%96%87%E6%A1%A3/img/%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6.png" alt></p><ul><li>commitLog：消息存储目录</li><li>config：运行期间一些配置信息</li><li>consumerqueue：消息消费队列存储目录</li><li>index：消息索引文件存储目录</li><li>abort：如果存在改文件寿命Broker非正常关闭</li><li>checkpoint：文件检查点，存储CommitLog文件最后一次刷盘时间戳、consumerquueue最后一次刷盘时间，index索引文件最后一次刷盘时间戳。</li></ul><h3 id="存储文件内存映射"><a href="#存储文件内存映射" class="headerlink" title="存储文件内存映射"></a>存储文件内存映射</h3><p>RocketMQ通过使用内存映射文件提高IO访问性能，无论是CommitLog、ConsumerQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。</p><h4 id="MappedFileQueue"><a href="#MappedFileQueue" class="headerlink" title="MappedFileQueue"></a>MappedFileQueue</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mappedfilequeue.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String storePath;<span class="comment">//存储目录</span></span><br><span class="line"><span class="keyword">int</span> mappedFileSize;<span class="comment">// 单个文件大小</span></span><br><span class="line">CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles;<span class="comment">//MappedFile文件集合</span></span><br><span class="line">AllocateMappedFileService allocateMappedFileService;<span class="comment">//创建MapFile服务类</span></span><br><span class="line"><span class="keyword">long</span> flushedWhere = <span class="number">0</span>;<span class="comment">//当前刷盘指针</span></span><br><span class="line"><span class="keyword">long</span> committedWhere = <span class="number">0</span>;<span class="comment">//当前数据提交指针,内存中ByteBuffer当前的写指针,该值大于等于flushWhere</span></span><br></pre></td></tr></table></figure><ul><li>根据存储时间查询MappedFile</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getMappedFileByTime</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    Object[] mfs = <span class="keyword">this</span>.copyMappedFiles(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mfs)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//遍历MappedFile文件数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfs.length; i++) &#123;</span><br><span class="line">        MappedFile mappedFile = (MappedFile) mfs[i];</span><br><span class="line">        <span class="comment">//MappedFile文件的最后修改时间大于指定时间戳则返回该文件</span></span><br><span class="line">        <span class="keyword">if</span> (mappedFile.getLastModifiedTimestamp() &gt;= timestamp) &#123;</span><br><span class="line">            <span class="keyword">return</span> mappedFile;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (MappedFile) mfs[mfs.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据消息偏移量offset查找MappedFile</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得第一个MappedFile文件</span></span><br><span class="line">        MappedFile firstMappedFile = <span class="keyword">this</span>.getFirstMappedFile();</span><br><span class="line">        <span class="comment">//获得最后一个MappedFile文件</span></span><br><span class="line">        MappedFile lastMappedFile = <span class="keyword">this</span>.getLastMappedFile();</span><br><span class="line">        <span class="comment">//第一个文件和最后一个文件均不为空,则进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (firstMappedFile != <span class="keyword">null</span> &amp;&amp; lastMappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; firstMappedFile.getFileFromOffset() || </span><br><span class="line">                offset &gt;= lastMappedFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获得文件索引</span></span><br><span class="line">                <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((offset / <span class="keyword">this</span>.mappedFileSize) </span><br><span class="line">                                   - (firstMappedFile.getFileFromOffset() / <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">                MappedFile targetFile = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//根据索引返回目标文件</span></span><br><span class="line">                    targetFile = <span class="keyword">this</span>.mappedFiles.get(index);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetFile != <span class="keyword">null</span> &amp;&amp; offset &gt;= targetFile.getFileFromOffset()</span><br><span class="line">                    &amp;&amp; offset &lt; targetFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">                    <span class="keyword">return</span> targetFile;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (MappedFile tmpMappedFile : <span class="keyword">this</span>.mappedFiles) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (offset &gt;= tmpMappedFile.getFileFromOffset()</span><br><span class="line">                        &amp;&amp; offset &lt; tmpMappedFile.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">                        <span class="keyword">return</span> tmpMappedFile;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</span><br><span class="line">                <span class="keyword">return</span> firstMappedFile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"findMappedFileByOffset Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取存储文件最小偏移量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMinOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(<span class="number">0</span>).getFileFromOffset();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//continue;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"getMinOffset has exception."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取存储文件最大偏移量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getReadPosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回存储文件当前写指针</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxWrotePosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFile = getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mappedfile.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;<span class="comment">//操作系统每页大小,默认4K</span></span><br><span class="line">AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);<span class="comment">//当前JVM实例中MappedFile虚拟内存</span></span><br><span class="line">AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);<span class="comment">//当前JVM实例中MappedFile对象个数</span></span><br><span class="line">AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);<span class="comment">//当前文件的写指针</span></span><br><span class="line">AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);<span class="comment">//当前文件的提交指针</span></span><br><span class="line">AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);<span class="comment">//刷写到磁盘指针</span></span><br><span class="line"><span class="keyword">int</span> fileSize;<span class="comment">//文件大小</span></span><br><span class="line">FileChannel fileChannel;<span class="comment">//文件通道</span></span><br><span class="line">ByteBuffer writeBuffer = <span class="keyword">null</span>;<span class="comment">//堆外内存ByteBuffer</span></span><br><span class="line">TransientStorePool transientStorePool = <span class="keyword">null</span>;<span class="comment">//堆外内存池</span></span><br><span class="line">String fileName;<span class="comment">//文件名称</span></span><br><span class="line"><span class="keyword">long</span> fileFromOffset;<span class="comment">//该文件的处理偏移量</span></span><br><span class="line">File file;<span class="comment">//物理文件</span></span><br><span class="line">MappedByteBuffer mappedByteBuffer;<span class="comment">//物理文件对应的内存映射Buffer</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;<span class="comment">//文件最后一次内容写入时间</span></span><br><span class="line"><span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>;<span class="comment">//是否是MappedFileQueue队列中第一个文件</span></span><br></pre></td></tr></table></figure><p><strong><em>MappedFile初始化</em></strong></p><ul><li>未开启<code>transientStorePoolEnable</code>。<code>transientStorePoolEnable=true</code>为<code>true</code>表示数据先存储到堆外内存，然后通过<code>Commit</code>线程将数据提交到内存映射Buffer中，再通过<code>Flush</code>线程将内存映射<code>Buffer</code>中数据持久化磁盘。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="keyword">this</span>.file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">this</span>.fileFromOffset = Long.parseLong(<span class="keyword">this</span>.file.getName());</span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ensureDirOK(<span class="keyword">this</span>.file.getParent());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line">        TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line">        ok = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"create file channel "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"map file "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok &amp;&amp; <span class="keyword">this</span>.fileChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启<code>transientStorePoolEnable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize);</span><br><span class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer();<span class="comment">//初始化writeBuffer</span></span><br><span class="line">    <span class="keyword">this</span>.transientStorePool = transientStorePool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile提交</em></strong></p><p>提交数据到FileChannel，commitLeastPages为本次提交最小的页数，如果待提交数据不满commitLeastPages，则不执行本次提交操作。如果writeBuffer如果为空，直接返回writePosition指针，无需执行commit操作，表名commit操作主体是writeBuffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否满足提交条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in commit, hold failed, commit offset = "</span> + <span class="keyword">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据提交后,清空缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.transientStorePool != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.fileSize == <span class="keyword">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="keyword">this</span>.writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile#isAbleToCommit</em></strong></p><p>判断是否执行commit操作，如果文件已满返回true；如果commitLeastpages大于0，则比较writePosition与上一次提交的指针commitPosition的差值，除以OS_PAGE_SIZE得到当前脏页的数量，如果大于commitLeastPages则返回true，如果commitLeastpages小于0表示只要存在脏页就提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经刷盘指针</span></span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">    <span class="comment">//文件写指针</span></span><br><span class="line">    <span class="keyword">int</span> write = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"><span class="comment">//写满刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//文件内容达到commitLeastPages页数,则刷盘</span></span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile#commit0</em></strong></p><p>具体提交的实现，首先创建WriteBuffer区共享缓存区，然后将新创建的position回退到上一次提交的位置（commitPosition），设置limit为wrotePosition（当前最大有效数据指针），然后把commitPosition到wrotePosition的数据写入到FileChannel中，然后更新committedPosition指针为wrotePosition。commit的作用就是将MappedFile的writeBuffer中数据提交到文件通道FileChannel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commit0</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写指针</span></span><br><span class="line">    <span class="keyword">int</span> writePos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    <span class="comment">//上次提交指针</span></span><br><span class="line">    <span class="keyword">int</span> lastCommittedPosition = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePos - <span class="keyword">this</span>.committedPosition.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//复制共享内存区域</span></span><br><span class="line">            ByteBuffer byteBuffer = writeBuffer.slice();</span><br><span class="line">            <span class="comment">//设置提交位置是上次提交位置</span></span><br><span class="line">            byteBuffer.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//最大提交数量</span></span><br><span class="line">            byteBuffer.limit(writePos);</span><br><span class="line">            <span class="comment">//设置fileChannel位置为上次提交位置</span></span><br><span class="line">            <span class="keyword">this</span>.fileChannel.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//将lastCommittedPosition到writePos的数据复制到FileChannel中</span></span><br><span class="line">            <span class="keyword">this</span>.fileChannel.write(byteBuffer);</span><br><span class="line">            <span class="comment">//重置提交位置</span></span><br><span class="line">            <span class="keyword">this</span>.committedPosition.set(writePos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when commit data to FileChannel."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile#flush</em></strong></p><p>刷写磁盘，直接调用MappedByteBuffer或fileChannel的force方法将内存中的数据持久化到磁盘，那么flushedPosition应该等于MappedByteBuffer中的写指针；如果writeBuffer不为空，则flushPosition应该等于上一次的commit指针；因为上一次提交的数据就是进入到MappedByteBuffer中的数据；如果writeBuffer为空，数据时直接进入到MappedByteBuffer，wrotePosition代表的是MappedByteBuffer中的指针，故设置flushPosition为wrotePosition。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/flush.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据达到刷盘条件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        <span class="comment">//加锁，同步刷盘</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//获得读指针</span></span><br><span class="line">            <span class="keyword">int</span> value = getReadPosition();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//数据从writeBuffer提交数据到fileChannel再刷新到磁盘</span></span><br><span class="line">                <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//从mmap刷新数据到磁盘</span></span><br><span class="line">                    <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//更新刷盘位置</span></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(value);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in flush, hold failed, flush offset = "</span> + <span class="keyword">this</span>.flushedPosition.get());</span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile#getReadPosition</em></strong></p><p>获取当前文件最大可读指针。如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设置中,只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getReadPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果writeBuffer为空,刷盘的位置就是应该等于上次commit的位置,如果为空则为mmap的写指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.writeBuffer == <span class="keyword">null</span> ? <span class="keyword">this</span>.wrotePosition.get() : <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile#selectMappedBuffer</em></strong></p><p>查找pos到当前最大可读之间的数据，由于在整个写入期间都未曾改MappedByteBuffer的指针，如果mappedByteBuffer.slice()方法返回的共享缓存区空间为整个MappedFile，然后通过设置ByteBuffer的position为待查找的值，读取字节长度当前可读最大长度，最终返回的ByteBuffer的limit为size。整个共享缓存区的容量为（MappedFile#fileSize-pos）。故在操作SelectMappedBufferResult不能对包含在里面的ByteBuffer调用filp方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">selectMappedBuffer</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得最大可读指针</span></span><br><span class="line">    <span class="keyword">int</span> readPosition = getReadPosition();</span><br><span class="line">    <span class="comment">//pos小于最大可读指针,并且大于0</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; readPosition &amp;&amp; pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//复制mappedByteBuffer读共享区</span></span><br><span class="line">            ByteBuffer byteBuffer = <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">            <span class="comment">//设置读指针位置</span></span><br><span class="line">            byteBuffer.position(pos);</span><br><span class="line">            <span class="comment">//获得可读范围</span></span><br><span class="line">            <span class="keyword">int</span> size = readPosition - pos;</span><br><span class="line">            <span class="comment">//设置最大刻度范围</span></span><br><span class="line">            ByteBuffer byteBufferNew = byteBuffer.slice();</span><br><span class="line">            byteBufferNew.limit(size);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectMappedBufferResult(<span class="keyword">this</span>.fileFromOffset + pos, byteBufferNew, size, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>MappedFile#shutdown</em></strong></p><p>MappedFile文件销毁的实现方法为public boolean destory(long intervalForcibly)，intervalForcibly表示拒绝被销毁的最大存活时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> intervalForcibly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.available) &#123;</span><br><span class="line">        <span class="comment">//关闭MapedFile</span></span><br><span class="line">        <span class="keyword">this</span>.available = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//设置当前关闭时间戳</span></span><br><span class="line">        <span class="keyword">this</span>.firstShutdownTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">this</span>.release();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getRefCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((System.currentTimeMillis() - <span class="keyword">this</span>.firstShutdownTimestamp) &gt;= intervalForcibly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.refCount.set(-<span class="number">1000</span> - <span class="keyword">this</span>.getRefCount());</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TransientStorePool"><a href="#TransientStorePool" class="headerlink" title="TransientStorePool"></a>TransientStorePool</h4><p>短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。RocketMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/transientstorepool.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> poolSize;<span class="comment">//availableBuffers个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fileSize;<span class="comment">//每隔ByteBuffer大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers;<span class="comment">//ByteBuffer容器。双端队列</span></span><br></pre></td></tr></table></figure><p><strong><em>初始化</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建poolSize个堆外内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(fileSize);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> address = ((DirectBuffer) byteBuffer).address();</span><br><span class="line">        Pointer pointer = <span class="keyword">new</span> Pointer(address);</span><br><span class="line">        <span class="comment">//使用com.sun.jna.Library类库将该批内存锁定,避免被置换到交换区,提高存储性能</span></span><br><span class="line">        LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> NativeLong(fileSize));</span><br><span class="line"></span><br><span class="line">        availableBuffers.offer(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实时更新消息消费队列与索引文件"><a href="#实时更新消息消费队列与索引文件" class="headerlink" title="实时更新消息消费队列与索引文件"></a>实时更新消息消费队列与索引文件</h3><p>消息消费队文件、消息属性索引文件都是基于CommitLog文件构建的，当消息生产者提交的消息存储在CommitLog文件中，ConsumerQueue、IndexFile需要及时更新，否则消息无法及时被消费，根据消息属性查找消息也会出现较大延迟。RocketMQ通过开启一个线程ReputMessageService来准实时转发CommitLog文件更新事件，相应的任务处理器根据转发的消息及时更新ConsumerQueue、IndexFile文件。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-cun-chu-jie-gou.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/gou-jian-xiao-xi-xiao-fei-dui-lie-he-suo-yin-wen-j.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：DefaultMessageStore：start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置CommitLog内存中最大偏移量</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore：run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"><span class="comment">//每隔1毫秒就继续尝试推送消息到消息消费队列和索引文件</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore：deReput</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从result中循环遍历消息,一次读一条,创建DispatherRequest对象。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">DispatchRequest dispatchRequest =                               DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">int</span> size = dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>DispatchRequest</em></strong></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/dispatchrequest.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String topic; <span class="comment">//消息主题名称</span></span><br><span class="line"><span class="keyword">int</span> queueId;  <span class="comment">//消息队列ID</span></span><br><span class="line"><span class="keyword">long</span> commitLogOffset;<span class="comment">//消息物理偏移量</span></span><br><span class="line"><span class="keyword">int</span> msgSize;<span class="comment">//消息长度</span></span><br><span class="line"><span class="keyword">long</span> tagsCode;<span class="comment">//消息过滤tag hashCode</span></span><br><span class="line"><span class="keyword">long</span> storeTimestamp;<span class="comment">//消息存储时间戳</span></span><br><span class="line"><span class="keyword">long</span> consumeQueueOffset;<span class="comment">//消息队列偏移量</span></span><br><span class="line">String keys;<span class="comment">//消息索引key</span></span><br><span class="line"><span class="keyword">boolean</span> success;<span class="comment">//是否成功解析到完整的消息</span></span><br><span class="line">String uniqKey;<span class="comment">//消息唯一键</span></span><br><span class="line"><span class="keyword">int</span> sysFlag;<span class="comment">//消息系统标记</span></span><br><span class="line"><span class="keyword">long</span> preparedTransactionOffset;<span class="comment">//消息预处理事务偏移量</span></span><br><span class="line">Map&lt;String, String&gt; propertiesMap;<span class="comment">//消息属性</span></span><br><span class="line"><span class="keyword">byte</span>[] bitMap;<span class="comment">//位图</span></span><br></pre></td></tr></table></figure><h4 id="转发到ConsumerQueue"><a href="#转发到ConsumerQueue" class="headerlink" title="转发到ConsumerQueue"></a>转发到ConsumerQueue</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-fen-fa-dao-xiao-xi-xiao-fei-dui-lie.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">//消息分发</span></span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得消费队列</span></span><br><span class="line">    ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">    <span class="comment">//消费队列分发消息</span></span><br><span class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#putMessagePositionInfo</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依次将消息偏移量、消息长度、tag写入到ByteBuffer中</span></span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line"><span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"><span class="comment">//获得内存映射文件</span></span><br><span class="line">MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line"><span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//将消息追加到内存映射文件,异步输盘</span></span><br><span class="line">    <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转发到Index"><a href="#转发到Index" class="headerlink" title="转发到Index"></a>转发到Index</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-fen-fa-dao-suo-yin-wen-jian.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#buildIndex</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得索引文件</span></span><br><span class="line">    IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">    <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获得文件最大物理偏移量</span></span><br><span class="line">        <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">        DispatchRequest msg = req;</span><br><span class="line">        String topic = msg.getTopic();</span><br><span class="line">        String keys = msg.getKeys();</span><br><span class="line">        <span class="comment">//如果该消息的物理偏移量小于索引文件中的最大物理偏移量,则说明是重复数据,忽略本次索引构建</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果消息ID不为空,则添加到Hash索引中</span></span><br><span class="line">        <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey()));</span><br><span class="line">            <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//构建索引key,RocketMQ支持为同一个消息建立多个索引,多个索引键空格隔开.</span></span><br><span class="line">        <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] keyset = keys.split(MessageConst.KEY_SEPARATOR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">                String key = keyset[i];</span><br><span class="line">                <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line">                    <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">"build index error, stop building index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列和索引文件恢复"><a href="#消息队列和索引文件恢复" class="headerlink" title="消息队列和索引文件恢复"></a>消息队列和索引文件恢复</h3><p>由于RocketMQ存储首先将消息全量存储在CommitLog文件中，然后异步生成转发任务更新ConsumerQueue和Index文件。如果消息成功存储到CommitLog文件中，转发任务未成功执行，此时消息服务器Broker由于某个愿意宕机，导致CommitLog、ConsumerQueue、IndexFile文件数据不一致。如果不加以人工修复的话，会有一部分消息即便在CommitLog中文件中存在，但由于没有转发到ConsumerQueue，这部分消息将永远复发被消费者消费。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/wen-jian-hui-fu-zong-ti-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h4 id="存储文件加载"><a href="#存储文件加载" class="headerlink" title="存储文件加载"></a>存储文件加载</h4><p><strong><em>代码：DefaultMessageStore#load</em></strong></p><p>判断上一次是否异常退出。实现机制是Broker在启动时创建abort文件，在退出时通过JVM钩子函数删除abort文件。如果下次启动时存在abort文件。说明Broker时异常退出的，CommitLog与ConsumerQueue数据有可能不一致，需要进行修复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断临时文件是否存在</span></span><br><span class="line"><span class="keyword">boolean</span> lastExitOK = !<span class="keyword">this</span>.isTempFileExist();</span><br><span class="line"><span class="comment">//根据临时文件判断当前Broker是否异常退出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTempFileExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String fileName = StorePathConfigHelper</span><br><span class="line">        .getAbortFile(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir());</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">return</span> file.exists();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#load</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延时队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载CommitLog文件</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载消费队列文件</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line"><span class="comment">//加载存储监测点,监测点主要记录CommitLog文件、ConsumerQueue文件、Index索引文件的刷盘点</span></span><br><span class="line">    <span class="keyword">this</span>.storeCheckpoint =<span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line"><span class="comment">//加载index文件</span></span><br><span class="line">    <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line"><span class="comment">//根据Broker是否异常退出,执行不同的恢复策略</span></span><br><span class="line">    <span class="keyword">this</span>.recover(lastExitOK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MappedFileQueue#load</em></strong></p><p>加载CommitLog到映射文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指向CommitLog文件目录</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</span><br><span class="line"><span class="comment">//获得文件数组</span></span><br><span class="line">File[] files = dir.listFiles();</span><br><span class="line"><span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 文件排序</span></span><br><span class="line">    Arrays.sort(files);</span><br><span class="line">    <span class="comment">//遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line"><span class="comment">//如果文件大小和配置文件不一致,退出</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() != <span class="keyword">this</span>.mappedFileSize) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建映射文件</span></span><br><span class="line">            MappedFile mappedFile = <span class="keyword">new</span> MappedFile(file.getPath(), mappedFileSize);</span><br><span class="line">            mappedFile.setWrotePosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setFlushedPosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            mappedFile.setCommittedPosition(<span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            <span class="comment">//将映射文件添加到队列</span></span><br><span class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">            log.info(<span class="string">"load "</span> + file.getPath() + <span class="string">" OK"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"load file "</span> + file + <span class="string">" error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#loadConsumeQueue</em></strong></p><p>加载消息消费队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行消费队列目录</span></span><br><span class="line">File dirLogic = <span class="keyword">new</span> File(StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line"><span class="comment">//遍历消费队列目录</span></span><br><span class="line">File[] fileTopicList = dirLogic.listFiles();</span><br><span class="line"><span class="keyword">if</span> (fileTopicList != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File fileTopic : fileTopicList) &#123;</span><br><span class="line">        <span class="comment">//获得子目录名称,即topic名称</span></span><br><span class="line">        String topic = fileTopic.getName();</span><br><span class="line"><span class="comment">//遍历子目录下的消费队列文件</span></span><br><span class="line">        File[] fileQueueIdList = fileTopic.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (fileQueueIdList != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历文件</span></span><br><span class="line">            <span class="keyword">for</span> (File fileQueueId : fileQueueIdList) &#123;</span><br><span class="line">                <span class="comment">//文件名称即队列ID</span></span><br><span class="line">                <span class="keyword">int</span> queueId;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queueId = Integer.parseInt(fileQueueId.getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建消费队列并加载到内存</span></span><br><span class="line">                ConsumeQueue logic = <span class="keyword">new</span> ConsumeQueue(</span><br><span class="line">                    topic,</span><br><span class="line">                    queueId,</span><br><span class="line">                    StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class="line">            <span class="keyword">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),</span><br><span class="line">                    <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">this</span>.putConsumeQueue(topic, queueId, logic);</span><br><span class="line">                <span class="keyword">if</span> (!logic.load()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"load logics queue all over, OK"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p><strong><em>代码：IndexService#load</em></strong></p><p>加载索引文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引文件目录</span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="keyword">this</span>.storePath);</span><br><span class="line">    <span class="comment">//遍历索引文件</span></span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//文件排序</span></span><br><span class="line">        Arrays.sort(files);</span><br><span class="line">        <span class="comment">//遍历文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加载索引文件</span></span><br><span class="line">                IndexFile f = <span class="keyword">new</span> IndexFile(file.getPath(), <span class="keyword">this</span>.hashSlotNum, <span class="keyword">this</span>.indexNum, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                f.load();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!lastExitOK) &#123;</span><br><span class="line">                    <span class="comment">//索引文件上次的刷盘时间小于该索引文件的消息时间戳,该文件将立即删除</span></span><br><span class="line">                    <span class="keyword">if</span> (f.getEndTimestamp() &gt; <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint()</span><br><span class="line">                        .getIndexMsgTimestamp()) &#123;</span><br><span class="line">                        f.destroy(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//将索引文件添加到队列</span></span><br><span class="line">                log.info(<span class="string">"load index file OK, "</span> + f.getFileName());</span><br><span class="line">                <span class="keyword">this</span>.indexFileList.add(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                log.error(<span class="string">"load file &#123;&#125; error"</span>, file, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#recover</em></strong></p><p>文件恢复，根据Broker是否正常退出执行不同的恢复策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得最大的物理便宜消费队列</span></span><br><span class="line">    <span class="keyword">long</span> maxPhyOffsetOfConsumeQueue = <span class="keyword">this</span>.recoverConsumeQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</span><br><span class="line">        <span class="comment">//正常恢复</span></span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverNormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//异常恢复</span></span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverAbnormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//在CommitLog中保存每个消息消费队列当前的存储逻辑偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.recoverTopicQueueTable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#recoverTopicQueueTable</em></strong></p><p>恢复ConsumerQueue后，将在CommitLog实例中保存每隔消息队列当前的存储逻辑偏移量，这也是消息中不仅存储主题、消息队列ID、还存储了消息队列的关键所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTopicQueueTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String<span class="comment">/* topic-queueid */</span>, Long<span class="comment">/* offset */</span>&gt; table = <span class="keyword">new</span> HashMap&lt;String, Long&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//CommitLog最小偏移量</span></span><br><span class="line">    <span class="keyword">long</span> minPhyOffset = <span class="keyword">this</span>.commitLog.getMinOffset();</span><br><span class="line">    <span class="comment">//遍历消费队列,将消费队列保存在CommitLog中</span></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : <span class="keyword">this</span>.consumeQueueTable.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumeQueue logic : maps.values()) &#123;</span><br><span class="line">            String key = logic.getTopic() + <span class="string">"-"</span> + logic.getQueueId();</span><br><span class="line">            table.put(key, logic.getMaxOffsetInQueue());</span><br><span class="line">            logic.correctMinOffset(minPhyOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.commitLog.setTopicQueueTable(table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正常恢复"><a href="#正常恢复" class="headerlink" title="正常恢复"></a>正常恢复</h4><p><strong><em>代码：CommitLog#recoverNormally</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">(<span class="keyword">long</span> maxPhyOffsetOfConsumeQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">         <span class="comment">//Broker正常停止再重启时,从倒数第三个开始恢复,如果不足3个文件,则从第一个文件开始恢复。</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        MappedFile mappedFile = mappedFiles.get(index);</span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="comment">//代表当前已校验通过的offset</span></span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//查找消息</span></span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="comment">//消息长度</span></span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line">           <span class="comment">//查找结果为true,并且消息长度大于0,表示消息正确.mappedFileOffset向前移动本消息长度</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果查找结果为true且消息长度等于0,表示已到该文件末尾,如果还有下一个文件,则重置processOffset和MappedFileOffset重复查找下一个文件,否则跳出循环。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</span><br><span class="line">              index++;</span><br><span class="line">              <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</span><br><span class="line">                  <span class="comment">// Current branch can not happen</span></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//取出每个文件</span></span><br><span class="line">                  mappedFile = mappedFiles.get(index);</span><br><span class="line">                  byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                  processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                  mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                  </span><br><span class="line">          &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找结果为false，表明该文件未填满所有消息，跳出循环，结束循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//更新MappedFileQueue的flushedWhere和committedWhere指针</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="comment">//删除offset之后的所有文件</span></span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxPhyOffsetOfConsumeQueue &gt;= processOffset) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MappedFileQueue#truncateDirtyFiles</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateDirtyFiles</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    List&lt;MappedFile&gt; willRemoveFiles = <span class="keyword">new</span> ArrayList&lt;MappedFile&gt;();</span><br><span class="line"><span class="comment">//遍历目录下文件</span></span><br><span class="line">    <span class="keyword">for</span> (MappedFile file : <span class="keyword">this</span>.mappedFiles) &#123;</span><br><span class="line">        <span class="comment">//文件尾部的偏移量</span></span><br><span class="line">        <span class="keyword">long</span> fileTailOffset = file.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line">        <span class="comment">//文件尾部的偏移量大于offset</span></span><br><span class="line">        <span class="keyword">if</span> (fileTailOffset &gt; offset) &#123;</span><br><span class="line">            <span class="comment">//offset大于文件的起始偏移量</span></span><br><span class="line">            <span class="keyword">if</span> (offset &gt;= file.getFileFromOffset()) &#123;</span><br><span class="line">                <span class="comment">//更新wrotePosition、committedPosition、flushedPosistion</span></span><br><span class="line">                file.setWrotePosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">                file.setCommittedPosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">                file.setFlushedPosition((<span class="keyword">int</span>) (offset % <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//offset小于文件的起始偏移量,说明该文件是有效文件后面创建的,释放mappedFile占用内存,删除文件</span></span><br><span class="line">                file.destroy(<span class="number">1000</span>);</span><br><span class="line">                willRemoveFiles.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.deleteExpiredFile(willRemoveFiles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h4><p>Broker异常停止文件恢复的实现为CommitLog#recoverAbnormally。异常文件恢复步骤与正常停止文件恢复流程基本相同，其主要差别有两个。首先，正常停止默认从倒数第三个文件开始进行恢复，而异常停止则需要从最后一个文件往前走，找到第一个消息存储正常的文件。其次，如果CommitLog目录没有消息文件，如果消息消费队列目录下存在文件，则需要销毁。</p><p><strong><em>代码：CommitLog#recoverAbnormally</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// Looking beginning to recover from which file</span></span><br><span class="line">    <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">1</span>;</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">        <span class="comment">//判断消息文件是否是一个正确的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</span><br><span class="line">            log.info(<span class="string">"recover from this mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//根据索引取出mappedFile文件</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        mappedFile = mappedFiles.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...验证消息的合法性,并将消息转发到消息消费队列和索引文件</span></span><br><span class="line">       </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//未找到mappedFile,重置flushWhere、committedWhere都为0，销毁消息队列文件</span></span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="刷盘机制-1"><a href="#刷盘机制-1" class="headerlink" title="刷盘机制"></a>刷盘机制</h3><p>RocketMQ的存储是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘。</p><h4 id="同步刷盘-1"><a href="#同步刷盘-1" class="headerlink" title="同步刷盘"></a>同步刷盘</h4><p>消息追加到内存后，立即将数据刷写到磁盘文件</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/tong-bu-shua-pan-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：CommitLog#handleDiskFlush</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//刷盘服务</span></span><br><span class="line"><span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line"><span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">    <span class="comment">//封装刷盘请求</span></span><br><span class="line">    GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">    <span class="comment">//提交刷盘请求</span></span><br><span class="line">    service.putRequest(request);</span><br><span class="line">    <span class="comment">//线程阻塞5秒，等待刷盘结束</span></span><br><span class="line">    <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><em>GroupCommitRequest</em></strong></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/groupcommitrequest.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> nextOffset;<span class="comment">//刷盘点偏移量</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);<span class="comment">//倒计树锁存器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;<span class="comment">//刷盘结果;默认为false</span></span><br></pre></td></tr></table></figure><p><strong><em>代码：GroupCommitService#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//线程等待10ms</span></span><br><span class="line">            <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//执行提交</span></span><br><span class="line">            <span class="keyword">this</span>.doCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：GroupCommitService#doCommit</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//遍历requestsRead</span></span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line"><span class="comment">//刷盘</span></span><br><span class="line">                    <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                        CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//唤醒发送消息客户端</span></span><br><span class="line">                req.wakeupCustomer(flushOK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新刷盘监测点</span></span><br><span class="line">            <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;               CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步刷盘-1"><a href="#异步刷盘-1" class="headerlink" title="异步刷盘"></a>异步刷盘</h4><p>在消息追加到内存后，立即返回给消息发送端。如果开启transientStorePoolEnable，RocketMQ会单独申请一个与目标物理文件（commitLog）同样大小的堆外内存，该堆外内存将使用内存锁定，确保不会被置换到虚拟内存中去，消息首先追加到堆外内存，然后提交到物理文件的内存映射中，然后刷写到磁盘。如果未开启transientStorePoolEnable，消息直接追加到物理文件直接映射文件中，然后刷写到磁盘中。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/yi-bu-shua-pan-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>开启transientStorePoolEnable后异步刷盘步骤:</p><ol><li>将消息直接追加到ByteBuffer（堆外内存）</li><li>CommitRealTimeService线程每隔200ms将ByteBuffer新追加内容提交到MappedByteBuffer中</li><li>MappedByteBuffer在内存中追加提交的内容，wrotePosition指针向后移动</li><li>commit操作成功返回，将committedPosition位置恢复</li><li>FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</li></ol><p><strong><em>代码：CommitLog$CommitRealTimeService#run</em></strong></p><p>提交线程工作机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//间隔时间,默认200ms</span></span><br><span class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次提交的至少页数</span></span><br><span class="line"><span class="keyword">int</span> commitDataLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</span><br><span class="line"></span><br><span class="line"><span class="comment">//两次真实提交的最大间隔,默认200ms</span></span><br><span class="line"><span class="keyword">int</span> commitDataThoroughInterval =</span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交</span></span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= (<span class="keyword">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastCommitTimestamp = begin;</span><br><span class="line">    commitDataLeastPages = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行提交操作,将待提交数据提交到物理文件的内存映射区</span></span><br><span class="line"><span class="keyword">boolean</span> result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(commitDataLeastPages);</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></span><br><span class="line">    <span class="comment">//now wake up flush thread.</span></span><br><span class="line">    <span class="comment">//唤醒刷盘线程</span></span><br><span class="line">    flushCommitLogService.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</span><br><span class="line">    log.info(<span class="string">"Commit data to file costs &#123;&#125; ms"</span>, end - begin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.waitForRunning(interval);</span><br></pre></td></tr></table></figure><p><strong><em>代码：CommitLog$FlushRealTimeService#run</em></strong></p><p>刷盘线程工作机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示await方法等待,默认false</span></span><br><span class="line"><span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"><span class="comment">//线程执行时间间隔</span></span><br><span class="line"><span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line"><span class="comment">//一次刷写任务至少包含页数</span></span><br><span class="line"><span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line"><span class="comment">//两次真实刷写任务最大间隔</span></span><br><span class="line"><span class="keyword">int</span> flushPhysicQueueThoroughInterval =</span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//距离上次提交间隔超过flushPhysicQueueThoroughInterval,则本次刷盘任务将忽略flushPhysicQueueLeastPages,直接提交</span></span><br><span class="line"><span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">    flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">    printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行一次刷盘前,先等待指定时间间隔</span></span><br><span class="line"><span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">    Thread.sleep(interval);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//刷写磁盘</span></span><br><span class="line">CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line"><span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line"><span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//更新存储监测点文件的时间戳</span></span><br><span class="line">CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br></pre></td></tr></table></figure><h3 id="过期文件删除机制"><a href="#过期文件删除机制" class="headerlink" title="过期文件删除机制"></a>过期文件删除机制</h3><p>由于RocketMQ操作CommitLog、ConsumerQueue文件是基于内存映射机制并在启动的时候回加载CommitLog、ConsumerQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久存储在消息服务器上，所以要引入一种机制来删除已过期的文件。RocketMQ顺序写CommitLog、ConsumerQueue文件，所有写操作全部落在最后一个CommitLog或者ConsumerQueue文件上，之前的文件在下一个文件创建后将不会再被更新。RocketMQ清除过期文件的方法时：如果当前文件在在一定时间间隔内没有再次被消费，则认为是过期文件，可以被删除，RocketMQ不会关注这个文件上的消息是否全部被消费。默认每个文件的过期时间为72小时，通过在Broker配置文件中设置fileReservedTime来改变过期时间，单位为小时。</p><p><strong><em>代码：DefaultMessageStore#addScheduleTask</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addScheduleTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//每隔10s调度一次清除文件</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.cleanFilesPeriodically();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">60</span>, <span class="keyword">this</span>.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#cleanFilesPeriodically</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanFilesPeriodically</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清除存储文件</span></span><br><span class="line">    <span class="keyword">this</span>.cleanCommitLogService.run();</span><br><span class="line">    <span class="comment">//清除消息消费队列文件</span></span><br><span class="line">    <span class="keyword">this</span>.cleanConsumeQueueService.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#deleteExpiredFiles</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteExpiredFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除的数量</span></span><br><span class="line">    <span class="keyword">int</span> deleteCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//文件保留的时间</span></span><br><span class="line">    <span class="keyword">long</span> fileReservedTime = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getFileReservedTime();</span><br><span class="line">    <span class="comment">//删除物理文件的间隔</span></span><br><span class="line">    <span class="keyword">int</span> deletePhysicFilesInterval = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDeleteCommitLogFilesInterval();</span><br><span class="line">    <span class="comment">//线程被占用,第一次拒绝删除后能保留的最大时间,超过该时间,文件将被强制删除</span></span><br><span class="line">    <span class="keyword">int</span> destroyMapedFileIntervalForcibly = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> timeup = <span class="keyword">this</span>.isTimeToDelete();</span><br><span class="line"><span class="keyword">boolean</span> spacefull = <span class="keyword">this</span>.isSpaceToDelete();</span><br><span class="line"><span class="keyword">boolean</span> manualDelete = <span class="keyword">this</span>.manualDeleteFileSeveralTimes &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (timeup || spacefull || manualDelete) &#123;</span><br><span class="line">...执行删除逻辑</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...无作为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除文件操作的条件</p><ol><li>指定删除文件的时间点，RocketMQ通过deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认4点</li><li>磁盘空间如果不充足，删除过期文件</li><li>预留，手工触发。</li></ol><p><strong><em>代码：CleanCommitLogService#isSpaceToDelete</em></strong></p><p>当磁盘空间不足时执行删除过期文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpaceToDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//磁盘分区的最大使用量</span></span><br><span class="line">    <span class="keyword">double</span> ratio = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getDiskMaxUsedSpaceRatio() / <span class="number">100.0</span>;</span><br><span class="line"><span class="comment">//是否需要立即执行删除过期文件操作</span></span><br><span class="line">    cleanImmediately = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        String storePathPhysic = DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getStorePathCommitLog();</span><br><span class="line">        <span class="comment">//当前CommitLog目录所在的磁盘分区的磁盘使用率</span></span><br><span class="line">        <span class="keyword">double</span> physicRatio = UtilAll.getDiskPartitionSpaceUsedPercent(storePathPhysic);</span><br><span class="line">        <span class="comment">//diskSpaceWarningLevelRatio:磁盘使用率警告阈值,默认0.90</span></span><br><span class="line">        <span class="keyword">if</span> (physicRatio &gt; diskSpaceWarningLevelRatio) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskFull();</span><br><span class="line">            <span class="keyword">if</span> (diskok) &#123;</span><br><span class="line">                DefaultMessageStore.log.error(<span class="string">"physic disk maybe full soon "</span> + physicRatio + <span class="string">", so mark disk full"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//diskSpaceCleanForciblyRatio:强制清除阈值,默认0.85</span></span><br><span class="line">            cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (physicRatio &gt; diskSpaceCleanForciblyRatio) &#123;</span><br><span class="line">            cleanImmediately = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> diskok = DefaultMessageStore.<span class="keyword">this</span>.runningFlags.getAndMakeDiskOK();</span><br><span class="line">            <span class="keyword">if</span> (!diskok) &#123;</span><br><span class="line">            DefaultMessageStore.log.info(<span class="string">"physic disk space OK "</span> + physicRatio + <span class="string">", so mark disk ok"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (physicRatio &lt; <span class="number">0</span> || physicRatio &gt; ratio) &#123;</span><br><span class="line">        DefaultMessageStore.log.info(<span class="string">"physic disk maybe full soon, so reclaim space, "</span> + physicRatio);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MappedFileQueue#deleteExpiredFileByTime</em></strong></p><p>执行文件销毁和删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mfsLength; i++) &#123;</span><br><span class="line">    <span class="comment">//遍历每隔文件</span></span><br><span class="line">    MappedFile mappedFile = (MappedFile) mfs[i];</span><br><span class="line">    <span class="comment">//计算文件存活时间</span></span><br><span class="line">    <span class="keyword">long</span> liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime;</span><br><span class="line">    <span class="comment">//如果超过72小时,执行文件删除</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &gt;= liveMaxTimestamp || cleanImmediately) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappedFile.destroy(intervalForcibly)) &#123;</span><br><span class="line">            files.add(mappedFile);</span><br><span class="line">            deleteCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (files.size() &gt;= DELETE_FILES_BATCH_MAX) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (deleteFilesInterval &gt; <span class="number">0</span> &amp;&amp; (i + <span class="number">1</span>) &lt; mfsLength) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(deleteFilesInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//avoid deleting files in the middle</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>RocketMQ的存储文件包括消息文件（Commitlog）、消息消费队列文件（ConsumerQueue）、Hash索引文件（IndexFile）、监测点文件（checkPoint）、abort（关闭异常文件）。单个消息存储文件、消息消费队列文件、Hash索引文件长度固定以便使用内存映射机制进行文件的读写操作。RocketMQ组织文件以文件的起始偏移量来命令文件，这样根据偏移量能快速定位到真实的物理文件。RocketMQ基于内存映射文件机制提供了同步刷盘和异步刷盘两种机制，异步刷盘是指在消息存储时先追加到内存映射文件，然后启动专门的刷盘线程定时将内存中的文件数据刷写到磁盘。</p><p>CommitLog，消息存储文件，RocketMQ为了保证消息发送的高吞吐量，采用单一文件存储所有主题消息，保证消息存储是完全的顺序写，但这样给文件读取带来了不便，为此RocketMQ为了方便消息消费构建了消息消费队列文件，基于主题与队列进行组织，同时RocketMQ为消息实现了Hash索引，可以为消息设置索引键，根据所以能够快速从CommitLog文件中检索消息。</p><p>当消息达到CommitLog后，会通过ReputMessageService线程接近实时地将消息转发给消息消费队列文件与索引文件。为了安全起见，RocketMQ引入abort文件，记录Broker的停机是否是正常关闭还是异常关闭，在重启Broker时为了保证CommitLog文件，消息消费队列文件与Hash索引文件的正确性，分别采用不同策略来恢复文件。</p><p>RocketMQ不会永久存储消息文件、消息消费队列文件，而是启动文件过期机制并在磁盘空间不足或者默认凌晨4点删除过期文件，文件保存72小时并且在删除文件时并不会判断该消息文件上的消息是否被消费。</p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><h3 id="消息消费概述"><a href="#消息消费概述" class="headerlink" title="消息消费概述"></a>消息消费概述</h3><p>消息消费以组的模式开展，一个消费组内可以包含多个消费者，每一个消费者组可订阅多个主题，消费组之间有ff式和广播模式两种消费模式。集群模式，主题下的同一条消息只允许被其中一个消费者消费。广播模式，主题下的同一条消息，将被集群内的所有消费者消费一次。消息服务器与消费者之间的消息传递也有两种模式：推模式、拉模式。所谓的拉模式，是消费端主动拉起拉消息请求，而推模式是消息达到消息服务器后，推送给消息消费者。RocketMQ消息推模式的实现基于拉模式，在拉模式上包装一层，一个拉取任务完成后开始下一个拉取任务。</p><p>集群模式下，多个消费者如何对消息队列进行负载呢？消息队列负载机制遵循一个通用思想：一个消息队列同一个时间只允许被一个消费者消费，一个消费者可以消费多个消息队列。</p><p>RocketMQ支持局部顺序消息消费，也就是保证同一个消息队列上的消息顺序消费。不支持消息全局顺序消费，如果要实现某一个主题的全局顺序消费，可以将该主题的队列数设置为1，牺牲高可用性。</p><h3 id="消息消费初探"><a href="#消息消费初探" class="headerlink" title="消息消费初探"></a>消息消费初探</h3><p><strong><u>消息推送模式</u></strong></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-tui-song.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><strong><u>消息消费重要方法</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span>：发送消息确认</span></span><br><span class="line"><span class="function">Set&lt;MessageQueue&gt; <span class="title">fetchSubscribeMessageQueues</span><span class="params">(<span class="keyword">final</span> String topic)</span> :获取消费者对主题分配了那些消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerConcurrently messageListener)</span>：注册并发事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerMessageListener</span><span class="params">(<span class="keyword">final</span> MessageListenerOrderly messageListener)</span>：注册顺序消息事件监听器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String subExpression)</span>：基于主题订阅消息，消息过滤使用表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> String fullClassName,<span class="keyword">final</span> String filterClassSource)</span>：基于主题订阅消息，消息过滤使用类模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> MessageSelector selector)</span> ：订阅消息，并指定队列选择器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(<span class="keyword">final</span> String topic)</span>：取消消息订阅</span></span><br></pre></td></tr></table></figure><p><strong><u>DefaultMQPushConsumer</u></strong></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/defaultmqpushconsumer.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费者组</span></span><br><span class="line"><span class="keyword">private</span> String consumerGroup;</span><br><span class="line"><span class="comment">//消息消费模式</span></span><br><span class="line"><span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING;</span><br><span class="line"><span class="comment">//指定消费开始偏移量（最大偏移量、最小偏移量、启动时间戳）开始消费</span></span><br><span class="line"><span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"><span class="comment">//集群模式下的消息队列负载策略</span></span><br><span class="line"><span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br><span class="line"><span class="comment">//订阅信息</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">//消息业务监听器</span></span><br><span class="line"><span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line"><span class="comment">//消息消费进度存储器</span></span><br><span class="line"><span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line"><span class="comment">//消费者最小线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//消费者最大线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//并发消息消费时处理队列最大跨度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</span><br><span class="line"><span class="comment">//每1000次流控后打印流控日志</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//推模式下任务间隔时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//推模式下任务拉取的条数,默认32条</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>;</span><br><span class="line"><span class="comment">//每次传入MessageListener#consumerMessage中消息的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//是否每次拉取消息都订阅消息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//消息重试次数,-1代表16次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//消息消费超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h3 id="消费者启动流程"><a href="#消费者启动流程" class="headerlink" title="消费者启动流程"></a>消费者启动流程</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-xiao-fei-qi-dong-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：DefaultMQPushConsumerImpl#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"><span class="comment">//检查消息者是否合法</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="comment">//构建主题订阅信息</span></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line"><span class="comment">//设置消费者客户端实例名称为进程ID</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//创建MQClient实例</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"><span class="comment">//构建rebalanceImpl</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactor</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                mQClientFactory,</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookLis</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">case</span> BROADCASTING: <span class="comment">//消息消费广播模式,将消费进度保存在本地</span></span><br><span class="line">                   <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> CLUSTERING:<span class="comment">//消息消费集群模式,将消费进度保存在远端Broker</span></span><br><span class="line">                       <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">this</span>.offsetStore.load</span><br><span class="line">            <span class="comment">//创建顺序消息消费服务</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                <span class="comment">//创建并发消息消费服务</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                    <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息消费服务启动</span></span><br><span class="line">            <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line">            <span class="comment">//注册消费者实例</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//启动消费者客户端</span></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h3><p>消息消费模式有两种模式：广播模式与集群模式。广播模式比较简单，每一个消费者需要拉取订阅主题下所有队列的消息。本文重点讲解集群模式。在集群模式下，同一个消费者组内有多个消息消费者，同一个主题存在多个消费队列，消费者通过负载均衡的方式消费消息。</p><p>消息队列负载均衡，通常的作法是一个消息队列在同一个时间只允许被一个消费消费者消费，一个消息消费者可以同时消费多个消息队列。</p><h4 id="PullMessageService实现机制"><a href="#PullMessageService实现机制" class="headerlink" title="PullMessageService实现机制"></a>PullMessageService实现机制</h4><p>从MQClientInstance的启动流程中可以看出，RocketMQ使用一个单独的线程PullMessageService来负责消息的拉取。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/pullmessageservice-shi-xian-ji-zhi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：PullMessageService#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"><span class="comment">//循环拉取消息</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从请求队列中获取拉取消息请求</span></span><br><span class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="comment">//拉取消息</span></span><br><span class="line">            <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><strong>PullRequest</strong></u></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/pullrequest.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String consumerGroup;<span class="comment">//消费者组</span></span><br><span class="line"><span class="keyword">private</span> MessageQueue messageQueue;<span class="comment">//待拉取消息队列</span></span><br><span class="line"><span class="keyword">private</span> ProcessQueue processQueue;<span class="comment">//消息处理队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextOffset;<span class="comment">//待拉取的MessageQueue偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;<span class="comment">//是否被锁定</span></span><br></pre></td></tr></table></figure><p><strong><em>代码：PullMessageService#pullMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得消费者实例</span></span><br><span class="line">    <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//强转为推送模式消费者</span></span><br><span class="line">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        <span class="comment">//推送消息</span></span><br><span class="line">        impl.pullMessage(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">"No matched consumer for the PullRequest &#123;&#125;, drop it"</span>, pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProcessQueue实现机制"><a href="#ProcessQueue实现机制" class="headerlink" title="ProcessQueue实现机制"></a>ProcessQueue实现机制</h4><p>ProcessQueue是MessageQueue在消费端的重现、快照。PullMessageService从消息服务器默认每次拉取32条消息，按照消息的队列偏移量顺序存放在ProcessQueue中，PullMessageService然后将消息提交到消费者消费线程池，消息成功消费后从ProcessQueue中移除。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/processqueue.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><strong><u>属性</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息容器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//ProcessQueue总消息树</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicLong msgCount = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"><span class="comment">//ProcessQueue队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> queueOffsetMax = <span class="number">0L</span>;</span><br><span class="line"><span class="comment">//当前ProcessQueue是否被丢弃</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dropped = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//上一次拉取时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPullTimestamp = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//上一次消费时间戳</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastConsumeTimestamp = System.currentTimeMillis();</span><br></pre></td></tr></table></figure><p><strong><u>方法</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除消费超时消息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanExpiredMsg</span><span class="params">(DefaultMQPushConsumer pushConsumer)</span></span></span><br><span class="line"><span class="function"><span class="comment">//添加消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取消息最大间隔</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxSpan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//移除消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap中消息重新放在msgTreeMap,并清空consumingMsgOrderlyTreeMap   </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将consumingMsgOrderlyTreeMap消息清除,表示成功处理该批消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//重新处理该批消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMessageToCosumeAgain</span><span class="params">(List&lt;MessageExt&gt; msgs)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//从processQueue中取出batchSize条消息</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title">takeMessags</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> batchSize)</span></span></span><br></pre></td></tr></table></figure><h4 id="消息拉取基本流程"><a href="#消息拉取基本流程" class="headerlink" title="消息拉取基本流程"></a>消息拉取基本流程</h4><h5 id="客户端发起拉取请求"><a href="#客户端发起拉取请求" class="headerlink" title="客户端发起拉取请求"></a>客户端发起拉取请求</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-la-qu-ji-ben-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：DefaultMQPushConsumerImpl#pullMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从pullRequest获得ProcessQueue</span></span><br><span class="line">    <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">    <span class="comment">//如果处理队列被丢弃,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">        log.info(<span class="string">"the pull request[&#123;&#125;] is dropped."</span>, pullRequest.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果处理队列未被丢弃,更新时间戳</span></span><br><span class="line">    pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"pullMessage exception, consumer state not ok"</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果处理队列被挂起,延迟1s后再执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">        log.warn(<span class="string">"consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得最大待处理消息数量</span></span><br><span class="line"><span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">    <span class="comment">//获得最大待处理消息大小</span></span><br><span class="line"><span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="comment">//从数量进行流控</span></span><br><span class="line"><span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">            <span class="string">"the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从消息大小进行流控</span></span><br><span class="line"><span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">            <span class="string">"the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;"</span>,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得订阅信息</span></span><br><span class="line"> <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        log.warn(<span class="string">"find the consumer's subscription failed, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//与服务端交互,获取消息</span></span><br><span class="line">    <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    subExpression,</span><br><span class="line">    subscriptionData.getExpressionType(),</span><br><span class="line">    subscriptionData.getSubVersion(),</span><br><span class="line">    pullRequest.getNextOffset(),</span><br><span class="line">    <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">    sysFlag,</span><br><span class="line">    commitOffsetValue,</span><br><span class="line">    BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">    CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">    CommunicationMode.ASYNC,</span><br><span class="line">    pullCallback</span><br><span class="line">);</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息服务端Broker组装消息"><a href="#消息服务端Broker组装消息" class="headerlink" title="消息服务端Broker组装消息"></a>消息服务端Broker组装消息</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-fu-wu-duanbroker-zu-zhuang-xiao-xi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息过滤器</span></span><br><span class="line">MessageFilter messageFilter;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">    messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用MessageStore.getMessage查找消息</span></span><br><span class="line"><span class="keyword">final</span> GetMessageResult getMessageResult =</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(</span><br><span class="line">    requestHeader.getConsumerGroup(), <span class="comment">//消费组名称</span></span><br><span class="line">    requestHeader.getTopic(),<span class="comment">//主题名称</span></span><br><span class="line">        requestHeader.getQueueId(), <span class="comment">//队列ID</span></span><br><span class="line">    requestHeader.getQueueOffset(), <span class="comment">//待拉取偏移量</span></span><br><span class="line">    requestHeader.getMaxMsgNums(), <span class="comment">//最大拉取消息条数</span></span><br><span class="line">    messageFilter<span class="comment">//消息过滤器</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore#getMessage</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line"><span class="keyword">long</span> nextBeginOffset = offset;<span class="comment">//查找下一次队列偏移量</span></span><br><span class="line"><span class="keyword">long</span> minOffset = <span class="number">0</span>;<span class="comment">//当前消息队列最小偏移量</span></span><br><span class="line"><span class="keyword">long</span> maxOffset = <span class="number">0</span>;<span class="comment">//当前消息队列最大偏移量</span></span><br><span class="line">GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();<span class="comment">//当前commitLog最大偏移量</span></span><br><span class="line"><span class="comment">//根据主题名称和队列编号获取消息消费队列</span></span><br><span class="line">ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line"><span class="comment">//消息偏移量异常情况校对下一次拉取偏移量</span></span><br><span class="line"><span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;<span class="comment">//表示当前消息队列中没有消息</span></span><br><span class="line">    status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;<span class="comment">//待拉取消息的偏移量小于队列的其实偏移量</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;<span class="comment">//待拉取偏移量为队列最大偏移量</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">    nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;<span class="comment">//偏移量越界</span></span><br><span class="line">    status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从CommitLog中拉取32条消息</span></span><br><span class="line">SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br></pre></td></tr></table></figure><p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据拉取结果填充responseHeader</span></span><br><span class="line">response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断如果存在主从同步慢,设置下一次拉取任务的ID为主节点</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">    <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SLAVE:</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//GetMessageResult与Response的Code转换</span></span><br><span class="line"><span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">    <span class="keyword">case</span> FOUND:<span class="comment">//成功</span></span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MESSAGE_WAS_REMOVING:<span class="comment">//消息存放在下一个commitLog中</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);<span class="comment">//消息重试</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:<span class="comment">//未找到队列</span></span><br><span class="line">    <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:<span class="comment">//队列中未包含消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">            requestHeader.getQueueOffset(),</span><br><span class="line">            getMessageResult.getNextBeginOffset(),</span><br><span class="line">            requestHeader.getTopic(),</span><br><span class="line">            requestHeader.getQueueId(),</span><br><span class="line">            requestHeader.getConsumerGroup()</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> NO_MATCHED_MESSAGE:<span class="comment">//未找到消息</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_FOUND_NULL:<span class="comment">//消息物理偏移量为空</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:<span class="comment">//offset越界</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">        <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">        log.info(<span class="string">"the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;"</span>,</span><br><span class="line">                requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:<span class="comment">//offset在队列中未找到</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> OFFSET_TOO_SMALL:<span class="comment">//offset未在队列中</span></span><br><span class="line">        response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">        requestHeader.getConsumerGroup(), </span><br><span class="line">        requestHeader.getTopic(), </span><br><span class="line">        requestHeader.getQueueOffset(),</span><br><span class="line">        getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果CommitLog标记可用,并且当前Broker为主节点,则更新消息消费进度</span></span><br><span class="line"><span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">storeOffsetEnable = storeOffsetEnable</span><br><span class="line">    &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line"><span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">    <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">        requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息拉取客户端处理消息"><a href="#消息拉取客户端处理消息" class="headerlink" title="消息拉取客户端处理消息"></a>消息拉取客户端处理消息</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-la-qu-ke-hu-duan-chu-li-xiao-xi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><em>代码：MQClientAPIImpl#processPullResponse</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">processPullResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemotingCommand response)</span> <span class="keyword">throws</span> MQBrokerException, RemotingCommandException </span>&#123;</span><br><span class="line">    PullStatus pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">   <span class="comment">//判断响应结果</span></span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">            pullStatus = PullStatus.FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">            pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">            pullStatus = PullStatus.NO_MATCHED_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">            pullStatus = PullStatus.OFFSET_ILLEGAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//解码响应头</span></span><br><span class="line">    PullMessageResponseHeader responseHeader =</span><br><span class="line">        (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);</span><br><span class="line"><span class="comment">//封装PullResultExt返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),</span><br><span class="line">        responseHeader.getMaxOffset(), <span class="keyword">null</span>, responseHeader.getSuggestWhichBrokerId(), response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><strong>PullResult类</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PullStatus pullStatus;<span class="comment">//拉取结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> nextBeginOffset;<span class="comment">//下次拉取偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> minOffset;<span class="comment">//消息队列最小偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxOffset;<span class="comment">//消息队列最大偏移量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageExt&gt; msgFoundList;<span class="comment">//拉取的消息列表</span></span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/pullstatus.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><strong><em>代码：DefaultMQPushConsumerImpl$PullCallback#OnSuccess</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取到的消息存入processQueue</span></span><br><span class="line"><span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line"><span class="comment">//将processQueue提交到consumeMessageService中供消费者消费</span></span><br><span class="line">DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">    pullResult.getMsgFoundList(),</span><br><span class="line">    processQueue,</span><br><span class="line">    pullRequest.getMessageQueue(),</span><br><span class="line">    dispatchToConsume);</span><br><span class="line"><span class="comment">//如果pullInterval大于0,则等待pullInterval毫秒后将pullRequest对象放入到PullMessageService中的pullRequestQueue队列中</span></span><br><span class="line"><span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="消息拉取总结"><a href="#消息拉取总结" class="headerlink" title="消息拉取总结"></a>消息拉取总结</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-xi-la-qu-liu-cheng-zong-jie.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h4 id="消息拉取长轮询机制分析"><a href="#消息拉取长轮询机制分析" class="headerlink" title="消息拉取长轮询机制分析"></a>消息拉取长轮询机制分析</h4><p>RocketMQ未真正实现消息推模式，而是消费者主动向消息服务器拉取消息，RocketMQ推模式是循环向消息服务端发起消息拉取请求，如果消息消费者向RocketMQ拉取消息时，消息未到达消费队列时，如果不启用长轮询机制，则会在服务端等待shortPollingTimeMills时间后（挂起）再去判断消息是否已经到达指定消息队列，如果消息仍未到达则提示拉取消息客户端PULL—NOT—FOUND（消息不存在）；如果开启长轮询模式，RocketMQ一方面会每隔5s轮询检查一次消息是否可达，同时一有消息达到后立马通知挂起线程再次验证消息是否是自己感兴趣的消息，如果是则从CommitLog文件中提取消息返回给消息拉取客户端，否则直到挂起超时，超时时间由消息拉取方在消息拉取是封装在请求参数中，PUSH模式为15s，PULL模式通过DefaultMQPullConsumer#setBrokerSuspendMaxTimeMillis设置。RocketMQ通过在Broker客户端配置longPollingEnable为true来开启长轮询模式。</p><p><strong><em>代码：PullMessageProcessor#processRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当没有拉取到消息时，通过长轮询方式继续拉取消息</span></span><br><span class="line"><span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">    <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">        <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">            pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String topic = requestHeader.getTopic();</span><br><span class="line">        <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">        <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">        <span class="comment">//构建拉取请求对象</span></span><br><span class="line">        PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">        <span class="comment">//处理拉取请求</span></span><br><span class="line">        <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">        response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><u>PullRequestHoldService方式实现长轮询</u></strong></p><p><strong><em>代码：PullRequestHoldService#suspendPullRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将拉取消息请求，放置在ManyPullRequest集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspendPullRequest</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">    ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mpr) &#123;</span><br><span class="line">        mpr = <span class="keyword">new</span> ManyPullRequest();</span><br><span class="line">        ManyPullRequest prev = <span class="keyword">this</span>.pullRequestTable.putIfAbsent(key, mpr);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mpr = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mpr.addPullRequest(pullRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：PullRequestHoldService#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果开启长轮询每隔5秒判断消息是否到达</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有开启长轮询,每隔1s再次尝试</span></span><br><span class="line">              <span class="keyword">this</span>.waitForRunning(<span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">            <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">            <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：PullRequestHoldService#checkHoldRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历拉取任务</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">        String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">            String topic = kArray[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//获得消息偏移量</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通知有消息达到</span></span><br><span class="line">                <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：PullRequestHoldService#notifyMessageArriving</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果拉取消息偏移大于请求偏移量,如果消息匹配调用executeRequestWhenWakeup处理消息</span></span><br><span class="line"><span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">        <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">    <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">    <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                request.getRequestCommand());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果过期时间超时,则不继续等待将直接返回给客户端消息未找到</span></span><br><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">            request.getRequestCommand());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启了长轮询机制，PullRequestHoldService会每隔5s被唤醒去尝试检测是否有新的消息的到来才给客户端响应，或者直到超时才给客户端进行响应，消息实时性比较差，为了避免这种情况，RocketMQ引入另外一种机制：当消息到达时唤醒挂起线程触发一次检查。</p><p><strong><u>DefaultMessageStore$ReputMessageService机制</u></strong></p><p><strong><em>代码：DefaultMessageStore#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长轮询入口</span></span><br><span class="line"><span class="keyword">this</span>.reputMessageService.setReputFromOffset(maxPhysicalPosInLogicQueue);</span><br><span class="line"><span class="keyword">this</span>.reputMessageService.start();</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore$ReputMessageService#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//长轮询核心逻辑代码入口</span></span><br><span class="line">            <span class="keyword">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：DefaultMessageStore$ReputMessageService#deReput</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当新消息达到是,进行通知监听器进行处理</span></span><br><span class="line"><span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">    &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">    DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">        dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">        dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">        dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：NotifyMessageArrivingListener#arriving</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arriving</span><span class="params">(String topic, <span class="keyword">int</span> queueId, <span class="keyword">long</span> logicOffset, <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode,</span><br><span class="line">        msgStoreTime, filterBitMap, properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息队列负载与重新分布机制"><a href="#消息队列负载与重新分布机制" class="headerlink" title="消息队列负载与重新分布机制"></a>消息队列负载与重新分布机制</h3><p>RocketMQ消息队列重新分配是由RebalanceService线程来实现。一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p><p><strong><em>代码：RebalanceService#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"><span class="comment">//RebalanceService线程默认每隔20s执行一次mqClientFactory.doRebalance方法</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">        <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：MQClientInstance#doRebalance</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//MQClientInstance遍历以注册的消费者,对消费者执行doRebalance()方法</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">        MQConsumerInner impl = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                impl.doRebalance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：RebalanceImpl#doRebalance</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历订阅消息对每个主题的订阅的队列进行重新负载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">    <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"rebalanceByTopic Exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：RebalanceImpl#rebalanceByTopic</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从主题订阅消息缓存表中获取主题的队列信息</span></span><br><span class="line">Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line"><span class="comment">//查找该主题订阅组所有的消费者ID</span></span><br><span class="line">List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给消费者重新分配队列</span></span><br><span class="line"><span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">    mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">    Collections.sort(mqAll);</span><br><span class="line">    Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">    AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">    List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">            e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>RocketMQ默认提供5中负载均衡分配算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AllocateMessageQueueAveragely:平均分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q2,q3</span><br><span class="line">c2:q4,q5,a6</span><br><span class="line">c3:q7,q8</span><br><span class="line">AllocateMessageQueueAveragelyByCircle:平均轮询分配</span><br><span class="line">举例:<span class="number">8</span>个队列q1,q2,q3,q4,q5,a6,q7,q8,消费者<span class="number">3</span>个:c1,c2,c3</span><br><span class="line">分配如下:</span><br><span class="line">c1:q1,q4,q7</span><br><span class="line">c2:q2,q5,a8</span><br><span class="line">c3:q3,q6</span><br></pre></td></tr></table></figure><p>注意：消息队列的分配遵循一个消费者可以分配到多个队列，但同一个消息队列只会分配给一个消费者，故如果出现消费者个数大于消息队列数量，则有些消费者无法消费消息。</p><h3 id="消息消费过程"><a href="#消息消费过程" class="headerlink" title="消息消费过程"></a>消息消费过程</h3><p>PullMessageService负责对消息队列进行消息拉取，从远端服务器拉取消息后将消息存储ProcessQueue消息队列处理队列中，然后调用ConsumeMessageService#submitConsumeRequest方法进行消息消费，使用线程池来消费消息，确保了消息拉取与消息消费的解耦。ConsumeMessageService支持顺序消息和并发消息，核心类图如下：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/consumemessageservice.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><strong><u>并发消息消费</u></strong></p><p><strong><em>代码：ConsumeMessageConcurrentlyService#submitConsumeRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息批次单次</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"><span class="comment">//msgs.size()默认最多为32条。</span></span><br><span class="line"><span class="comment">//如果msgs.size()小于consumeBatchSize,则直接将拉取到的消息放入到consumeRequest,然后将consumeRequest提交到消费者线程池中</span></span><br><span class="line"><span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">    ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果拉取的消息条数大于consumeBatchSize,则对拉取消息进行分页</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">       List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">               msgThis.add(msgs.get(total));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">       ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">           <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">               msgThis.add(msgs.get(total));</span><br><span class="line">    </span><br><span class="line">           <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：ConsumeMessageConcurrentlyService$ConsumeRequest#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查processQueue的dropped,如果为true,则停止该队列消费。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//执行消息处理的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">    consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace());</span><br><span class="line">    consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">    consumeMessageContext.setMq(messageQueue);</span><br><span class="line">    consumeMessageContext.setMsgList(msgs);</span><br><span class="line">    consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//调用应用程序消息监听器的consumeMessage方法,进入到具体的消息消费业务处理逻辑</span></span><br><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行消息处理后的钩子函数</span></span><br><span class="line"><span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">    consumeMessageContext.setStatus(status.toString());</span><br><span class="line">    consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定时消息机制"><a href="#定时消息机制" class="headerlink" title="定时消息机制"></a>定时消息机制</h3><p>定时消息是消息发送到Broker后，并不立即被消费者消费而是要等到特定的时间后才能被消费，RocketMQ并不支持任意的时间精度，如果要支持任意时间精度定时调度，不可避免地需要在Broker层做消息排序，再加上持久化方面的考量，将不可避免的带来巨大的性能消耗，所以RocketMQ只支持特定级别的延迟消息。消息延迟级别在Broker端通过messageDelayLevel配置，默认为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，delayLevel=1表示延迟消息1s,delayLevel=2表示延迟5s,依次类推。</p><p>RocketMQ定时消息实现类为ScheduleMessageService，该类在DefaultMessageStore中创建。通过在DefaultMessageStore中调用load方法加载该类并调用start方法启动。</p><p><strong><em>代码：ScheduleMessageService#load</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载延迟消息消费进度的加载与delayLevelTable的构造。延迟消息的进度默认存储路径为/store/config/delayOffset.json</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.parseDelayLevel();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：ScheduleMessageService#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历延迟队列创建定时任务,遍历延迟级别，根据延迟级别level从offsetTable中获取消费队列的消费进度。如果不存在，则使用0</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">    Integer level = entry.getKey();</span><br><span class="line">    Long timeDelay = entry.getValue();</span><br><span class="line">    Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">        offset = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每隔10s持久化一次延迟队列的消息消费进度</span></span><br><span class="line"><span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (started.get()) ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br></pre></td></tr></table></figure><p><strong><u>调度机制</u></strong></p><p>ScheduleMessageService的start方法启动后，会为每一个延迟级别创建一个调度任务，每一个延迟级别对应SCHEDULE_TOPIC_XXXX主题下的一个消息消费队列。定时调度任务的实现类为DeliverDelayedMessageTimerTask，核心实现方法为executeOnTimeup</p><p><strong><em>代码：ScheduleMessageService$DeliverDelayedMessageTimerTask#executeOnTimeup</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据队列ID与延迟主题查找消息消费队列</span></span><br><span class="line">ConsumeQueue cq =</span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">        delayLevel2QueueId(delayLevel));</span><br><span class="line">...</span><br><span class="line"><span class="comment">//根据偏移量从消息消费队列中获取当前队列中所有有效的消息</span></span><br><span class="line">SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//遍历ConsumeQueue,解析消息队列中消息</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//can't find ext content.So re compute tags code.</span></span><br><span class="line">            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</span><br><span class="line">                tagsCode, offsetPy, sizePy);</span><br><span class="line">            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//根据消息偏移量与消息大小,从CommitLog中查找消息.</span></span><br><span class="line">  MessageExt msgExt =</span><br><span class="line">   ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">       offsetPy, sizePy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>顺序消息实现类是org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService</p><p><strong><em>代码：ConsumeMessageOrderlyService#start</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果消息模式为集群模式，启动定时任务，默认每隔20s执行一次锁定分配给自己的消息消费队列</span></span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())) &#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.lockMQPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">1</span>, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：ConsumeMessageOrderlyService#submitConsumeRequest</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建消息任务,并提交消费线程池中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ProcessQueue processQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> MessageQueue messageQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> dispathToConsume)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dispathToConsume) &#123;</span><br><span class="line">        ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(processQueue, messageQueue);</span><br><span class="line">        <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：ConsumeMessageOrderlyService$ConsumeRequest#run</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果消息队列为丢弃,则停止本次消费任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.warn(<span class="string">"run, the message queue not be able to consume, because it's dropped. &#123;&#125;"</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从消息队列中获取一个对象。然后消费消息时先申请独占objLock锁。顺序消息一个消息消费队列同一时刻只会被一个消费线程池处理</span></span><br><span class="line"><span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"><span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>RocketMQ消息消费方式分别为集群模式、广播模式。</p><p>消息队列负载由RebalanceService线程默认每隔20s进行一次消息队列负载，根据当前消费者组内消费者个数与主题队列数量按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消费队列，同一个消息消费队列同一个时间只会分配给一个消费者。</p><p>消息拉取由PullMessageService线程根据RebalanceService线程创建的拉取任务进行拉取，默认每次拉取32条消息，提交给消费者消费线程后继续下一次消息拉取。如果消息消费过慢产生消息堆积会触发消息消费拉取流控。 </p><p>并发消息消费指消费线程池中的线程可以并发对同一个消息队列的消息进行消费，消费成功后，取出消息队列中最小的消息偏移量作为消息消费进度偏移量存储在于消息消费进度存储文件中，集群模式消息消费进度存储在Broker（消息服务器），广播模式消息消费进度存储在消费者端。</p><p>RocketMQ不支持任意精度的定时调度消息，只支持自定义的消息延迟级别，例如1s、2s、5s等，可通过在broker配置文件中设置messageDelayLevel。</p><p>顺序消息一般使用集群模式，是指对消息消费者内的线程池中的线程对消息消费队列只能串行消费。并并发消息消费最本质的区别是消息消费时必须成功锁定消息消费队列，在Broker端会存储消息消费队列的锁占用情况。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 02 - 案例介绍</title>
      <link href="RocketMQ/middleware/rocketmq-02/"/>
      <url>RocketMQ/middleware/rocketmq-02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：本文档由《黑马程序员》整理，本人只是为了方便才整理到自己博客！！<br>相应视频资料：<a href="https://www.bilibili.com/video/BV1L4411y7mn?from=search&amp;seid=10733892066736275631" target="_blank" rel="noopener">RocketMQ系统精讲</a></p></blockquote><h1 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h1><h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h2><p>模拟电商网站购物场景中的【下单】和【支付】业务</p><a id="more"></a><h3 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xia-dan-zu-jian-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="500" alt title></p><ol><li>用户请求订单系统下单</li><li>订单系统通过RPC调用订单服务下单</li><li>订单服务调用优惠券服务，扣减优惠券</li><li>订单服务调用调用库存服务，校验并扣减库存</li><li>订单服务调用用户服务，扣减用户余额</li><li>订单服务完成确认订单</li></ol><hr><h3 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/zhi-fu-zu-jian-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="500" alt title></p><ol><li>用户请求支付系统</li><li>支付系统调用第三方支付平台API进行发起支付流程</li><li>用户通过第三方支付平台支付成功后，第三方支付平台回调通知支付系统</li><li>支付系统调用订单服务修改订单状态</li><li>支付系统调用积分服务添加积分</li><li>支付系统调用日志服务记录日志</li></ol><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>用户提交订单后，扣减库存成功、扣减优惠券成功、使用余额成功，但是在确认订单操作失败，需要对库存、库存、余额进行回退。</p><p>如何保证数据的完整性？</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xia-dan-shi-bai-liu-cheng-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p><p><u>使用MQ保证在下单失败后系统数据的完整性</u></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xia-dan-shi-xu-tu-2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>用户通过第三方支付平台（支付宝、微信）支付成功后，第三方支付平台要通过回调API异步通知商家支付系统用户支付结果，支付系统根据支付结果修改订单状态、记录支付日志和给用户增加积分。</p><p>商家支付系统如何保证在收到第三方支付平台的异步通知时，如何快速给第三方支付凭条做出回应？</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/zhi-fu-liu-cheng.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p><u>通过MQ进行数据分发，提高系统处理性能</u></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/zhi-fu-cheng-gong-shu-ju-fen-fa-liu-cheng-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h1 id="技术分析"><a href="#技术分析" class="headerlink" title="技术分析"></a>技术分析</h1><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>SpringBoot</li><li>Dubbo</li><li>Zookeeper</li><li>RocketMQ</li><li>Mysql</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiang-mu-jie-gou-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="SpringBoot整合RocketMQ"><a href="#SpringBoot整合RocketMQ" class="headerlink" title="SpringBoot整合RocketMQ"></a>SpringBoot整合RocketMQ</h2><p>下载<a href="https://github.com/apache/rocketmq-spring.git" target="_blank" rel="noopener">rocketmq-spring</a>项目</p><p>将rocketmq-spring安装到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install -Dmaven.skip.test=true</span><br></pre></td></tr></table></figure><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rocketmq-spring-boot-starter-version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">rocketmq-spring-boot-starter-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;rocketmq-spring-boot-starter-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">rocketmq.name-server=192.168.25.135:9876;192.168.25.138:9876</span><br><span class="line">rocketmq.producer.group=my-group</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQProducerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MQSpringBootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = &#123;MQSpringBootApplication.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rocketMQTemplate.convertAndSend(<span class="string">"springboot-mq"</span>,<span class="string">"hello springboot rocketmq"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>同消息生产者</p><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>同消息生产者</p><h4 id="启动类-1"><a href="#启动类-1" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MQConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MQSpringBootApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息监听器"><a href="#消息监听器" class="headerlink" title="消息监听器"></a>消息监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"springboot-mq"</span>,consumerGroup = <span class="string">"springboot-mq-consumer-1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Receive message："</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot整合Dubbo"><a href="#SpringBoot整合Dubbo" class="headerlink" title="SpringBoot整合Dubbo"></a>SpringBoot整合Dubbo</h2><p>下载<a href="https://github.com/alibaba/dubbo-spring-boot-starter.git" target="_blank" rel="noopener">dubbo-spring-boot-starter</a>依赖包</p><p>将<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```shell</span><br><span class="line">mvn install -Dmaven.skip.test=true</span><br></pre></td></tr></table></figure></p><p><img src="../%E6%96%87%E6%A1%A3/img/dubbo.png" alt></p><h3 id="搭建Zookeeper集群"><a href="#搭建Zookeeper集群" class="headerlink" title="搭建Zookeeper集群"></a>搭建Zookeeper集群</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>安装JDK</li><li>将Zookeeper上传到服务器</li><li>解压Zookeeper，并创建data目录，将conf下的zoo_sample.cfg文件改名为zoo.cfg</li><li><p>建立<code>/user/local/zookeeper-cluster</code>,将解压后的Zookeeper复制到以下三个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper-cluster/zookeeper-1</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-2</span><br><span class="line">/usr/local/zookeeper-cluster/zookeeper-3</span><br></pre></td></tr></table></figure></li><li><p>配置每一个 Zookeeper 的 dataDir（zoo.cfg） clientPort 分别为 2181 2182 2183</p><p>修改<code>/usr/local/zookeeper-cluster/zookeeper-1/conf/zoo.cfg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-1/data</span><br></pre></td></tr></table></figure><p> 修改/usr/local/zookeeper-cluster/zookeeper-2/conf/zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clientPort=2182</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-2/data</span><br></pre></td></tr></table></figure><p> 修改/usr/local/zookeeper-cluster/zookeeper-3/conf/zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clientPort=2183</span><br><span class="line">dataDir=/usr/local/zookeeper-cluster/zookeeper-3/data</span><br></pre></td></tr></table></figure></li></ol><h4 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h4><ol><li><p>在每个 zookeeper 的 data 目录下创建一个 myid 文件，内容分别是 1、2、3 。这个文件就是记录每个服务器的 ID</p></li><li><p>在每一个 zookeeper 的 zoo.cfg 配置客户端访问端口（clientPort）和集群服务器 IP 列表。</p><p>集群服务器 IP 列表如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.25.140:2881:3881</span><br><span class="line">server.2=192.168.25.140:2882:3882</span><br><span class="line">server.3=192.168.25.140:2883:3883</span><br></pre></td></tr></table></figure></li></ol><p>解释：server.服务器 ID=服务器 IP 地址：服务器之间通信端口：服务器之间投票选举端口</p><h4 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h4><p>启动集群就是分别启动每个实例。</p><p><img src="../%E6%96%87%E6%A1%A3/img/zk.png" alt></p><h3 id="RPC服务接口"><a href="#RPC服务接口" class="headerlink" title="RPC服务接口"></a>RPC服务接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><h4 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring-boot-stater--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--zookeeper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--API--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">spring.application.name=dubbo-demo-provider</span><br><span class="line">spring.dubbo.application.id=dubbo-demo-provider</span><br><span class="line">spring.dubbo.application.name=dubbo-demo-provider</span><br><span class="line">spring.dubbo.registry.address=zookeeper://192.168.25.140:2181;zookeeper://192.168.25.140:2182;zookeeper://192.168.25.140:2183</span><br><span class="line">spring.dubbo.server=true</span><br><span class="line">spring.dubbo.protocol.name=dubbo</span><br><span class="line">spring.dubbo.protocol.port=20880</span><br></pre></td></tr></table></figure><h4 id="启动类-2"><a href="#启动类-2" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SpringApplication.run(ProviderBootstrap.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务实现"><a href="#服务实现" class="headerlink" title="服务实现"></a>服务实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span>(interfaceClass = IUserService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello:"</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><h4 id="添加依赖-3"><a href="#添加依赖-3" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--zookeeper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--API--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-3"><a href="#配置文件-3" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">spring.application.name=dubbo-demo-consumer</span><br><span class="line">spring.dubbo.application.name=dubbo-demo-consumer</span><br><span class="line">spring.dubbo.application.id=dubbo-demo-consumer</span><br><span class="line">    spring.dubbo.registry.address=zookeeper://192.168.25.140:2181;zookeeper://192.168.25.140:2182;zookeeper://192.168.25.140:2183</span><br></pre></td></tr></table></figure><h4 id="启动类-3"><a href="#启动类-3" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerBootstrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerBootstrap.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sayHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="优惠券表"><a href="#优惠券表" class="headerlink" title="优惠券表"></a>优惠券表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>coupon_id</td><td>bigint(50) NOT NULL</td><td>优惠券ID</td></tr><tr><td>coupon_price</td><td>decimal(10,2) NULL</td><td>优惠券金额</td></tr><tr><td>user_id</td><td>bigint(50) NULL</td><td>用户ID</td></tr><tr><td>order_id</td><td>bigint(32) NULL</td><td>订单ID</td></tr><tr><td>is_used</td><td>int(1) NULL</td><td>是否使用 0未使用 1已使用</td></tr><tr><td>used_time</td><td>timestamp NULL</td><td>使用时间</td></tr></tbody></table></div><h3 id="商品表"><a href="#商品表" class="headerlink" title="商品表"></a>商品表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>goods_id</td><td>bigint(50) NOT NULL</td><td>主键</td></tr><tr><td>goods_name</td><td>varchar(255) NULL</td><td>商品名称</td></tr><tr><td>goods_number</td><td>int(11) NULL</td><td>商品库存</td></tr><tr><td>goods_price</td><td>decimal(10,2) NULL</td><td>商品价格</td></tr><tr><td>goods_desc</td><td>varchar(255) NULL</td><td>商品描述</td></tr><tr><td>add_time</td><td>timestamp NULL</td><td>添加时间</td></tr></tbody></table></div><h3 id="订单表"><a href="#订单表" class="headerlink" title="订单表"></a>订单表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>order_id</td><td>bigint(50) NOT NULL</td><td>订单ID</td></tr><tr><td>user_id</td><td>bigint(50) NULL</td><td>用户ID</td></tr><tr><td>order_status</td><td>int(1) NULL</td><td>订单状态 0未确认 1已确认 2已取消 3无效 4退款</td></tr><tr><td>pay_status</td><td>int(1) NULL</td><td>支付状态 0未支付 1支付中 2已支付</td></tr><tr><td>shipping_status</td><td>int(1) NULL</td><td>发货状态 0未发货 1已发货 2已退货</td></tr><tr><td>address</td><td>varchar(255) NULL</td><td>收货地址</td></tr><tr><td>consignee</td><td>varchar(255) NULL</td><td>收货人</td></tr><tr><td>goods_id</td><td>bigint(50) NULL</td><td>商品ID</td></tr><tr><td>goods_number</td><td>int(11) NULL</td><td>商品数量</td></tr><tr><td>goods_price</td><td>decimal(10,2) NULL</td><td>商品价格</td></tr><tr><td>goods_amount</td><td>decimal(10,0) NULL</td><td>商品总价</td></tr><tr><td>shipping_fee</td><td>decimal(10,2) NULL</td><td>运费</td></tr><tr><td>order_amount</td><td>decimal(10,2) NULL</td><td>订单价格</td></tr><tr><td>coupon_id</td><td>bigint(50) NULL</td><td>优惠券ID</td></tr><tr><td>coupon_paid</td><td>decimal(10,2) NULL</td><td>优惠券</td></tr><tr><td>money_paid</td><td>decimal(10,2) NULL</td><td>已付金额</td></tr><tr><td>pay_amount</td><td>decimal(10,2) NULL</td><td>支付金额</td></tr><tr><td>add_time</td><td>timestamp NULL</td><td>创建时间</td></tr><tr><td>confirm_time</td><td>timestamp NULL</td><td>订单确认时间</td></tr><tr><td>pay_time</td><td>timestamp NULL</td><td>支付时间</td></tr></tbody></table></div><h3 id="订单商品日志表"><a href="#订单商品日志表" class="headerlink" title="订单商品日志表"></a>订单商品日志表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>goods_id</td><td>int(11) NOT NULL</td><td>商品ID</td></tr><tr><td>order_id</td><td>varchar(32) NOT NULL</td><td>订单ID</td></tr><tr><td>goods_number</td><td>int(11) NULL</td><td>库存数量</td></tr><tr><td>log_time</td><td>datetime NULL</td><td>记录时间</td></tr></tbody></table></div><h3 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>user_id</td><td>bigint(50) NOT NULL</td><td>用户ID</td></tr><tr><td>user_name</td><td>varchar(255) NULL</td><td>用户姓名</td></tr><tr><td>user_password</td><td>varchar(255) NULL</td><td>用户密码</td></tr><tr><td>user_mobile</td><td>varchar(255) NULL</td><td>手机号</td></tr><tr><td>user_score</td><td>int(11) NULL</td><td>积分</td></tr><tr><td>user_reg_time</td><td>timestamp NULL</td><td>注册时间</td></tr><tr><td>user_money</td><td>decimal(10,0) NULL</td><td>用户余额</td></tr></tbody></table></div><h3 id="用户余额日志表"><a href="#用户余额日志表" class="headerlink" title="用户余额日志表"></a>用户余额日志表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>user_id</td><td>bigint(50) NOT NULL</td><td>用户ID</td></tr><tr><td>order_id</td><td>bigint(50) NOT NULL</td><td>订单ID</td></tr><tr><td>money_log_type</td><td>int(1) NOT NULL</td><td>日志类型 1订单付款 2 订单退款</td></tr><tr><td>use_money</td><td>decimal(10,2) NULL</td><td>操作金额</td></tr><tr><td>create_time</td><td>timestamp NULL</td><td>日志时间</td></tr></tbody></table></div><h3 id="订单支付表"><a href="#订单支付表" class="headerlink" title="订单支付表"></a>订单支付表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>pay_id</td><td>bigint(50) NOT NULL</td><td>支付编号</td></tr><tr><td>order_id</td><td>bigint(50) NULL</td><td>订单编号</td></tr><tr><td>pay_amount</td><td>decimal(10,2) NULL</td><td>支付金额</td></tr><tr><td>is_paid</td><td>int(1) NULL</td><td>是否已支付 1否 2是</td></tr></tbody></table></div><h3 id="MQ消息生产表"><a href="#MQ消息生产表" class="headerlink" title="MQ消息生产表"></a>MQ消息生产表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>id</td><td>varchar(100) NOT NULL</td><td>主键</td></tr><tr><td>group_name</td><td>varchar(100) NULL</td><td>生产者组名</td></tr><tr><td>msg_topic</td><td>varchar(100) NULL</td><td>消息主题</td></tr><tr><td>msg_tag</td><td>varchar(100) NULL</td><td>Tag</td></tr><tr><td>msg_key</td><td>varchar(100) NULL</td><td>Key</td></tr><tr><td>msg_body</td><td>varchar(500) NULL</td><td>消息内容</td></tr><tr><td>msg_status</td><td>int(1) NULL</td><td>0:未处理;1:已经处理</td></tr><tr><td>create_time</td><td>timestamp NOT NULL</td><td>记录时间</td></tr></tbody></table></div><h3 id="MQ消息消费表"><a href="#MQ消息消费表" class="headerlink" title="MQ消息消费表"></a>MQ消息消费表</h3><div class="table-container"><table><thead><tr><th>Field</th><th>Type</th><th>Comment</th></tr></thead><tbody><tr><td>msg_id</td><td>varchar(50) NULL</td><td>消息ID</td></tr><tr><td>group_name</td><td>varchar(100) NOT NULL</td><td>消费者组名</td></tr><tr><td>msg_tag</td><td>varchar(100) NOT NULL</td><td>Tag</td></tr><tr><td>msg_key</td><td>varchar(100) NOT NULL</td><td>Key</td></tr><tr><td>msg_body</td><td>varchar(500) NULL</td><td>消息体</td></tr><tr><td>consumer_status</td><td>int(1) NULL</td><td>0:正在处理;1:处理成功;2:处理失败</td></tr><tr><td>consumer_times</td><td>int(1) NULL</td><td>消费次数</td></tr><tr><td>consumer_timestamp</td><td>timestamp NULL</td><td>消费时间</td></tr><tr><td>remark</td><td>varchar(500) NULL</td><td>备注</td></tr></tbody></table></div><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>shop系统基于Maven进行项目管理</p><h3 id="工程浏览"><a href="#工程浏览" class="headerlink" title="工程浏览"></a>工程浏览</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiang-mu-chu-shi-hua.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><ul><li>父工程：shop-parent</li><li>订单系统：shop-order-web</li><li>支付系统：shop-pay-web</li><li>优惠券服务：shop-coupon-service</li><li>订单服务：shop-order-service</li><li>支付服务：shop-pay-service</li><li>商品服务：shop-goods-service</li><li>用户服务：shop-user-service</li><li>实体类：shop-pojo</li><li>持久层：shop-dao</li><li>接口层：shop-api</li><li>工具工程：shop-common</li></ul><p>共12个系统</p><h3 id="工程关系"><a href="#工程关系" class="headerlink" title="工程关系"></a>工程关系</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiang-mu-jie-gou-tu.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="Mybatis逆向工程使用"><a href="#Mybatis逆向工程使用" class="headerlink" title="Mybatis逆向工程使用"></a>Mybatis逆向工程使用</h2><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>使用Mybatis逆向工程针对数据表生成CURD持久层代码</p><h3 id="代码导入"><a href="#代码导入" class="headerlink" title="代码导入"></a>代码导入</h3><ul><li>将实体类导入到shop-pojo工程</li><li>在服务层工程中导入对应的Mapper类和对应配置文件</li></ul><h2 id="公共类介绍"><a href="#公共类介绍" class="headerlink" title="公共类介绍"></a>公共类介绍</h2><ul><li><p>ID生成器</p><p>IDWorker：Twitter雪花算法</p></li><li><p>异常处理类</p><p>CustomerException：自定义异常类</p><p>CastException：异常抛出类</p></li><li><p>常量类</p><p>ShopCode：系统状态类</p></li><li><p>响应实体类</p><p>Result：封装响应状态和响应信息</p></li></ul><h1 id="下单业务"><a href="#下单业务" class="headerlink" title="下单业务"></a>下单业务</h1><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xia-dan-shi-xu-tu-2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="下单基本流程"><a href="#下单基本流程" class="headerlink" title="下单基本流程"></a>下单基本流程</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><ul><li>IOrderService</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认订单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">confirmOrder</span><span class="params">(TradeOrder order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务类实现"><a href="#业务类实现" class="headerlink" title="业务类实现"></a>业务类实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span>(interfaceClass = IOrderService.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">IOrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">confirmOrder</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.校验订单</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//2.生成预订单</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3.扣减库存</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4.扣减优惠券</span></span><br><span class="line">           </span><br><span class="line">            <span class="comment">//5.使用余额</span></span><br><span class="line">           </span><br><span class="line">            <span class="comment">//6.确认订单</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//7.返回成功状态</span></span><br><span class="line">           </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//1.确认订单失败,发送消息</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2.返回失败状态</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="校验订单"><a href="#校验订单" class="headerlink" title="校验订单"></a>校验订单</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/xiao-yan-ding-dan-2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkOrder</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.校验订单是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(order==<span class="keyword">null</span>)&#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_ORDER_INVALID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.校验订单中的商品是否存在</span></span><br><span class="line">        TradeGoods goods = goodsService.findOne(order.getGoodsId());</span><br><span class="line">        <span class="keyword">if</span>(goods==<span class="keyword">null</span>)&#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_GOODS_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.校验下单用户是否存在</span></span><br><span class="line">        TradeUser user = userService.findOne(order.getUserId());</span><br><span class="line">        <span class="keyword">if</span>(user==<span class="keyword">null</span>)&#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_USER_NO_EXIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.校验商品单价是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(order.getGoodsPrice().compareTo(goods.getGoodsPrice())!=<span class="number">0</span>)&#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_GOODS_PRICE_INVALID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.校验订单商品数量是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(order.getGoodsNumber()&gt;=goods.getGoodsNumber())&#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_GOODS_NUM_NOT_ENOUGH);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"校验订单通过"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成预订单"><a href="#生成预订单" class="headerlink" title="生成预订单"></a>生成预订单</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/sheng-cheng-yu-ding-dan.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">savePreOrder</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.设置订单状态为不可见</span></span><br><span class="line">        order.setOrderStatus(ShopCode.SHOP_ORDER_NO_CONFIRM.getCode());</span><br><span class="line">        <span class="comment">//2.订单ID</span></span><br><span class="line">        order.setOrderId(idWorker.nextId());</span><br><span class="line">        <span class="comment">//核算运费是否正确</span></span><br><span class="line">        BigDecimal shippingFee = calculateShippingFee(order.getOrderAmount());</span><br><span class="line">        <span class="keyword">if</span> (order.getShippingFee().compareTo(shippingFee) != <span class="number">0</span>) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_ORDER_SHIPPINGFEE_INVALID);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.计算订单总价格是否正确</span></span><br><span class="line">        BigDecimal orderAmount = order.getGoodsPrice().multiply(<span class="keyword">new</span> BigDecimal(order.getGoodsNumber()));</span><br><span class="line">        orderAmount.add(shippingFee);</span><br><span class="line">        <span class="keyword">if</span> (orderAmount.compareTo(order.getOrderAmount()) != <span class="number">0</span>) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_ORDERAMOUNT_INVALID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断优惠券信息是否合法</span></span><br><span class="line">        Long couponId = order.getCouponId();</span><br><span class="line">        <span class="keyword">if</span> (couponId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TradeCoupon coupon = couponService.findOne(couponId);</span><br><span class="line">            <span class="comment">//优惠券不存在</span></span><br><span class="line">            <span class="keyword">if</span> (coupon == <span class="keyword">null</span>) &#123;</span><br><span class="line">                CastException.cast(ShopCode.SHOP_COUPON_NO_EXIST);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//优惠券已经使用</span></span><br><span class="line">            <span class="keyword">if</span> ((ShopCode.SHOP_COUPON_ISUSED.getCode().toString())</span><br><span class="line">                .equals(coupon.getIsUsed().toString())) &#123;</span><br><span class="line">                CastException.cast(ShopCode.SHOP_COUPON_INVALIED);</span><br><span class="line">            &#125;</span><br><span class="line">            order.setCouponPaid(coupon.getCouponPrice());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            order.setCouponPaid(BigDecimal.ZERO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断余额是否正确</span></span><br><span class="line">        BigDecimal moneyPaid = order.getMoneyPaid();</span><br><span class="line">        <span class="keyword">if</span> (moneyPaid != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//比较余额是否大于0</span></span><br><span class="line">            <span class="keyword">int</span> r = order.getMoneyPaid().compareTo(BigDecimal.ZERO);</span><br><span class="line">            <span class="comment">//余额小于0</span></span><br><span class="line">            <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">                CastException.cast(ShopCode.SHOP_MONEY_PAID_LESS_ZERO);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//余额大于0</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//查询用户信息</span></span><br><span class="line">                TradeUser user = userService.findOne(order.getUserId());</span><br><span class="line">                <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    CastException.cast(ShopCode.SHOP_USER_NO_EXIST);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//比较余额是否大于用户账户余额</span></span><br><span class="line">            <span class="keyword">if</span> (user.getUserMoney().compareTo(order.getMoneyPaid().longValue()) == -<span class="number">1</span>) &#123;</span><br><span class="line">                CastException.cast(ShopCode.SHOP_MONEY_PAID_INVALID);</span><br><span class="line">            &#125;</span><br><span class="line">            order.setMoneyPaid(order.getMoneyPaid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        order.setMoneyPaid(BigDecimal.ZERO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算订单支付总价</span></span><br><span class="line">    order.setPayAmount(orderAmount.subtract(order.getCouponPaid())</span><br><span class="line">                       .subtract(order.getMoneyPaid()));</span><br><span class="line">    <span class="comment">//设置订单添加时间</span></span><br><span class="line">    order.setAddTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存预订单</span></span><br><span class="line">    <span class="keyword">int</span> r = orderMapper.insert(order);</span><br><span class="line">    <span class="keyword">if</span> (ShopCode.SHOP_SUCCESS.getCode() != r) &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_ORDER_SAVE_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"]预订单生成成功"</span>);</span><br><span class="line">    <span class="keyword">return</span> order.getOrderId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扣减库存"><a href="#扣减库存" class="headerlink" title="扣减库存"></a>扣减库存</h3><ul><li>通过dubbo调用商品服务完成扣减库存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reduceGoodsNum</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">        TradeGoodsNumberLog goodsNumberLog = <span class="keyword">new</span> TradeGoodsNumberLog();</span><br><span class="line">        goodsNumberLog.setGoodsId(order.getGoodsId());</span><br><span class="line">        goodsNumberLog.setOrderId(order.getOrderId());</span><br><span class="line">        goodsNumberLog.setGoodsNumber(order.getGoodsNumber());</span><br><span class="line">        Result result = goodsService.reduceGoodsNum(goodsNumberLog);</span><br><span class="line">        <span class="keyword">if</span> (result.getSuccess().equals(ShopCode.SHOP_FAIL.getSuccess())) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_REDUCE_GOODS_NUM_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"]扣减库存["</span>+order.getGoodsNumber()+<span class="string">"个]成功"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>商品服务GoodsService扣减库存</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">reduceGoodsNum</span><span class="params">(TradeGoodsNumberLog goodsNumberLog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (goodsNumberLog == <span class="keyword">null</span> ||</span><br><span class="line">            goodsNumberLog.getGoodsNumber() == <span class="keyword">null</span> ||</span><br><span class="line">            goodsNumberLog.getOrderId() == <span class="keyword">null</span> ||</span><br><span class="line">            goodsNumberLog.getGoodsNumber() == <span class="keyword">null</span> ||</span><br><span class="line">            goodsNumberLog.getGoodsNumber().intValue() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_REQUEST_PARAMETER_VALID);</span><br><span class="line">    &#125;</span><br><span class="line">    TradeGoods goods = goodsMapper.selectByPrimaryKey(goodsNumberLog.getGoodsId());</span><br><span class="line">    <span class="keyword">if</span>(goods.getGoodsNumber()&lt;goodsNumberLog.getGoodsNumber())&#123;</span><br><span class="line">        <span class="comment">//库存不足</span></span><br><span class="line">        CastException.cast(ShopCode.SHOP_GOODS_NUM_NOT_ENOUGH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减库存</span></span><br><span class="line">    goods.setGoodsNumber(goods.getGoodsNumber()-goodsNumberLog.getGoodsNumber());</span><br><span class="line">    goodsMapper.updateByPrimaryKey(goods);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录库存操作日志</span></span><br><span class="line">    goodsNumberLog.setGoodsNumber(-(goodsNumberLog.getGoodsNumber()));</span><br><span class="line">    goodsNumberLog.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line">    goodsNumberLogMapper.insert(goodsNumberLog);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_SUCCESS.getSuccess(),ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扣减优惠券"><a href="#扣减优惠券" class="headerlink" title="扣减优惠券"></a>扣减优惠券</h3><ul><li>通过dubbo完成扣减优惠券</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeCoponStatus</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断用户是否使用优惠券</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(order.getCouponId())) &#123;</span><br><span class="line">        <span class="comment">//封装优惠券对象</span></span><br><span class="line">        TradeCoupon coupon = couponService.findOne(order.getCouponId());</span><br><span class="line">        coupon.setIsUsed(ShopCode.SHOP_COUPON_ISUSED.getCode());</span><br><span class="line">        coupon.setUsedTime(<span class="keyword">new</span> Date());</span><br><span class="line">        coupon.setOrderId(order.getOrderId());</span><br><span class="line">        Result result = couponService.changeCouponStatus(coupon);</span><br><span class="line">        <span class="comment">//判断执行结果</span></span><br><span class="line">        <span class="keyword">if</span> (result.getSuccess().equals(ShopCode.SHOP_FAIL.getSuccess())) &#123;</span><br><span class="line">            <span class="comment">//优惠券使用失败</span></span><br><span class="line">            CastException.cast(ShopCode.SHOP_COUPON_USE_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"]使用扣减优惠券["</span>+coupon.getCouponPrice()+<span class="string">"元]成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优惠券服务CouponService更改优惠券状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">changeCouponStatus</span><span class="params">(TradeCoupon coupon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断请求参数是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (coupon == <span class="keyword">null</span> || StringUtils.isEmpty(coupon.getCouponId())) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_REQUEST_PARAMETER_VALID);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//更新优惠券状态为已使用</span></span><br><span class="line">        couponMapper.updateByPrimaryKey(coupon);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_SUCCESS.getSuccess(), ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_FAIL.getSuccess(), ShopCode.SHOP_FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扣减用户余额"><a href="#扣减用户余额" class="headerlink" title="扣减用户余额"></a>扣减用户余额</h3><ul><li>通过用户服务完成扣减余额</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reduceMoneyPaid</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断订单中使用的余额是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (order.getMoneyPaid() != <span class="keyword">null</span> &amp;&amp; order.getMoneyPaid().compareTo(BigDecimal.ZERO) == <span class="number">1</span>) &#123;</span><br><span class="line">        TradeUserMoneyLog userMoneyLog = <span class="keyword">new</span> TradeUserMoneyLog();</span><br><span class="line">        userMoneyLog.setOrderId(order.getOrderId());</span><br><span class="line">        userMoneyLog.setUserId(order.getUserId());</span><br><span class="line">        userMoneyLog.setUseMoney(order.getMoneyPaid());</span><br><span class="line">        userMoneyLog.setMoneyLogType(ShopCode.SHOP_USER_MONEY_PAID.getCode());</span><br><span class="line">        <span class="comment">//扣减余额</span></span><br><span class="line">        Result result = userService.changeUserMoney(userMoneyLog);</span><br><span class="line">        <span class="keyword">if</span> (result.getSuccess().equals(ShopCode.SHOP_FAIL.getSuccess())) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_USER_MONEY_REDUCE_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"扣减余额["</span>+order.getMoneyPaid()+<span class="string">"元]成功]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户服务UserService,更新余额</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/geng-gai-yong-hu-yu-e.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">changeUserMoney</span><span class="params">(TradeUserMoneyLog userMoneyLog)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断请求参数是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (userMoneyLog == <span class="keyword">null</span></span><br><span class="line">            || userMoneyLog.getUserId() == <span class="keyword">null</span></span><br><span class="line">            || userMoneyLog.getUseMoney() == <span class="keyword">null</span></span><br><span class="line">            || userMoneyLog.getOrderId() == <span class="keyword">null</span></span><br><span class="line">            || userMoneyLog.getUseMoney().compareTo(BigDecimal.ZERO) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_REQUEST_PARAMETER_VALID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询该订单是否存在付款记录</span></span><br><span class="line">    TradeUserMoneyLogExample userMoneyLogExample = <span class="keyword">new</span> TradeUserMoneyLogExample();</span><br><span class="line">    userMoneyLogExample.createCriteria()</span><br><span class="line">            .andUserIdEqualTo(userMoneyLog.getUserId())</span><br><span class="line">            .andOrderIdEqualTo(userMoneyLog.getOrderId());</span><br><span class="line">   <span class="keyword">int</span> count = userMoneyLogMapper.countByExample(userMoneyLogExample);</span><br><span class="line">   TradeUser tradeUser = <span class="keyword">new</span> TradeUser();</span><br><span class="line">   tradeUser.setUserId(userMoneyLog.getUserId());</span><br><span class="line">   tradeUser.setUserMoney(userMoneyLog.getUseMoney().longValue());</span><br><span class="line">   <span class="comment">//判断余额操作行为</span></span><br><span class="line">   <span class="comment">//【付款操作】</span></span><br><span class="line">   <span class="keyword">if</span> (userMoneyLog.getMoneyLogType().equals(ShopCode.SHOP_USER_MONEY_PAID.getCode())) &#123;</span><br><span class="line">           <span class="comment">//订单已经付款，则抛异常</span></span><br><span class="line">           <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                CastException.cast(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//用户账户扣减余额</span></span><br><span class="line">           userMapper.reduceUserMoney(tradeUser);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">//【退款操作】</span></span><br><span class="line">    <span class="keyword">if</span> (userMoneyLog.getMoneyLogType().equals(ShopCode.SHOP_USER_MONEY_REFUND.getCode())) &#123;</span><br><span class="line">         <span class="comment">//如果订单未付款,则不能退款,抛异常</span></span><br><span class="line">         <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">         CastException.cast(ShopCode.SHOP_ORDER_PAY_STATUS_NO_PAY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//防止多次退款</span></span><br><span class="line">     userMoneyLogExample = <span class="keyword">new</span> TradeUserMoneyLogExample();</span><br><span class="line">     userMoneyLogExample.createCriteria()</span><br><span class="line">             .andUserIdEqualTo(userMoneyLog.getUserId())</span><br><span class="line">                .andOrderIdEqualTo(userMoneyLog.getOrderId())</span><br><span class="line">                .andMoneyLogTypeEqualTo(ShopCode.SHOP_USER_MONEY_REFUND.getCode());</span><br><span class="line">     count = userMoneyLogMapper.countByExample(userMoneyLogExample);</span><br><span class="line">     <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         CastException.cast(ShopCode.SHOP_USER_MONEY_REFUND_ALREADY);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//用户账户添加余额</span></span><br><span class="line">        userMapper.addUserMoney(tradeUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录用户使用余额日志</span></span><br><span class="line">    userMoneyLog.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">    userMoneyLogMapper.insert(userMoneyLog);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_SUCCESS.getSuccess(),ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确认订单"><a href="#确认订单" class="headerlink" title="确认订单"></a>确认订单</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateOrderStatus</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">    order.setOrderStatus(ShopCode.SHOP_ORDER_CONFIRM.getCode());</span><br><span class="line">    order.setPayStatus(ShopCode.SHOP_ORDER_PAY_STATUS_NO_PAY.getCode());</span><br><span class="line">    order.setConfirmTime(<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">int</span> r = orderMapper.updateByPrimaryKey(order);</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_ORDER_CONFIRM_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"]状态修改成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">confirmOrder</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.校验订单</span></span><br><span class="line">    checkOrder(order);</span><br><span class="line">    <span class="comment">//2.生成预订单</span></span><br><span class="line">    Long orderId = savePreOrder(order);</span><br><span class="line">    order.setOrderId(orderId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.扣减库存</span></span><br><span class="line">        reduceGoodsNum(order);</span><br><span class="line">        <span class="comment">//4.扣减优惠券</span></span><br><span class="line">        changeCoponStatus(order);</span><br><span class="line">        <span class="comment">//5.使用余额</span></span><br><span class="line">        reduceMoneyPaid(order);</span><br><span class="line">        <span class="comment">//6.确认订单</span></span><br><span class="line">        updateOrderStatus(order);</span><br><span class="line">        log.info(<span class="string">"订单:["</span>+orderId+<span class="string">"]确认成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_SUCCESS.getSuccess(), ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//确认订单失败,发送消息</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_FAIL.getSuccess(), ShopCode.SHOP_FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失败补偿机制"><a href="#失败补偿机制" class="headerlink" title="失败补偿机制"></a>失败补偿机制</h2><h3 id="消息发送方"><a href="#消息发送方" class="headerlink" title="消息发送方"></a>消息发送方</h3><ul><li>配置RocketMQ属性值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.name-server=192.168.25.135:9876;192.168.25.138:9876</span><br><span class="line">rocketmq.producer.group=orderProducerGroup</span><br><span class="line"></span><br><span class="line">mq.order.consumer.group.name=order_orderTopic_cancel_group</span><br><span class="line">mq.order.topic=orderTopic</span><br><span class="line">mq.order.tag.confirm=order_confirm</span><br><span class="line">mq.order.tag.cancel=order_cancel</span><br></pre></td></tr></table></figure><ul><li>注入模板类和属性值信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;mq.order.topic&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String topic;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;mq.order.tag.cancel&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String cancelTag;</span><br></pre></td></tr></table></figure><ul><li>发送下单失败消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">confirmOrder</span><span class="params">(TradeOrder order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.校验订单</span></span><br><span class="line">    <span class="comment">//2.生成预订</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.扣减库存</span></span><br><span class="line">        <span class="comment">//4.扣减优惠券</span></span><br><span class="line">        <span class="comment">//5.使用余额</span></span><br><span class="line">        <span class="comment">//6.确认订单</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//确认订单失败,发送消息</span></span><br><span class="line">        CancelOrderMQ cancelOrderMQ = <span class="keyword">new</span> CancelOrderMQ();</span><br><span class="line">        cancelOrderMQ.setOrderId(order.getOrderId());</span><br><span class="line">        cancelOrderMQ.setCouponId(order.getCouponId());</span><br><span class="line">        cancelOrderMQ.setGoodsId(order.getGoodsId());</span><br><span class="line">        cancelOrderMQ.setGoodsNumber(order.getGoodsNumber());</span><br><span class="line">        cancelOrderMQ.setUserId(order.getUserId());</span><br><span class="line">        cancelOrderMQ.setUserMoney(order.getMoneyPaid());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(topic, </span><br><span class="line">                        cancelTag, </span><br><span class="line">                        cancelOrderMQ.getOrderId().toString(), </span><br><span class="line">                    JSON.toJSONString(cancelOrderMQ));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">            CastException.cast(ShopCode.SHOP_MQ_SEND_MESSAGE_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_FAIL.getSuccess(), ShopCode.SHOP_FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String topic, String tags, String keys, String body)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//判断Topic是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(topic)) &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_MQ_TOPIC_IS_EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断消息内容是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(body)) &#123;</span><br><span class="line">        CastException.cast(ShopCode.SHOP_MQ_MESSAGE_BODY_IS_EMPTY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消息体</span></span><br><span class="line">    Message message = <span class="keyword">new</span> Message(topic, tags, keys, body.getBytes());</span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    rocketMQTemplate.getProducer().send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费接收方"><a href="#消费接收方" class="headerlink" title="消费接收方"></a>消费接收方</h3><ul><li>配置RocketMQ属性值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.name-server=192.168.25.135:9876;192.168.25.138:9876</span><br><span class="line">mq.order.consumer.group.name=order_orderTopic_cancel_group</span><br><span class="line">mq.order.topic=orderTopic</span><br></pre></td></tr></table></figure><ul><li>创建监听类，消费消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"$&#123;mq.order.topic&#125;"</span>, </span><br><span class="line">                         consumerGroup = <span class="string">"$&#123;mq.order.consumer.group.name&#125;"</span>,</span><br><span class="line">                         messageModel = MessageModel.BROADCASTING)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderConsumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回退库存"><a href="#回退库存" class="headerlink" title="回退库存"></a>回退库存</h4><ul><li>流程分析</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/hui-tui-ku-cun.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li>消息消费者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"$&#123;mq.order.topic&#125;"</span>,consumerGroup = <span class="string">"$&#123;mq.order.consumer.group.name&#125;"</span>,messageModel = MessageModel.BROADCASTING )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelMQListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mq.order.consumer.group.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String groupName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TradeGoodsMapper goodsMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TradeMqConsumerLogMapper mqConsumerLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TradeGoodsNumberLogMapper goodsNumberLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        String msgId=<span class="keyword">null</span>;</span><br><span class="line">        String tags=<span class="keyword">null</span>;</span><br><span class="line">        String keys=<span class="keyword">null</span>;</span><br><span class="line">        String body=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 解析消息内容</span></span><br><span class="line">            msgId = messageExt.getMsgId();</span><br><span class="line">            tags= messageExt.getTags();</span><br><span class="line">            keys= messageExt.getKeys();</span><br><span class="line">            body= <span class="keyword">new</span> String(messageExt.getBody(),<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"接受消息成功"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2. 查询消息消费记录</span></span><br><span class="line">            TradeMqConsumerLogKey primaryKey = <span class="keyword">new</span> TradeMqConsumerLogKey();</span><br><span class="line">            primaryKey.setMsgTag(tags);</span><br><span class="line">            primaryKey.setMsgKey(keys);</span><br><span class="line">            primaryKey.setGroupName(groupName);</span><br><span class="line">            TradeMqConsumerLog mqConsumerLog = mqConsumerLogMapper.selectByPrimaryKey(primaryKey);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mqConsumerLog!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//3. 判断如果消费过...</span></span><br><span class="line">                <span class="comment">//3.1 获得消息处理状态</span></span><br><span class="line">                Integer status = mqConsumerLog.getConsumerStatus();</span><br><span class="line">                <span class="comment">//处理过...返回</span></span><br><span class="line">                <span class="keyword">if</span>(ShopCode.SHOP_MQ_MESSAGE_STATUS_SUCCESS.getCode().intValue()==status.intValue())&#123;</span><br><span class="line">                    log.info(<span class="string">"消息:"</span>+msgId+<span class="string">",已经处理过"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//正在处理...返回</span></span><br><span class="line">                <span class="keyword">if</span>(ShopCode.SHOP_MQ_MESSAGE_STATUS_PROCESSING.getCode().intValue()==status.intValue())&#123;</span><br><span class="line">                    log.info(<span class="string">"消息:"</span>+msgId+<span class="string">",正在处理"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理失败</span></span><br><span class="line">                <span class="keyword">if</span>(ShopCode.SHOP_MQ_MESSAGE_STATUS_FAIL.getCode().intValue()==status.intValue())&#123;</span><br><span class="line">                    <span class="comment">//获得消息处理次数</span></span><br><span class="line">                    Integer times = mqConsumerLog.getConsumerTimes();</span><br><span class="line">                    <span class="keyword">if</span>(times&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                        log.info(<span class="string">"消息:"</span>+msgId+<span class="string">",消息处理超过3次,不能再进行处理了"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mqConsumerLog.setConsumerStatus(ShopCode.SHOP_MQ_MESSAGE_STATUS_PROCESSING.getCode());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//使用数据库乐观锁更新</span></span><br><span class="line">                    TradeMqConsumerLogExample example = <span class="keyword">new</span> TradeMqConsumerLogExample();</span><br><span class="line">                    TradeMqConsumerLogExample.Criteria criteria = example.createCriteria();</span><br><span class="line">                    criteria.andMsgTagEqualTo(mqConsumerLog.getMsgTag());</span><br><span class="line">                    criteria.andMsgKeyEqualTo(mqConsumerLog.getMsgKey());</span><br><span class="line">                    criteria.andGroupNameEqualTo(groupName);</span><br><span class="line">                    criteria.andConsumerTimesEqualTo(mqConsumerLog.getConsumerTimes());</span><br><span class="line">                    <span class="keyword">int</span> r = mqConsumerLogMapper.updateByExampleSelective(mqConsumerLog, example);</span><br><span class="line">                    <span class="keyword">if</span>(r&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//未修改成功,其他线程并发修改</span></span><br><span class="line">                        log.info(<span class="string">"并发修改,稍后处理"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//4. 判断如果没有消费过...</span></span><br><span class="line">                mqConsumerLog = <span class="keyword">new</span> TradeMqConsumerLog();</span><br><span class="line">                mqConsumerLog.setMsgTag(tags);</span><br><span class="line">                mqConsumerLog.setMsgKey(keys);</span><br><span class="line">                mqConsumerLog.setConsumerStatus(ShopCode.SHOP_MQ_MESSAGE_STATUS_PROCESSING.getCode());</span><br><span class="line">                mqConsumerLog.setMsgBody(body);</span><br><span class="line">                mqConsumerLog.setMsgId(msgId);</span><br><span class="line">                mqConsumerLog.setConsumerTimes(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将消息处理信息添加到数据库</span></span><br><span class="line">                mqConsumerLogMapper.insert(mqConsumerLog);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5. 回退库存</span></span><br><span class="line">            MQEntity mqEntity = JSON.parseObject(body, MQEntity.class);</span><br><span class="line">            Long goodsId = mqEntity.getGoodsId();</span><br><span class="line">            TradeGoods goods = goodsMapper.selectByPrimaryKey(goodsId);</span><br><span class="line">            goods.setGoodsNumber(goods.getGoodsNumber()+mqEntity.getGoodsNum());</span><br><span class="line">            goodsMapper.updateByPrimaryKey(goods);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录库存操作日志</span></span><br><span class="line">            TradeGoodsNumberLog goodsNumberLog = <span class="keyword">new</span> TradeGoodsNumberLog();</span><br><span class="line">            goodsNumberLog.setOrderId(mqEntity.getOrderId());</span><br><span class="line">            goodsNumberLog.setGoodsId(goodsId);</span><br><span class="line">            goodsNumberLog.setGoodsNumber(mqEntity.getGoodsNum());</span><br><span class="line">            goodsNumberLog.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line">            goodsNumberLogMapper.insert(goodsNumberLog);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 将消息的处理状态改为成功</span></span><br><span class="line">            mqConsumerLog.setConsumerStatus(ShopCode.SHOP_MQ_MESSAGE_STATUS_SUCCESS.getCode());</span><br><span class="line">            mqConsumerLog.setConsumerTimestamp(<span class="keyword">new</span> Date());</span><br><span class="line">            mqConsumerLogMapper.updateByPrimaryKey(mqConsumerLog);</span><br><span class="line">            log.info(<span class="string">"回退库存成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            TradeMqConsumerLogKey primaryKey = <span class="keyword">new</span> TradeMqConsumerLogKey();</span><br><span class="line">            primaryKey.setMsgTag(tags);</span><br><span class="line">            primaryKey.setMsgKey(keys);</span><br><span class="line">            primaryKey.setGroupName(groupName);</span><br><span class="line">            TradeMqConsumerLog mqConsumerLog = mqConsumerLogMapper.selectByPrimaryKey(primaryKey);</span><br><span class="line">            <span class="keyword">if</span>(mqConsumerLog==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//数据库未有记录</span></span><br><span class="line">                mqConsumerLog = <span class="keyword">new</span> TradeMqConsumerLog();</span><br><span class="line">                mqConsumerLog.setMsgTag(tags);</span><br><span class="line">                mqConsumerLog.setMsgKey(keys);</span><br><span class="line">                mqConsumerLog.setConsumerStatus(ShopCode.SHOP_MQ_MESSAGE_STATUS_FAIL.getCode());</span><br><span class="line">                mqConsumerLog.setMsgBody(body);</span><br><span class="line">                mqConsumerLog.setMsgId(msgId);</span><br><span class="line">                mqConsumerLog.setConsumerTimes(<span class="number">1</span>);</span><br><span class="line">                mqConsumerLogMapper.insert(mqConsumerLog);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                mqConsumerLog.setConsumerTimes(mqConsumerLog.getConsumerTimes()+<span class="number">1</span>);</span><br><span class="line">                mqConsumerLogMapper.updateByPrimaryKeySelective(mqConsumerLog);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回退优惠券"><a href="#回退优惠券" class="headerlink" title="回退优惠券"></a>回退优惠券</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"$&#123;mq.order.topic&#125;"</span>,consumerGroup = <span class="string">"$&#123;mq.order.consumer.group.name&#125;"</span>,messageModel = MessageModel.BROADCASTING )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelMQListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TradeCouponMapper couponMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 解析消息内容</span></span><br><span class="line">            String body = <span class="keyword">new</span> String(message.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">            MQEntity mqEntity = JSON.parseObject(body, MQEntity.class);</span><br><span class="line">            log.info(<span class="string">"接收到消息"</span>);</span><br><span class="line">            <span class="comment">//2. 查询优惠券信息</span></span><br><span class="line">            TradeCoupon coupon = couponMapper.selectByPrimaryKey(mqEntity.getCouponId());</span><br><span class="line">            <span class="comment">//3.更改优惠券状态</span></span><br><span class="line">            coupon.setUsedTime(<span class="keyword">null</span>);</span><br><span class="line">            coupon.setIsUsed(ShopCode.SHOP_COUPON_UNUSED.getCode());</span><br><span class="line">            coupon.setOrderId(<span class="keyword">null</span>);</span><br><span class="line">            couponMapper.updateByPrimaryKey(coupon);</span><br><span class="line">            log.info(<span class="string">"回退优惠券成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"回退优惠券失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回退余额"><a href="#回退余额" class="headerlink" title="回退余额"></a>回退余额</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"$&#123;mq.order.topic&#125;"</span>,consumerGroup = <span class="string">"$&#123;mq.order.consumer.group.name&#125;"</span>,messageModel = MessageModel.BROADCASTING )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelMQListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.解析消息</span></span><br><span class="line">            String body = <span class="keyword">new</span> String(messageExt.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">            MQEntity mqEntity = JSON.parseObject(body, MQEntity.class);</span><br><span class="line">            log.info(<span class="string">"接收到消息"</span>);</span><br><span class="line">            <span class="keyword">if</span>(mqEntity.getUserMoney()!=<span class="keyword">null</span> &amp;&amp; mqEntity.getUserMoney().compareTo(BigDecimal.ZERO)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//2.调用业务层,进行余额修改</span></span><br><span class="line">                TradeUserMoneyLog userMoneyLog = <span class="keyword">new</span> TradeUserMoneyLog();</span><br><span class="line">                userMoneyLog.setUseMoney(mqEntity.getUserMoney());</span><br><span class="line">                userMoneyLog.setMoneyLogType(ShopCode.SHOP_USER_MONEY_REFUND.getCode());</span><br><span class="line">                userMoneyLog.setUserId(mqEntity.getUserId());</span><br><span class="line">                userMoneyLog.setOrderId(mqEntity.getOrderId());</span><br><span class="line">                userService.updateMoneyPaid(userMoneyLog);</span><br><span class="line">                log.info(<span class="string">"余额回退成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"余额回退失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取消订单"><a href="#取消订单" class="headerlink" title="取消订单"></a>取消订单</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        String body = <span class="keyword">new</span> String(messageExt.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        String msgId = messageExt.getMsgId();</span><br><span class="line">        String tags = messageExt.getTags();</span><br><span class="line">        String keys = messageExt.getKeys();</span><br><span class="line">        log.info(<span class="string">"CancelOrderProcessor receive message:"</span>+messageExt);</span><br><span class="line">        CancelOrderMQ cancelOrderMQ = JSON.parseObject(body, CancelOrderMQ.class);</span><br><span class="line">        TradeOrder order = orderService.findOne(cancelOrderMQ.getOrderId());</span><br><span class="line">order.setOrderStatus(ShopCode.SHOP_ORDER_CANCEL.getCode());</span><br><span class="line">        orderService.changeOrderStatus(order);</span><br><span class="line">        log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"]状态设置为取消"</span>);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="准备测试环境"><a href="#准备测试环境" class="headerlink" title="准备测试环境"></a>准备测试环境</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = ShopOrderServiceApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IOrderService orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备测试数据"><a href="#准备测试数据" class="headerlink" title="准备测试数据"></a>准备测试数据</h3><ul><li>用户数据</li><li>商品数据</li><li>优惠券数据</li></ul><h3 id="测试下单成功流程"><a href="#测试下单成功流程" class="headerlink" title="测试下单成功流程"></a>测试下单成功流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Long goodsId=XXXL;</span><br><span class="line">    Long userId=XXXL;</span><br><span class="line">    Long couponId=XXXL;</span><br><span class="line"></span><br><span class="line">    TradeOrder order = <span class="keyword">new</span> TradeOrder();</span><br><span class="line">    order.setGoodsId(goodsId);</span><br><span class="line">    order.setUserId(userId);</span><br><span class="line">    order.setGoodsNumber(<span class="number">1</span>);</span><br><span class="line">    order.setAddress(<span class="string">"北京"</span>);</span><br><span class="line">    order.setGoodsPrice(<span class="keyword">new</span> BigDecimal(<span class="string">"5000"</span>));</span><br><span class="line">    order.setOrderAmount(<span class="keyword">new</span> BigDecimal(<span class="string">"5000"</span>));</span><br><span class="line">    order.setMoneyPaid(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>));</span><br><span class="line">    order.setCouponId(couponId);</span><br><span class="line">    order.setShippingFee(<span class="keyword">new</span> BigDecimal(<span class="number">0</span>));</span><br><span class="line">    orderService.confirmOrder(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完毕后,查看数据库中用户的余额、优惠券数据，及订单的状态数据</p><h3 id="测试下单失败流程"><a href="#测试下单失败流程" class="headerlink" title="测试下单失败流程"></a>测试下单失败流程</h3><p>代码同上。</p><p>执行完毕后，查看用户的余额、优惠券数据是否发生更改，订单的状态是否为取消。</p><h1 id="支付业务"><a href="#支付业务" class="headerlink" title="支付业务"></a>支付业务</h1><h2 id="创建支付订单"><a href="#创建支付订单" class="headerlink" title="创建支付订单"></a>创建支付订单</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/chuang-jian-zhi-fu-ding-dan.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">createPayment</span><span class="params">(TradePay tradePay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询订单支付状态</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TradePayExample payExample = <span class="keyword">new</span> TradePayExample();</span><br><span class="line">        TradePayExample.Criteria criteria = payExample.createCriteria();</span><br><span class="line">        criteria.andOrderIdEqualTo(tradePay.getOrderId());</span><br><span class="line">        criteria.andIsPaidEqualTo(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode());</span><br><span class="line">        <span class="keyword">int</span> count = tradePayMapper.countByExample(payExample);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> payId = idWorker.nextId();</span><br><span class="line">        tradePay.setPayId(payId);</span><br><span class="line">        tradePay.setIsPaid(ShopCode.SHOP_ORDER_PAY_STATUS_NO_PAY.getCode());</span><br><span class="line">        tradePayMapper.insert(tradePay);</span><br><span class="line">        log.info(<span class="string">"创建支付订单成功:"</span> + payId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_FAIL.getSuccess(), ShopCode.SHOP_FAIL.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_SUCCESS.getSuccess(), ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支付回调"><a href="#支付回调" class="headerlink" title="支付回调"></a>支付回调</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/12-zhi-fu-hou-hui-diao.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">callbackPayment</span><span class="params">(TradePay tradePay)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tradePay.getIsPaid().equals(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode())) &#123;</span><br><span class="line">        tradePay = tradePayMapper.selectByPrimaryKey(tradePay.getPayId());</span><br><span class="line">        <span class="keyword">if</span> (tradePay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_PAYMENT_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        tradePay.setIsPaid(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode());</span><br><span class="line">        <span class="keyword">int</span> i = tradePayMapper.updateByPrimaryKeySelective(tradePay);</span><br><span class="line">        <span class="comment">//更新成功代表支付成功</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            TradeMqProducerTemp mqProducerTemp = <span class="keyword">new</span> TradeMqProducerTemp();</span><br><span class="line">            mqProducerTemp.setId(String.valueOf(idWorker.nextId()));</span><br><span class="line">            mqProducerTemp.setGroupName(<span class="string">"payProducerGroup"</span>);</span><br><span class="line">            mqProducerTemp.setMsgKey(String.valueOf(tradePay.getPayId()));</span><br><span class="line">            mqProducerTemp.setMsgTag(topic);</span><br><span class="line">            mqProducerTemp.setMsgBody(JSON.toJSONString(tradePay));</span><br><span class="line">            mqProducerTemp.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">            mqProducerTempMapper.insert(mqProducerTemp);</span><br><span class="line">            TradePay finalTradePay = tradePay;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        SendResult sendResult = sendMessage(topic, </span><br><span class="line">                                                            tag, </span><br><span class="line">                                                            finalTradePay.getPayId(), </span><br><span class="line">                                                            JSON.toJSONString(finalTradePay));</span><br><span class="line">                        log.info(JSON.toJSONString(sendResult));</span><br><span class="line">                        <span class="keyword">if</span> (SendStatus.SEND_OK.equals(sendResult.getSendStatus())) &#123;</span><br><span class="line">                            mqProducerTempMapper.deleteByPrimaryKey(mqProducerTemp.getId());</span><br><span class="line">                            System.out.println(<span class="string">"删除消息表成功"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            CastException.cast(ShopCode.SHOP_PAYMENT_IS_PAID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(ShopCode.SHOP_SUCCESS.getSuccess(), ShopCode.SHOP_SUCCESS.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池优化消息发送逻辑"><a href="#线程池优化消息发送逻辑" class="headerlink" title="线程池优化消息发送逻辑"></a>线程池优化消息发送逻辑</h4><ul><li>创建线程池对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">getThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line"></span><br><span class="line">    executor.setCorePoolSize(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    executor.setMaxPoolSize(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">"Pool-A"</span>);</span><br><span class="line"></span><br><span class="line">    executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    executor.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用线程池</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ThreadPoolTaskExecutor executorService;</span><br><span class="line"></span><br><span class="line">executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SendResult sendResult = sendMessage(topic, tag, finalTradePay.getPayId(), JSON.toJSONString(finalTradePay));</span><br><span class="line">            log.info(JSON.toJSONString(sendResult));</span><br><span class="line">            <span class="keyword">if</span> (SendStatus.SEND_OK.equals(sendResult.getSendStatus())) &#123;</span><br><span class="line">                mqProducerTempMapper.deleteByPrimaryKey(mqProducerTemp.getId());</span><br><span class="line">                System.out.println(<span class="string">"删除消息表成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="处理消息"><a href="#处理消息" class="headerlink" title="处理消息"></a>处理消息</h3><p>支付成功后，支付服务payService发送MQ消息，订单服务、用户服务、日志服务需要订阅消息进行处理</p><ol><li>订单服务修改订单状态为已支付</li><li>日志服务记录支付日志</li><li>用户服务负责给用户增加积分</li></ol><p>以下用订单服务为例说明消息的处理情况</p><h4 id="配置RocketMQ属性值"><a href="#配置RocketMQ属性值" class="headerlink" title="配置RocketMQ属性值"></a>配置RocketMQ属性值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mq.pay.topic=payTopic</span><br><span class="line">mq.pay.consumer.group.name=pay_payTopic_group</span><br></pre></td></tr></table></figure><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><ul><li>在订单服务中，配置公共的消息处理类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TradeOrder <span class="title">handleMessage</span><span class="params">(IOrderService </span></span></span><br><span class="line"><span class="function"><span class="params">                                    orderService, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    MessageExt messageExt,Integer code)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//解析消息内容</span></span><br><span class="line">        String body = <span class="keyword">new</span> String(messageExt.getBody(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        String msgId = messageExt.getMsgId();</span><br><span class="line">        String tags = messageExt.getTags();</span><br><span class="line">        String keys = messageExt.getKeys();</span><br><span class="line">        OrderMQ orderMq = JSON.parseObject(body, OrderMQ.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询</span></span><br><span class="line">        TradeOrder order = orderService.findOne(orderMq.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ShopCode.SHOP_ORDER_MESSAGE_STATUS_CANCEL.getCode().equals(code))&#123;</span><br><span class="line">            order.setOrderStatus(ShopCode.SHOP_ORDER_CANCEL.getCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ShopCode.SHOP_ORDER_MESSAGE_STATUS_ISPAID.getCode().equals(code))&#123;</span><br><span class="line">            order.setPayStatus(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode());</span><br><span class="line">        &#125;</span><br><span class="line">        orderService.changeOrderStatus(order);</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接受订单支付成功消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener</span>(topic = <span class="string">"$&#123;mq.pay.topic&#125;"</span>, </span><br><span class="line">                         consumerGroup = <span class="string">"$&#123;mq.pay.consumer.group.name&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayConsumer</span> <span class="keyword">extends</span> <span class="title">BaseConsumer</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageExt</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"CancelOrderProcessor receive message:"</span>+messageExt);</span><br><span class="line">            TradeOrder order = handleMessage(orderService, </span><br><span class="line">                                             messageExt, </span><br><span class="line">                                             ShopCode.SHOP_ORDER_MESSAGE_STATUS_ISPAID.getCode());</span><br><span class="line">            log.info(<span class="string">"订单:["</span>+order.getOrderId()+<span class="string">"]支付成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.error(<span class="string">"订单支付失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整体联调"><a href="#整体联调" class="headerlink" title="整体联调"></a>整体联调</h1><p>通过Rest客户端请求shop-order-web和shop-pay-web完成下单和支付操作</p><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="配置RestTemplate类"><a href="#配置RestTemplate类" class="headerlink" title="配置RestTemplate类"></a>配置RestTemplate类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123; RestOperations.class, RestTemplate.class &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(ClientHttpRequestFactory factory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 utf-8 编码集的 conver 替换默认的 conver（默认的 string conver 的编码集为"ISO-8859-1"）</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();</span><br><span class="line">        Iterator&lt;HttpMessageConverter&lt;?&gt;&gt; iterator = messageConverters.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            HttpMessageConverter&lt;?&gt; converter = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> StringHttpMessageConverter) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;ClientHttpRequestFactory.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">simpleClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleClientHttpRequestFactory factory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">        <span class="comment">// ms</span></span><br><span class="line">        factory.setReadTimeout(<span class="number">15000</span>);</span><br><span class="line">        <span class="comment">// ms</span></span><br><span class="line">        factory.setConnectTimeout(<span class="number">15000</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置请求地址"><a href="#配置请求地址" class="headerlink" title="配置请求地址"></a>配置请求地址</h3><ul><li>订单系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.host=http://localhost</span><br><span class="line">server.servlet.path=/order-web</span><br><span class="line">server.port=8080</span><br><span class="line">shop.order.baseURI=$&#123;server.host&#125;:$&#123;server.port&#125;$&#123;server.servlet.path&#125;</span><br><span class="line">shop.order.confirm=/order/confirm</span><br></pre></td></tr></table></figure><ul><li>支付系统</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server.host=http://localhost</span><br><span class="line">server.servlet.path=/pay-web</span><br><span class="line">server.port=9090</span><br><span class="line">shop.pay.baseURI=$&#123;server.host&#125;:$&#123;server.port&#125;$&#123;server.servlet.path&#125;</span><br><span class="line">shop.pay.createPayment=/pay/createPayment</span><br><span class="line">shop.pay.callbackPayment=/pay/callbackPayment</span><br></pre></td></tr></table></figure><h2 id="下单测试"><a href="#下单测试" class="headerlink" title="下单测试"></a>下单测试</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = ShopOrderWebApplication.class)</span><br><span class="line"><span class="meta">@TestPropertySource</span>(<span class="string">"classpath:application.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;shop.order.baseURI&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String baseURI;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;shop.order.confirm&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String confirmOrderPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDWorker idWorker;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirmOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long goodsId=XXXL;</span><br><span class="line">        Long userId=XXXL;</span><br><span class="line">        Long couponId=XXXL;</span><br><span class="line"></span><br><span class="line">        TradeOrder order = <span class="keyword">new</span> TradeOrder();</span><br><span class="line">        order.setGoodsId(goodsId);</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line">        order.setGoodsNumber(<span class="number">1</span>);</span><br><span class="line">        order.setAddress(<span class="string">"北京"</span>);</span><br><span class="line">        order.setGoodsPrice(<span class="keyword">new</span> BigDecimal(<span class="string">"5000"</span>));</span><br><span class="line">        order.setOrderAmount(<span class="keyword">new</span> BigDecimal(<span class="string">"5000"</span>));</span><br><span class="line">        order.setMoneyPaid(<span class="keyword">new</span> BigDecimal(<span class="string">"100"</span>));</span><br><span class="line">        order.setCouponId(couponId);</span><br><span class="line">        order.setShippingFee(<span class="keyword">new</span> BigDecimal(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        Result result = restTemplate.postForEntity(baseURI + confirmOrderPath, order, Result.class).getBody();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支付测试"><a href="#支付测试" class="headerlink" title="支付测试"></a>支付测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = ShopPayWebApplication.class)</span><br><span class="line"><span class="meta">@TestPropertySource</span>(<span class="string">"classpath:application.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;shop.pay.baseURI&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String baseURI;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;shop.pay.createPayment&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String createPaymentPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;shop.pay.callbackPayment&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String callbackPaymentPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IDWorker idWorker;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建支付订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPayment</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Long orderId = <span class="number">346321587315814400L</span>;</span><br><span class="line">        TradePay pay = <span class="keyword">new</span> TradePay();</span><br><span class="line">        pay.setOrderId(orderId);</span><br><span class="line">        pay.setPayAmount(<span class="keyword">new</span> BigDecimal(<span class="number">4800</span>));</span><br><span class="line"></span><br><span class="line">        Result result = restTemplate.postForEntity(baseURI + createPaymentPath, pay, Result.class).getBody();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackPayment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long payId = <span class="number">346321891507720192L</span>;</span><br><span class="line">        TradePay pay = <span class="keyword">new</span> TradePay();</span><br><span class="line">        pay.setPayId(payId);</span><br><span class="line">        pay.setIsPaid(ShopCode.SHOP_ORDER_PAY_STATUS_IS_PAY.getCode());</span><br><span class="line">        Result result = restTemplate.postForEntity(baseURI + callbackPaymentPath, pay, Result.class).getBody();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 01 - 基础介绍</title>
      <link href="RocketMQ/middleware/rocketmq-01/"/>
      <url>RocketMQ/middleware/rocketmq-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>说明：本文档由《黑马程序员》整理，本人只是为了方便才整理到自己博客！！<br>相应视频资料：<a href="https://www.bilibili.com/video/BV1L4411y7mn?from=search&amp;seid=10733892066736275631" target="_blank" rel="noopener">RocketMQ系统精讲</a></p></blockquote><h1 id="MQ介绍"><a href="#MQ介绍" class="headerlink" title="MQ介绍"></a>MQ介绍</h1><h2 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h2><p>消息队列是一种“先进先出”的数据结构</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/queue1.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><a id="more"></a><p>其应用场景主要包含以下3个方面</p><ul><li>应用解耦</li></ul><p>系统的耦合性越高，容错性就越低。以电商应用为例，用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障或者因为升级等原因暂时不可用，都会造成下单操作异常，影响用户使用体验。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/jie-ou1.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="300" alt title></p><p>使用消息队列解耦合，系统的耦合性就会提高了。比如物流系统发生故障，需要几分钟才能来修复，在这段时间内，物流系统要处理的数据被缓存到消息队列中，用户的下单操作正常完成。当物流系统回复后，补充处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/jie-ou2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><ul><li>流量削峰</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mq5.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mq6.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>一般情况，为了保证系统的稳定性，如果系统负载超过阈值，就会阻止用户请求，这会影响用户体验，而如果使用消息队列将请求缓存起来，等待系统处理完毕后通知用户下单完毕，这样总不能下单体验要好。</p><p><u>处于经济考量目的：</u></p><p>业务系统正常时段的QPS如果是1000，流量最高峰是10000，为了应对流量高峰配置高性能的服务器显然不划算，这时可以使用消息队列对峰值流量削峰</p><ul><li>数据分发</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mq1.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>通过消息队列可以让数据在多个系统更加之间进行流通。数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据即可</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mq2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="MQ的优点和缺点"><a href="#MQ的优点和缺点" class="headerlink" title="MQ的优点和缺点"></a>MQ的优点和缺点</h2><p>优点：解耦、削峰、数据分发</p><p>缺点包含以下几点：</p><ul><li><p>系统可用性降低</p><p>系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。</p><p>如何保证MQ的高可用？</p></li><li><p>系统复杂度提高</p><p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。</p><p>如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。</p><p>如何保证消息数据处理的一致性？</p></li></ul><h2 id="各种MQ产品的比较"><a href="#各种MQ产品的比较" class="headerlink" title="各种MQ产品的比较"></a>各种MQ产品的比较</h2><p>常见的MQ产品包括Kafka、ActiveMQ、RabbitMQ、RocketMQ。 </p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/mq-bi-jiao.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h1 id="RocketMQ快速入门"><a href="#RocketMQ快速入门" class="headerlink" title="RocketMQ快速入门"></a>RocketMQ快速入门</h1><p>RocketMQ是阿里巴巴2016年MQ中间件，使用Java语言开发，在阿里内部，RocketMQ承接了例如“双11”等高并发场景的消息流转，能够处理万亿级别的消息。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="下载RocketMQ"><a href="#下载RocketMQ" class="headerlink" title="下载RocketMQ"></a>下载RocketMQ</h3><p>RocketMQ最新版本：4.5.1</p><p><a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.5.1/rocketmq-all-4.5.1-bin-release.zip" target="_blank" rel="noopener">下载地址</a></p><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><ul><li><p>Linux64位系统</p></li><li><p>JDK1.8(64位)</p></li><li><p>源码安装需要安装Maven 3.2.x</p></li></ul><h2 id="安装RocketMQ"><a href="#安装RocketMQ" class="headerlink" title="安装RocketMQ"></a>安装RocketMQ</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>本教程以二进制包方式安装</p><ol><li>解压安装包</li><li>进入安装目录</li></ol><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul><li>bin：启动脚本，包括shell脚本和CMD脚本</li><li>conf：实例配置文件 ，包括broker配置文件、logback配置文件等</li><li>lib：依赖jar包，包括Netty、commons-lang、FastJSON等</li></ul><h2 id="启动RocketMQ"><a href="#启动RocketMQ" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h2><ol><li>启动NameServer</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.启动NameServer</span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta">#</span> 2.查看启动日志</span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><ol><li>启动Broker</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.启动Broker</span><br><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="meta">#</span> 2.查看启动日志</span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><ul><li><p>问题描述：</p><p>RocketMQ默认的虚拟机内存较大，启动Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 编辑runbroker.sh和runserver.sh修改默认JVM大小</span><br><span class="line">vi runbroker.sh</span><br><span class="line">vi runserver.sh</span><br></pre></td></tr></table></figure><ul><li>参考设置：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 测试RocketMQ</span><br><span class="line"></span><br><span class="line">### 发送消息</span><br><span class="line"></span><br><span class="line">```sh</span><br><span class="line"># 1.设置环境变量</span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"># 2.使用安装包的Demo发送消息</span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.设置环境变量</span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta">#</span> 2.接收消息</span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><h2 id="关闭RocketMQ"><a href="#关闭RocketMQ" class="headerlink" title="关闭RocketMQ"></a>关闭RocketMQ</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1.关闭NameServer</span><br><span class="line">sh bin/mqshutdown namesrv</span><br><span class="line"><span class="meta">#</span> 2.关闭Broker</span><br><span class="line">sh bin/mqshutdown broker</span><br></pre></td></tr></table></figure><h1 id="RocketMQ集群搭建"><a href="#RocketMQ集群搭建" class="headerlink" title="RocketMQ集群搭建"></a>RocketMQ集群搭建</h1><h2 id="各角色介绍"><a href="#各角色介绍" class="headerlink" title="各角色介绍"></a>各角色介绍</h2><ul><li>Producer：消息的发送者；举例：发信者</li><li>Consumer：消息接收者；举例：收信者</li><li>Broker：暂存和传输消息；举例：邮局</li><li>NameServer：管理Broker；举例：各个邮局的管理机构</li><li>Topic：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者可以订阅一个或者多个Topic消息</li><li>Message Queue：相当于是Topic的分区；用于并行发送和接收消息</li></ul><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/rocketmq-jiao-se.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="集群搭建方式"><a href="#集群搭建方式" class="headerlink" title="集群搭建方式"></a>集群搭建方式</h2><h3 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h3><ul><li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p></li><li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li><li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</li></ul><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><h4 id="单Master模式"><a href="#单Master模式" class="headerlink" title="单Master模式"></a>单Master模式</h4><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p><h4 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h4><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p><ul><li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li><li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li></ul><h4 id="多Master多Slave模式（异步）"><a href="#多Master多Slave模式（异步）" class="headerlink" title="多Master多Slave模式（异步）"></a>多Master多Slave模式（异步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p><ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li><li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li></ul><h4 id="多Master多Slave模式（同步）"><a href="#多Master多Slave模式（同步）" class="headerlink" title="多Master多Slave模式（同步）"></a>多Master多Slave模式（同步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p><ul><li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li><li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li></ul><h2 id="双主双从集群搭建"><a href="#双主双从集群搭建" class="headerlink" title="双主双从集群搭建"></a>双主双从集群搭建</h2><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p>消息高可用采用2m-2s（同步双写）方式</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/rocketmq-ji-qun.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h3 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h3><ol><li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li><li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li><li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li><li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li></ol><h3 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h3><div class="table-container"><table><thead><tr><th><strong>序号</strong></th><th><strong>IP</strong></th><th><strong>角色</strong></th><th><strong>架构模式</strong></th></tr></thead><tbody><tr><td>1</td><td>192.168.25.135</td><td>nameserver、brokerserver</td><td>Master1、Slave2</td></tr><tr><td>2</td><td>192.168.25.138</td><td>nameserver、brokerserver</td><td>Master2、Slave1</td></tr></tbody></table></div><h3 id="Host添加信息"><a href="#Host添加信息" class="headerlink" title="Host添加信息"></a>Host添加信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nameserver</span></span><br><span class="line">192.168.25.135 rocketmq-nameserver1</span><br><span class="line">192.168.25.138 rocketmq-nameserver2</span><br><span class="line"><span class="comment"># broker</span></span><br><span class="line">192.168.25.135 rocketmq-master1</span><br><span class="line">192.168.25.135 rocketmq-slave2</span><br><span class="line">192.168.25.138 rocketmq-master2</span><br><span class="line">192.168.25.138 rocketmq-slave1</span><br></pre></td></tr></table></figure><p>配置完成后, 重启网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p>宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld.service </span><br><span class="line"><span class="comment"># 查看防火墙的状态</span></span><br><span class="line">firewall-cmd --state </span><br><span class="line"><span class="comment"># 禁止firewall开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure><p>或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</p><ul><li><code>nameserver</code> 默认使用 9876 端口</li><li><code>master</code> 默认使用 10911 端口</li><li><code>slave</code> 默认使用11011 端口</li></ul><p>执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放name server默认端口</span></span><br><span class="line">firewall-cmd --remove-port=9876/tcp --permanent</span><br><span class="line"><span class="comment"># 开放master默认端口</span></span><br><span class="line">firewall-cmd --remove-port=10911/tcp --permanent</span><br><span class="line"><span class="comment"># 开放slave默认端口 (当前集群模式可不开启)</span></span><br><span class="line">firewall-cmd --remove-port=11011/tcp --permanent </span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在profile文件的末尾加入如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set rocketmq</span></span><br><span class="line">ROCKETMQ_HOME=/usr/<span class="built_in">local</span>/rocketmq/rocketmq-all-4.4.0-bin-release</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$ROCKETMQ_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> ROCKETMQ_HOME PATH</span><br></pre></td></tr></table></figure><p>输入:wq! 保存并退出， 并使得配置立刻生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="创建消息存储路径"><a href="#创建消息存储路径" class="headerlink" title="创建消息存储路径"></a>创建消息存储路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store/index</span><br></pre></td></tr></table></figure><h3 id="broker配置文件"><a href="#broker配置文件" class="headerlink" title="broker配置文件"></a>broker配置文件</h3><h4 id="master1"><a href="#master1" class="headerlink" title="master1"></a>master1</h4><p>服务器：192.168.25.135</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-a.properties</span><br></pre></td></tr></table></figure><p>修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker<span class="_">-a</span></span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h4 id="slave2"><a href="#slave2" class="headerlink" title="slave2"></a>slave2</h4><p>服务器：192.168.25.135</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b-s.properties</span><br></pre></td></tr></table></figure><p>修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h4 id="master2"><a href="#master2" class="headerlink" title="master2"></a>master2</h4><p>服务器：192.168.25.138</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker-b.properties</span><br></pre></td></tr></table></figure><p>修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=SYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h4 id="slave1"><a href="#slave1" class="headerlink" title="slave1"></a>slave1</h4><p>服务器：192.168.25.138</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/soft/rocketmq/conf/2m-2s-sync/broker<span class="_">-a</span>-s.properties</span><br></pre></td></tr></table></figure><p>修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker<span class="_">-a</span></span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=1</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=11011</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><h3 id="修改启动脚本文件"><a href="#修改启动脚本文件" class="headerlink" title="修改启动脚本文件"></a>修改启动脚本文件</h3><h4 id="runbroker-sh"><a href="#runbroker-sh" class="headerlink" title="runbroker.sh"></a>runbroker.sh</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/rocketmq/bin/runbroker.sh</span><br></pre></td></tr></table></figure><p>需要根据内存大小进行适当的对JVM参数进行调整：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#===================================================</span></span><br><span class="line"><span class="comment"># 开发环境配置 JVM Configuration</span></span><br><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m"</span></span><br></pre></td></tr></table></figure><h4 id="runserver-sh"><a href="#runserver-sh" class="headerlink" title="runserver.sh"></a>runserver.sh</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/rocketmq/bin/runserver.sh</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPT=<span class="string">"<span class="variable">$&#123;JAVA_OPT&#125;</span> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></td></tr></table></figure><h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><h4 id="启动NameServe集群"><a href="#启动NameServe集群" class="headerlink" title="启动NameServe集群"></a>启动NameServe集群</h4><p>分别在192.168.25.135和192.168.25.138启动NameServer</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure><h4 id="启动Broker集群"><a href="#启动Broker集群" class="headerlink" title="启动Broker集群"></a>启动Broker集群</h4><ul><li>在192.168.25.135上启动master1和slave2</li></ul><p>master1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-syncbroker-a.properties &amp;</span><br></pre></td></tr></table></figure><p>slave2：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure><ul><li>在192.168.25.138上启动master2和slave2</li></ul><p>master2</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker-b.properties &amp;</span><br></pre></td></tr></table></figure><p>slave1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/rocketmq/bin</span><br><span class="line">nohup sh mqbroker -c /usr/<span class="built_in">local</span>/rocketmq/conf/2m-2s-sync/broker<span class="_">-a</span>-s.properties &amp;</span><br></pre></td></tr></table></figure><h3 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h3><p>启动后通过JPS查看启动进程</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/jps1.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看nameServer日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="comment"># 查看broker日志</span></span><br><span class="line">tail -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>几乎所有命令都需要配置-n表示NameServer地址，格式为ip:port</li><li>几乎所有命令都可以通过-h获取帮助</li><li>如果既有Broker地址（-b）配置项又有clusterName（-c）配置项，则优先以Broker地址执行命令；如果不配置Broker地址，则对集群中所有主机执行命令</li></ul><h2 id="集群监控平台搭建"><a href="#集群监控平台搭建" class="headerlink" title="集群监控平台搭建"></a>集群监控平台搭建</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>RocketMQ</code>有一个对其扩展的开源项目<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，先将<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">incubator-rocketmq-externals</a>拉到本地，因为我们需要自己对<code>rocketmq-console</code>进行编译打包运行。</p><h3 id="下载并编译打包"><a href="#下载并编译打包" class="headerlink" title="下载并编译打包"></a>下载并编译打包</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/rocketmq-externals</span><br><span class="line"><span class="built_in">cd</span> rocketmq-console</span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>注意：打包前在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```sh</span><br><span class="line">rocketmq.config.namesrvAddr=192.168.25.135:9876;192.168.25.138:9876</span><br></pre></td></tr></table></figure></p><p>启动rocketmq-console：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了，如下图：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/rocketmqconsole2.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>集群状态：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/rocketmqconsole3.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h1 id="消息发送样例"><a href="#消息发送样例" class="headerlink" title="消息发送样例"></a>消息发送样例</h1><ul><li>导入MQ客户端依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>消息发送者步骤分析r</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建消息生产者producer，并制定生产者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.启动producer</span><br><span class="line">4.创建消息对象，指定主题Topic、Tag和消息体</span><br><span class="line">5.发送消息</span><br><span class="line">6.关闭生产者producer</span><br></pre></td></tr></table></figure><ul><li>消息消费者步骤分析</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建消费者Consumer，制定消费者组名</span><br><span class="line">2.指定Nameserver地址</span><br><span class="line">3.订阅主题Topic和Tag</span><br><span class="line">4.设置回调函数，处理消息</span><br><span class="line">5.启动消费者consumer</span><br></pre></td></tr></table></figure><h2 id="基本样例"><a href="#基本样例" class="headerlink" title="基本样例"></a>基本样例</h2><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><h4 id="发送同步消息"><a href="#发送同步消息" class="headerlink" title="发送同步消息"></a>发送同步消息</h4><p>这种可靠性同步地发送方式使用的比较广泛，比如：重要的消息通知，短信通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">    producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">        <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 发送消息到一个Broker</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            <span class="comment">// 通过sendResult返回消息是否成功送达</span></span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送异步消息"><a href="#发送异步消息" class="headerlink" title="发送异步消息"></a>发送异步消息</h4><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">// SendCallback接收异步返回结果的回调</span></span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                    System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者Producer</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">    <span class="comment">// 设置NameServer的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 启动Producer实例</span></span><br><span class="line">        producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建消息，并指定Topic，Tag和消息体</span></span><br><span class="line">        Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 发送单向消息，没有任何返回结果</span></span><br><span class="line">        producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不再发送消息，关闭Producer实例。</span></span><br><span class="line">    producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><h4 id="负载均衡模式"><a href="#负载均衡模式" class="headerlink" title="负载均衡模式"></a>负载均衡模式</h4><p>消费者采用负载均衡方式消费消息，多个消费者共同消费队列消息，每个消费者处理的消息不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic</span></span><br><span class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//负载均衡模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><p>消费者采用广播的方式消费消息，每个消费者消费的消息都是相同的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化消息生产者,指定组名</span></span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"group1"</span>);</span><br><span class="line">    <span class="comment">// 指定Namesrv地址信息.</span></span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">"localhost:9876"</span>);</span><br><span class="line">    <span class="comment">// 订阅Topic</span></span><br><span class="line">    consumer.subscribe(<span class="string">"Test"</span>, <span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">//广播模式消费</span></span><br><span class="line">    consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">    <span class="comment">// 注册回调函数，处理消息</span></span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s Receive New Messages: %s %n"</span>, </span><br><span class="line">                              Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//启动消息者</span></span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">"Consumer Started.%n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p><p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p><p>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是同一个队列。</p><h3 id="顺序消息生产"><a href="#顺序消息生产" class="headerlink" title="顺序消息生产"></a>顺序消息生产</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Producer，发送顺序消息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">       producer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line"></span><br><span class="line">       producer.start();</span><br><span class="line"></span><br><span class="line">       String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 订单列表</span></span><br><span class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> Producer().buildOrders();</span><br><span class="line"></span><br><span class="line">       Date date = <span class="keyword">new</span> Date();</span><br><span class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       String dateStr = sdf.format(date);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 加个时间前缀</span></span><br><span class="line">           String body = dateStr + <span class="string">" Hello RocketMQ "</span> + orderList.get(i);</span><br><span class="line">           Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i, body.getBytes());</span><br><span class="line"></span><br><span class="line">           SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">                   Long id = (Long) arg;  <span class="comment">//根据订单id选择发送queue</span></span><br><span class="line">                   <span class="keyword">long</span> index = id % mqs.size();</span><br><span class="line">                   <span class="keyword">return</span> mqs.get((<span class="keyword">int</span>) index);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, orderList.get(i).getOrderId());<span class="comment">//订单id</span></span><br><span class="line"></span><br><span class="line">           System.out.println(String.format(<span class="string">"SendResult status:%s, queueId:%d, body:%s"</span>,</span><br><span class="line">               sendResult.getSendStatus(),</span><br><span class="line">               sendResult.getMessageQueue().getQueueId(),</span><br><span class="line">               body));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       producer.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 订单的步骤</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStep</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">long</span> orderId;</span><br><span class="line">       <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> orderId;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">long</span> orderId)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> desc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.desc = desc;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"OrderStep&#123;"</span> +</span><br><span class="line">               <span class="string">"orderId="</span> + orderId +</span><br><span class="line">               <span class="string">", desc='"</span> + desc + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成模拟订单数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;OrderStep&gt; <span class="title">buildOrders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       List&lt;OrderStep&gt; orderList = <span class="keyword">new</span> ArrayList&lt;OrderStep&gt;();</span><br><span class="line"></span><br><span class="line">       OrderStep orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"创建"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"付款"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111065L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"推送"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103117235L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       orderDemo = <span class="keyword">new</span> OrderStep();</span><br><span class="line">       orderDemo.setOrderId(<span class="number">15103111039L</span>);</span><br><span class="line">       orderDemo.setDesc(<span class="string">"完成"</span>);</span><br><span class="line">       orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> orderList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序消费消息"><a href="#顺序消费消息" class="headerlink" title="顺序消费消息"></a>顺序消费消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 顺序消息消费，带事务方式（应用可控制Offset什么时候提交）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerInOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       DefaultMQPushConsumer consumer = <span class="keyword">new</span> </span><br><span class="line">           DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_3"</span>);</span><br><span class="line">       consumer.setNamesrvAddr(<span class="string">"127.0.0.1:9876"</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span></span><br><span class="line"><span class="comment">        * 如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">       consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"TagA || TagC || TagD"</span>);</span><br><span class="line"></span><br><span class="line">       consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line"></span><br><span class="line">           Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">               context.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">               <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                   <span class="comment">// 可以看到每个queue有唯一的consume线程来消费, 订单对每个queue(分区)有序</span></span><br><span class="line">                   System.out.println(<span class="string">"consumeThread="</span> + Thread.currentThread().getName() + <span class="string">"queueId="</span> + msg.getQueueId() + <span class="string">", content:"</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//模拟业务逻辑处理中...</span></span><br><span class="line">                   TimeUnit.SECONDS.sleep(random.nextInt(<span class="number">10</span>));</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       consumer.start();</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"Consumer Started."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h2><p>比如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的状态，如果还是未付款就取消订单释放库存。</p><h3 id="启动消息消费者"><a href="#启动消息消费者" class="headerlink" title="启动消息消费者"></a>启动消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageConsumer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化消费者</span></span><br><span class="line">      DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"ExampleConsumer"</span>);</span><br><span class="line">      <span class="comment">// 订阅Topics</span></span><br><span class="line">      consumer.subscribe(<span class="string">"TestTopic"</span>, <span class="string">"*"</span>);</span><br><span class="line">      <span class="comment">// 注册消息监听者</span></span><br><span class="line">      consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; messages, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (MessageExt message : messages) &#123;</span><br><span class="line">                  <span class="comment">// Print approximate delay time period</span></span><br><span class="line">                  System.out.println(<span class="string">"Receive message[msgId="</span> + message.getMsgId() + <span class="string">"] "</span> + (System.currentTimeMillis() - message.getStoreTimestamp()) + <span class="string">"ms later"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 启动消费者</span></span><br><span class="line">      consumer.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledMessageProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line">      DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">      <span class="comment">// 启动生产者</span></span><br><span class="line">      producer.start();</span><br><span class="line">      <span class="keyword">int</span> totalMessagesToSend = <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">          Message message = <span class="keyword">new</span> Message(<span class="string">"TestTopic"</span>, (<span class="string">"Hello scheduled message "</span> + i).getBytes());</span><br><span class="line">          <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间,详看delayTimeLevel)</span></span><br><span class="line">          message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">          <span class="comment">// 发送消息</span></span><br><span class="line">          producer.send(message);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 关闭生产者</span></span><br><span class="line">      producer.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>您将会看到消息的消费比存储时间晚10秒</p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org/apache/rocketmq/store/config/MessageStoreConfig.java</span></span><br><span class="line"><span class="keyword">private</span> String messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure><p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</p><h3 id="发送批量消息"><a href="#发送批量消息" class="headerlink" title="发送批量消息"></a>发送批量消息</h3><p>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String topic = <span class="string">"BatchTest"</span>;</span><br><span class="line">List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID001"</span>, <span class="string">"Hello world 0"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID002"</span>, <span class="string">"Hello world 1"</span>.getBytes()));</span><br><span class="line">messages.add(<span class="keyword">new</span> Message(topic, <span class="string">"TagA"</span>, <span class="string">"OrderID003"</span>, <span class="string">"Hello world 2"</span>.getBytes()));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   producer.send(messages);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">   <span class="comment">//处理error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果消息的总长度可能大于4MB时，这时候最好把消息进行分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListSplitter</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">List</span>&lt;<span class="title">Message</span>&gt;&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE_LIMIT = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Message&gt; messages;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> currIndex;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ListSplitter</span><span class="params">(List&lt;Message&gt; messages)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.messages = messages;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currIndex &lt; messages.size();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Message&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextIndex = currIndex;</span><br><span class="line">       <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">           Message message = messages.get(nextIndex);</span><br><span class="line">           <span class="keyword">int</span> tmpSize = message.getTopic().length() + message.getBody().length;</span><br><span class="line">           Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">               tmpSize += entry.getKey().length() + entry.getValue().length();</span><br><span class="line">           &#125;</span><br><span class="line">           tmpSize = tmpSize + <span class="number">20</span>; <span class="comment">// 增加日志的开销20字节</span></span><br><span class="line">           <span class="keyword">if</span> (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="comment">//单个消息超过了最大的限制</span></span><br><span class="line">               <span class="comment">//忽略,否则会阻塞分裂的进程</span></span><br><span class="line">               <span class="keyword">if</span> (nextIndex - currIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">//假如下一个子列表没有元素,则添加这个子列表然后退出循环,否则只是退出循环</span></span><br><span class="line">                  nextIndex++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               totalSize += tmpSize;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">       currIndex = nextIndex;</span><br><span class="line">       <span class="keyword">return</span> subList;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把大的消息分裂成若干个小的消息</span></span><br><span class="line">ListSplitter splitter = <span class="keyword">new</span> ListSplitter(messages);</span><br><span class="line"><span class="keyword">while</span> (splitter.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;Message&gt;  listItem = splitter.next();</span><br><span class="line">      producer.send(listItem);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="comment">//处理error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h2><p>在大多数情况下，TAG是一个简单而有用的设计，其可以来选择您想要的消息。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"CID_EXAMPLE"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"TOPIC"</span>, <span class="string">"TAGA || TAGB || TAGC"</span>);</span><br></pre></td></tr></table></figure><p>消费者将接收包含TAGA或TAGB或TAGC的消息。但是限制是一个消息只能有一个标签，这对于复杂的场景可能不起作用。在这种情况下，可以使用SQL表达式筛选消息。SQL特性可以通过发送消息时的属性来进行计算。在RocketMQ定义的语法下，可以实现一些简单的逻辑。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|  a &gt; 5 AND b = &apos;abc&apos;</span><br><span class="line">| a = 10   |  --------------------&gt; Gotten</span><br><span class="line">| b = &apos;abc&apos;|</span><br><span class="line">| c = true |</span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line">| message  |</span><br><span class="line">|----------|   a &gt; 5 AND b = &apos;abc&apos;</span><br><span class="line">| a = 1    |  --------------------&gt; Missed</span><br><span class="line">| b = &apos;abc&apos;|</span><br><span class="line">| c = true |</span><br><span class="line">------------</span><br></pre></td></tr></table></figure><h3 id="SQL基本语法"><a href="#SQL基本语法" class="headerlink" title="SQL基本语法"></a>SQL基本语法</h3><p>RocketMQ只定义了一些基本语法来支持这个特性。你也可以很容易地扩展它。</p><ul><li>数值比较，比如：<strong>&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=；</strong></li><li>字符比较，比如：<strong>=，&lt;&gt;，IN；</strong></li><li><strong>IS NULL</strong> 或者 <strong>IS NOT NULL；</strong></li><li>逻辑符号 <strong>AND，OR，NOT；</strong></li></ul><p>常量支持类型为：</p><ul><li>数值，比如：<strong>123，3.1415；</strong></li><li>字符，比如：<strong>‘abc’，必须用单引号包裹起来；</strong></li><li><strong>NULL</strong>，特殊的常量</li><li>布尔值，<strong>TRUE</strong> 或 <strong>FALSE</strong></li></ul><p>只有使用push模式的消费者才能用使用SQL92标准的sql语句，接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(finalString topic, <span class="keyword">final</span> MessageSelector messageSelector)</span></span></span><br></pre></td></tr></table></figure><h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>发送消息时，你能通过<code>putUserProperty</code>来设置消息的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">producer.start();</span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">   tag,</span><br><span class="line">   (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 设置一些属性</span></span><br><span class="line">msg.putUserProperty(<span class="string">"a"</span>, String.valueOf(i));</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line"></span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure><h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>用MessageSelector.bySql来使用sql筛选消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"please_rename_unique_group_name_4"</span>);</span><br><span class="line"><span class="comment">// 只有订阅的消息有这个属性a, a &gt;=0 and a &lt;= 3</span></span><br><span class="line">consumer.subscribe(<span class="string">"TopicTest"</span>, MessageSelector.bySql(<span class="string">"a between 0 and 3"</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/03/shi-wu-xiao-xi.png?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p><h4 id="事务消息发送及提交"><a href="#事务消息发送及提交" class="headerlink" title="事务消息发送及提交"></a>事务消息发送及提交</h4><p>(1) 发送消息（half消息）。</p><p>(2) 服务端响应消息写入结果。</p><p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><h4 id="事务补偿"><a href="#事务补偿" class="headerlink" title="事务补偿"></a>事务补偿</h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p><p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p><p>(3) 根据本地事务状态，重新Commit或者Rollback</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><h4 id="事务消息状态"><a href="#事务消息状态" class="headerlink" title="事务消息状态"></a>事务消息状态</h4><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p><ul><li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li><li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li><li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li></ul><h3 id="发送事务消息"><a href="#发送事务消息" class="headerlink" title="发送事务消息"></a>发送事务消息</h3><h4 id="创建事务性生产者"><a href="#创建事务性生产者" class="headerlink" title="创建事务性生产者"></a>创建事务性生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建事务监听器</span></span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line">        <span class="comment">//创建消息生产者</span></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"group6"</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"192.168.25.135:9876;192.168.25.138:9876"</span>);</span><br><span class="line">        <span class="comment">//生产者这是监听器</span></span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        <span class="comment">//启动消息生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[]&#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TransactionTopic"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line">                System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现事务的监听接口"><a href="#实现事务的监听接口" class="headerlink" title="实现事务的监听接口"></a>实现事务的监听接口</h4><p>当发送半消息成功时，我们使用 <code>executeLocalTransaction</code> 方法来执行本地事务。它返回前一节中提到的三个事务状态之一。<code>checkLocalTranscation</code> 方法用于检查本地事务状态，并回应消息队列的检查请求。它也是返回前一节中提到的三个事务状态之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行本地事务"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagA"</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">"TagB"</span>, msg.getTags())) &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MQ检查消息Tag【"</span>+msg.getTags()+<span class="string">"】的本地事务执行结果"</span>);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用限制-1"><a href="#使用限制-1" class="headerlink" title="使用限制"></a>使用限制</h3><ol><li>事务消息不支持延时消息和批量消息。</li><li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li><li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li><li>事务性消息可能不止一次被检查或消费。</li><li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li><li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li></ol>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一 Before start kernel</title>
      <link href="LinuxKernel4-0-arm32/linuxkernel4.0/before-start-kernel/"/>
      <url>LinuxKernel4-0-arm32/linuxkernel4.0/before-start-kernel/</url>
      
        <content type="html"><![CDATA[<h1 id="Qemu-调试"><a href="#Qemu-调试" class="headerlink" title="Qemu 调试"></a>Qemu 调试</h1><blockquote><p>详见 《奔跑吧 Linux内核》，有详细的 Qemu 调试内核的过程。</p></blockquote><h2 id="Qemu-调试配置"><a href="#Qemu-调试配置" class="headerlink" title="Qemu 调试配置"></a>Qemu 调试配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 准备环境</span><br><span class="line">$ sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential git gdb-arm-none-eabi</span><br><span class="line"># 下载仓库</span><br><span class="line">$ git clone git@github.com:figozhang/runninglinuxkernel_4<span class="number">.0</span>.git</span><br><span class="line">$ git checkout rlk_basic</span><br><span class="line"># 编译内核</span><br><span class="line">$ cd runninglinuxkernel<span class="number">-4.0</span></span><br><span class="line">$ <span class="keyword">export</span> ARCH=arm</span><br><span class="line">$ <span class="keyword">export</span> CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line">$ make vexpress_defconfig</span><br><span class="line">$ make menuconfig</span><br><span class="line"># 在 _install_arm32/dev 下创建设备节点</span><br><span class="line">$ cd _install_arm32</span><br><span class="line">$ mkdir dev</span><br><span class="line">$ cd dev</span><br><span class="line">$ sudo mknod console c <span class="number">5</span> <span class="number">1</span></span><br><span class="line"># 开始编译</span><br><span class="line">$ make bzImage -j4</span><br><span class="line">$ make dtbs</span><br><span class="line"></span><br><span class="line"># 一个 session 打开 ， 退出 ctrl+a+x, killall qemu-system-arm</span><br><span class="line">$ ./run.sh arm32 debug </span><br><span class="line"></span><br><span class="line"># 另一个 session 调试</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Qemu-调试-mmu-之前"><a href="#Qemu-调试-mmu-之前" class="headerlink" title="Qemu 调试 mmu 之前"></a>Qemu 调试 mmu 之前</h2><p>在 Qemu 调试过程中分为两个阶段: mmu 启动前; mmu启动后。因此，必须要了解<strong>链接地址</strong>与<strong>装载地址</strong>之间的差别。<br>对于<code>vexpress</code>板子而言，其dts文件在<code>arch/arm/boot/dts/vexpress-v2p-ca9.dts</code>，其物理内存从0x6000_0000开始。</p><p>因此，为了能够调试 mmu 启动前的代码，需要将符号表加载到能够访问的物理地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arm-none-eabi-gdb --tui 启动调试</span></span><br><span class="line">$ target remote localhost:<span class="number">1234</span></span><br><span class="line">$ load vmlinux <span class="number">-0x60000000</span></span><br><span class="line">$ add-symbol-file vmlinux <span class="number">0x60008280</span> -s .head.text <span class="number">0x60008000</span> -s .rodata <span class="number">0x60b18000</span> </span><br><span class="line"><span class="comment">// 通过 arm-none-eabi-readelf -S vmlinux 查看对应的 .text off: 008280; .head.text off: 008000; .rodata off: b18000。</span></span><br><span class="line">$ <span class="built_in">set</span> $pc=<span class="number">0x60008000</span></span><br><span class="line">$ <span class="built_in">set</span> $r2=<span class="number">0x63200000</span>  <span class="comment">// 调试 dtb 时使用</span></span><br><span class="line">$ b stext</span><br><span class="line">$ c</span><br></pre></td></tr></table></figure><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>为什么需要关闭 MMU? 内核需要自己创建页表，在创建页表前，内核实际运行在物理地址，必须关闭 MMU。<br>为什么 D-cache 关闭？因为内核运行到 stext 时，若 D-cache 开始，则会从 cache 中获取数据，可能缓存 uboot 或 解压时留下的数据，这部分数据是无效的，可能导致数据异常。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15808044320368.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="200" alt title></p><blockquote><p>此时系统满足的条件</p><ul><li>MMU=off, D-cache=off, C-cache=don’t care</li><li>r0=0, r1=machine nr, r2=atags or dtb pointer</li></ul></blockquote><p>内核装载后，pc 指向 stext 所在物理地址 0x6000_8000，执行内核代码。此时，内核页表、c程序执行的堆栈、必要硬件配置还未设置完成，因此无法使用 c 语言程序，且只能使用地址无关的汇编代码(bl等)。</p><h1 id="开启-SVC-关闭中断"><a href="#开启-SVC-关闭中断" class="headerlink" title="开启 SVC 关闭中断"></a>开启 SVC 关闭中断</h1><p><a href="https://developer.arm.com/docs/ddi0595/b/aarch32-system-registers/cpsr" target="_blank" rel="noopener">cpsr 寄存器</a></p><h2 id="hyp-stub-install"><a href="#hyp-stub-install" class="headerlink" title="__hyp_stub_install"></a>__hyp_stub_install</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/hyp-stup.S:40</span></span><br><span class="line">.macrostore_primary_cpu_mode reg1, reg2, reg3</span><br><span class="line">mrs\reg1, cpsr</span><br><span class="line"><span class="keyword">and</span>\reg1, \reg1, #MODE_MASK @ MODE_MASK=<span class="number">1f</span>, 获取 cpsr低<span class="number">5</span>位数据</span><br><span class="line">adr\reg2, .L__boot_cpu_mode_offset @     读取 .L__boot_cpu_mode_offset 所在内存地址</span><br><span class="line">ldr\reg3, [\reg2] @ __boot_cpu_mode 存放地址</span><br><span class="line">str\reg1, [\reg2, \reg3] @ 将当前运行模式保存到 __boot_cpu_mode 之中</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>由上面代码分析可知，<code>store_primary_cpu_mode</code>所要做的事情便是从 <code>cpsr</code> 状态寄存器中读取 <code>boot</code> 启动后的运行模式，然后将其存储到 <code>__boot_cpu_mode</code> 变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/hyp-stup.S:54</span></span><br><span class="line">.macrocompare_cpu_mode_with_primary mode, reg1, reg2, reg3</span><br><span class="line">adr\reg2, .L__boot_cpu_mode_offset</span><br><span class="line">ldr\reg3, [\reg2]</span><br><span class="line">ldr\reg1, [\reg2, \reg3]</span><br><span class="line">cmp\mode, \reg1@ matches primary CPU boot mode?</span><br><span class="line">orrne\reg1, \reg1, #BOOT_CPU_MODE_MISMATCH @ 不等</span><br><span class="line">strne\reg1, [\reg2, \reg3]@ record what happened <span class="keyword">and</span> give up</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><p>比较运行模式是否与 __boot_cpu_mode 一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/hyp-stup.S:87</span></span><br><span class="line">ENTRY(__hyp_stub_install)</span><br><span class="line">    store_primary_cpu_mode r4, r5, r6</span><br><span class="line">ENDPROC(__hyp_stub_install)</span><br><span class="line">ENTRY(__hyp_stub_install_secondary)</span><br><span class="line">mrsr4, cpsr</span><br><span class="line"><span class="keyword">and</span>r4, r4, #MODE_MASK</span><br><span class="line">compare_cpu_mode_with_primaryr4, r5, r6, r7 @ 比较运行模式是否与 __boot_cpu_mode 一致</span><br><span class="line">retnelr</span><br><span class="line">cmpr4, #HYP_MODE</span><br><span class="line">retnelr@ give up <span class="keyword">if</span> the CPU is <span class="keyword">not</span> in HYP mode, 默认是 svc 模式，若当前为 HYP_MODE 则继续运行，但是在本案例中，默认启动为 svc</span><br></pre></td></tr></table></figure><p>综上，该函数做了两件事情：</p><ol><li>通过 <code>store_primary_cpu_mode</code> 设置 <code>__boot_cpu_mode</code> 变量</li><li>对比当前运行模式是否为 <code>__boot_cpu_mode</code></li></ol><h2 id="safe-svcmode-maskall"><a href="#safe-svcmode-maskall" class="headerlink" title="safe_svcmode_maskall"></a>safe_svcmode_maskall</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/asm/assembler.h</span></span><br><span class="line">.macro safe_svcmode_maskall reg:req</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_ARM_ARCH__ &gt;= 6 &amp;&amp; !defined(CONFIG_CPU_V7M)</span></span><br><span class="line">mrs\reg , cpsr</span><br><span class="line">eor\reg, \reg, #HYP_MODE</span><br><span class="line">tst\reg, #MODE_MASK</span><br><span class="line">bic\reg , \reg , #MODE_MASK @ 清<span class="number">0</span>位</span><br><span class="line">orr\reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE @ 设置 svc 模式以及关闭中断</span><br><span class="line">THUMB(orr\reg , \reg , #PSR_T_BIT)</span><br><span class="line">bne<span class="number">1f</span></span><br><span class="line">orr\reg, \reg, #PSR_A_BIT</span><br><span class="line">adrlr, BSYM(<span class="number">2f</span>)</span><br><span class="line">msrspsr_cxsf, \reg</span><br><span class="line">__MSR_ELR_HYP(<span class="number">14</span>)</span><br><span class="line">__ERET</span><br><span class="line"><span class="number">1</span>:msrcpsr_c, \reg @ 写入状态寄存器</span><br><span class="line"><span class="number">2</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/include/uapi/asm/ptrace.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SVC_MODE    0x00000013</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSR_F_BIT   0x00000040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSR_I_BIT   0x00000080</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最开始的两个函数，确保了程序运行在 svc 模式，并且关闭了中断。</p><p>其核心代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrs\reg , cpsr</span><br><span class="line">bic\reg , \reg , #MODE_MASK @ 清<span class="number">0</span>位</span><br><span class="line">orr\reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE @ 设置 svc 模式以及关闭中断</span><br><span class="line">msrcpsr_c, \reg @ 写入状态寄</span><br></pre></td></tr></table></figure></p><h1 id="获取-proc-info"><a href="#获取-proc-info" class="headerlink" title="获取 proc info"></a>获取 proc info</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/head.S: 98</span></span><br><span class="line">mrcp15, <span class="number">0</span>, r9, c0, c0@ get processor id, r9 记录 cpu 的信息</span><br><span class="line">bl__lookup_processor_type@ r5 = procinfo cpuid arch/arm/include/<span class="keyword">asm</span>/procinfo.h  struct proc_info_list 描述 cpu 信息, 定义在 arch/arm/mm/proc-v7.S</span><br><span class="line">movsr10, r5@ invalid processor (r5=<span class="number">0</span>)?</span><br><span class="line"> THUMB( iteq )@ force fixup-able <span class="keyword">long</span> branch encoding</span><br><span class="line">beq__error_p@ yes, error <span class="string">'p'</span></span><br></pre></td></tr></table></figure><h2 id="procinfo-前提知识"><a href="#procinfo-前提知识" class="headerlink" title="procinfo 前提知识"></a>procinfo 前提知识</h2><ol><li><p>说明<br>procinfo 使用<code>proc_info_list</code>结构体，用于说明一个 cpu 的信息，包括 cpu 的 ID 号，对应的内核数据映射区的 MMU 标志等。</p></li><li><p>数据结构定义<br>arch/arm/include/asm/procinfo.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_val; <span class="comment">// cpu id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cpu_mask; <span class="comment">// cpu id 掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __cpu_mm_mmu_flags;<span class="comment">/* used by head.S 临时页表映射的内核空间 MMU 标识 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __cpu_io_mmu_flags;<span class="comment">/* used by head.S IO 映射区的 MMU 标识 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __cpu_flush; <span class="comment">/* used by head.S CPU setup 函数的地址，后续在打开 MMU 过程中使用 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>         *arch_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>         *elf_name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>         elf_hwcap;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>         *cpu_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">processor</span>     *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span>   *<span class="title">tlb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span>  *<span class="title">user</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span> *<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>存放地址<br>对于本案例而言数据存储在 <code>arch/arm/mm/proc-v7.S:503</code>文件中，为 Cortex A9 处理器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">465</span>:.section <span class="string">".proc.info.init"</span>, <span class="meta">#alloc, #execinstr</span></span><br><span class="line"></span><br><span class="line"><span class="number">467</span>: <span class="comment">/*</span></span><br><span class="line"><span class="comment">468:  * Standard v7 proc info content</span></span><br><span class="line"><span class="comment">469:  */</span></span><br><span class="line"><span class="number">470</span>: .macro __v7_proc initfunc, mm_mmuflags = <span class="number">0</span>, io_mmuflags = <span class="number">0</span>, hwcaps = <span class="number">0</span>, proc_fns = v7_processor_functions</span><br><span class="line"><span class="number">471</span>: ALT_SMP(.<span class="keyword">long</span>PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line"><span class="number">472</span>: PMD_SECT_AF | PMD_FLAGS_SMP | \mm_mmuflags)</span><br><span class="line"><span class="number">473</span>:  ALT_UP(.<span class="keyword">long</span>PMD_TYPE_SECT | PMD_SECT_AP_WRITE | PMD_SECT_AP_READ | \</span><br><span class="line"><span class="number">474</span>: PMD_SECT_AF | PMD_FLAGS_UP | \mm_mmuflags)</span><br><span class="line"><span class="number">475</span>: .<span class="keyword">long</span>PMD_TYPE_SECT | PMD_SECT_AP_WRITE | \</span><br><span class="line"><span class="number">476</span>: PMD_SECT_AP_READ | PMD_SECT_AF | \io_mmuflags</span><br><span class="line"><span class="number">477</span>: W(b)\initfunc</span><br><span class="line"><span class="number">478</span>: .<span class="keyword">long</span>cpu_arch_name</span><br><span class="line"><span class="number">479</span>: .<span class="keyword">long</span>cpu_elf_name</span><br><span class="line"><span class="number">480</span>: .<span class="keyword">long</span>HWCAP_SWP | HWCAP_HALF | HWCAP_THUMB | HWCAP_FAST_MULT | \</span><br><span class="line"><span class="number">481</span>: HWCAP_EDSP | HWCAP_TLS | \hwcaps</span><br><span class="line"><span class="number">482</span>: .<span class="keyword">long</span>cpu_v7_name</span><br><span class="line"><span class="number">483</span>: .<span class="keyword">long</span>\proc_fns</span><br><span class="line"><span class="number">484</span>: .<span class="keyword">long</span>v7wbi_tlb_fns</span><br><span class="line"><span class="number">485</span>: .<span class="keyword">long</span>v6_user_fns</span><br><span class="line"><span class="number">486</span>: .<span class="keyword">long</span>v7_cache_fns</span><br><span class="line"><span class="number">487</span>: .endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">500</span>: <span class="comment">/*</span></span><br><span class="line"><span class="comment">501:  * ARM Ltd. Cortex A9 processor.</span></span><br><span class="line"><span class="comment">502:  */</span></span><br><span class="line"><span class="number">503</span>: .type   __v7_ca9mp_proc_info, #object</span><br><span class="line"><span class="number">504</span>: __v7_ca9mp_proc_info:</span><br><span class="line"><span class="number">505</span>: .<span class="keyword">long</span><span class="number">0x410fc090</span></span><br><span class="line"><span class="number">506</span>: .<span class="keyword">long</span><span class="number">0xff0ffff0</span></span><br><span class="line"><span class="number">507</span>: __v7_proc __v7_ca9mp_setup, proc_fns = ca9mp_processor_functions</span><br><span class="line"><span class="number">508</span>: .size__v7_ca9mp_proc_info, . - __v7_ca9mp_proc_info</span><br></pre></td></tr></table></figure></li><li><p>链接<br>arch/arm/kernel/vmlinux.lds.S会将arch/arm/mm/proc-*.S中所有相关数据都编译到同一段中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span>: <span class="meta">#<span class="meta-keyword">define</span> PROC_INFO\</span></span><br><span class="line"><span class="number">26</span>: . = ALIGN(<span class="number">4</span>);\</span><br><span class="line"><span class="number">27</span>: VMLINUX_SYMBOL(__proc_info_begin) = .;\</span><br><span class="line"><span class="number">28</span>:*(.proc.info.init)\</span><br><span class="line"><span class="number">29</span>:VMLINUX_SYMBOL(__proc_info_end) = .;</span><br><span class="line"></span><br><span class="line"><span class="number">203</span>:.init.proc.info : &#123;</span><br><span class="line"><span class="number">204</span>:ARM_CPU_DISCARD(PROC_INFO)</span><br><span class="line"><span class="number">205</span>:&#125;</span><br></pre></td></tr></table></figure></li><li><p>链接后结构<br>通过查看 System.map 文件查看链接地址，可以看到 .init.proc.info 段放了所有相关 cpu 的 procinfo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c0b17c04 T __proc_info_begin</span><br><span class="line">c0b17c04 t __v7_ca5mp_proc_info</span><br><span class="line">c0b17c38 t __v7_ca9mp_proc_info</span><br><span class="line">c0b17c6c t __v7_cr7mp_proc_info</span><br><span class="line">c0b17ca0 t __v7_ca7mp_proc_info</span><br><span class="line">c0b17cd4 t __v7_ca12mp_proc_info</span><br><span class="line">c0b17d08 t __v7_ca15mp_proc_info</span><br><span class="line">c0b17d3c t __v7_b15mp_proc_info</span><br><span class="line">c0b17d70 t __v7_ca17mp_proc_info</span><br><span class="line">c0b17da4 t __krait_proc_info</span><br><span class="line">c0b17dd8 t __v7_proc_info</span><br><span class="line">c0b17e0c T __proc_info_end</span><br></pre></td></tr></table></figure></li></ol><h2 id="获取-CPU-ID"><a href="#获取-CPU-ID" class="headerlink" title="获取 CPU ID"></a>获取 CPU ID</h2><p>arm 中将 CPU ID 存放在 cp15 的 c0 寄存器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mrc p15(cp15协处理器), 0(cp15必须为0), r9(写入寄存器), c0(cp15上c0寄存器), c0(默认使用), &#123;,opcode_2(默认为0)&#125;</span><br></pre></td></tr></table></figure><p>opcode_2=0时访问处理器标识符寄存器。<br>opcode_2=1时访问cache类型标识符寄存器。</p><p>运行完成后获取 <code>r9=0x410fc090</code></p><h2 id="获取procinfo"><a href="#获取procinfo" class="headerlink" title="获取procinfo"></a>获取procinfo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/head-common.S:152</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *r9 = cpuid</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *r3, r4, r6 corrupted</span></span><br><span class="line"><span class="comment"> *r5 = proc_info pointer in physical address space</span></span><br><span class="line"><span class="comment"> *r9 = cpuid (preserved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__lookup_processor_type:</span><br><span class="line">adrr3, __lookup_processor_type_data@ r3 = __lookup_processor_type_data 所在的物理地址</span><br><span class="line">ldmiar3, &#123;r4 - r6&#125;</span><br><span class="line">@ r4 = __lookup_processor_type_data 所在虚拟地址 r5 = __proc_info_begin 虚拟地址, r6 = __proc_info_end 虚拟地址</span><br><span class="line">subr3, r3, r4@ get offset between virt&amp;phys</span><br><span class="line">addr5, r5, r3@ convert virt addresses to, r5 = __proc_info_begin 物理地址</span><br><span class="line">addr6, r6, r3@ physical address space, r6 = __proc_info_end 物理地址</span><br><span class="line"><span class="number">1</span>:ldmiar5, &#123;r3, r4&#125;@ value, mask</span><br><span class="line"><span class="keyword">and</span>r4, r4, r9@ mask wanted bits</span><br><span class="line">teqr3, r4</span><br><span class="line">beq<span class="number">2f</span></span><br><span class="line">addr5, r5, #PROC_INFO_SZ@ <span class="keyword">sizeof</span>(proc_info_list)</span><br><span class="line">cmpr5, r6</span><br><span class="line">blo<span class="number">1b</span></span><br><span class="line">movr5, #<span class="number">0</span>@ unknown processor</span><br><span class="line"><span class="number">2</span>:retlr</span><br><span class="line">ENDPROC(__lookup_processor_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look in &lt;asm/procinfo.h&gt; for information about the __proc_info structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.align<span class="number">2</span></span><br><span class="line">.type__lookup_processor_type_data, %object</span><br><span class="line">__lookup_processor_type_data:</span><br><span class="line">.<span class="keyword">long</span>.</span><br><span class="line">.<span class="keyword">long</span>__proc_info_begin</span><br><span class="line">.<span class="keyword">long</span>__proc_info_end</span><br><span class="line">.size__lookup_processor_type_data, . - __lookup_processor_type_data</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li>proc info 是如何获取的？<br>通过读取 cp15 中的 cpu id 信息，然后与 __proc_info_begin 段中的所有 cpu_val 进行比较，如果与当前 cpu 一致，则找到对应的 procinfo 数据。</li><li>为何需要提前获取？<br>有初始化必要的参数，譬如临时页表所需的 mmu 标识，在打开 mmu 之前需要配置临时内核页表。</li></ol><h1 id="DTB-校验-以及-fixup"><a href="#DTB-校验-以及-fixup" class="headerlink" title="DTB 校验 以及 fixup"></a>DTB 校验 以及 fixup</h1><h2 id="DTB-校验"><a href="#DTB-校验" class="headerlink" title="DTB 校验"></a>DTB 校验</h2><p>DTB 的校验工作其实很简单就是从 DTB 文件读取 magic 进行比较，如果一致则认为 DTB 有效。</p><p>DTB 这部分数据的话会在 start_kernel 的时候使用，所以必须保证是一个有效的数据块。</p><p>DTB 数据会被加载到 <code>0x6320_0000</code> 这一地址。DTB 文件在编译后的 arch/arm/boot/dts。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// arch/arm/boot/dts</span><br><span class="line">$ hexdump -C vexpress-v2p-ca9.dtb | head</span><br><span class="line"></span><br><span class="line">00000000  d0 0d fe ed 00 00 36 e0  00 00 00 38 00 00 33 3c  |......6....8..3&lt;|</span><br><span class="line">00000010  00 00 00 28 00 00 00 11  00 00 00 10 00 00 00 00  |...(............|</span><br><span class="line">00000020  00 00 03 a4 00 00 33 04  00 00 00 00 00 00 00 00  |......3.........|</span><br><span class="line">00000030  00 00 00 00 00 00 00 00  00 00 00 01 00 00 00 00  |................|</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arch/arm/kernel/head-common.S:47</span></span><br><span class="line"></span><br><span class="line">__vet_atags:</span><br><span class="line">tstr2, #<span class="number">0x3</span>@ aligned? 保证 dtb 地址是<span class="number">4</span>字节对齐的</span><br><span class="line">bne<span class="number">1f</span></span><br><span class="line"></span><br><span class="line">ldrr5, [r2, #<span class="number">0</span>]@ 获取 dtb 前四个字节，存放在 r5 寄存器中</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_OF_FLATTREE</span></span><br><span class="line">ldrr6, =OF_DT_MAGIC@ is it a DTB?</span><br><span class="line">cmpr5, r6</span><br><span class="line">beq<span class="number">2f</span></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:retlr@ atag/dtb pointer is ok</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:movr2, #<span class="number">0</span></span><br><span class="line">retlr</span><br></pre></td></tr></table></figure><h2 id="fixup"><a href="#fixup" class="headerlink" title="fixup"></a>fixup</h2><blockquote><p>该部分感觉并非特别重要，且与具体 cpu 相关，放弃阅读。</p></blockquote><h1 id="创建页表"><a href="#创建页表" class="headerlink" title="创建页表"></a>创建页表</h1><blockquote><p>页表创建是在 start_kernel 最关键也是比较难以理解的一个部分，尤其是对计算机硬件了解不深，对 MMU、TLB 没有认识的人而言更加难以理解整个过程。<br>本节将简单的介绍一下 MMU，并通过一个简单的例子来说明虚拟地址是如何转化到物理地址上的。对 MMU 有一个比较深刻的认识。<br>了解完 MMU 后，才能够继续讲解 <strong>create_page_tables，因为 </strong>create_page_tables 函数就是基于 MMU 特性所做的一个操作。</p></blockquote><h2 id="MMU-介绍"><a href="#MMU-介绍" class="headerlink" title="MMU 介绍"></a>MMU 介绍</h2><p>MMU 是 Memory Management Unit（内存管理单元），开启 MMU 后就可以通过虚拟地址管理内存，完成硬件进行虚拟地址到物理地址的转化，提供硬件的内存访问授权。</p><h3 id="Arm32-MMU-一级描述符的格式"><a href="#Arm32-MMU-一级描述符的格式" class="headerlink" title="Arm32 MMU 一级描述符的格式"></a>Arm32 MMU 一级描述符的格式</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811402462093.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>最后两位用于表示当前使用的是哪一种类型：</p><ul><li>0b00: Fault, 表示无效或错误。</li><li>0b01: Page table, 表示使用页表。</li><li>0b10: Section or Supersection, 表示当前使用段管理，或者超级段（在32位中访问大于4G内存）。若是 Supersection 则 Bit[18] 必须为 1, Section 为 0。</li></ul><h3 id="Section-段管理"><a href="#Section-段管理" class="headerlink" title="Section 段管理"></a>Section 段管理</h3><blockquote><p>因为在 __create_page_tables 中使用的是最简单的段管理，因此这里详细讲解下 Section。参考 ARMv7 手册 p.1320。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811406851839.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><ul><li>Bit[1:0] 描述类型，必须为 10</li><li>TEX[2:0] + CB 用于表示 cache 的运行模式，例如：001 + 11 表示 Outer and Inner Write-Back，Write-Allocate。这部分需要有 cpu cache 前置知识，需要知道 cache 有直写和写回两种方法，Write-Allocate 是要求在写 cache 中没有的数据时，不能直接写内存，而是先把内存数据加载到 cache，然后写 cache。</li><li>Domain 控制域。</li><li>AP[2:0] 访问权限控制，若是 011 则表示 Full access。</li><li>NS 表示 Non-secure bit. 表示转化 PA 是否在 secure address map。</li><li>nG 表示 not global bit.</li><li>S 表示 shareable bit.</li></ul><h3 id="MMU-如何工作"><a href="#MMU-如何工作" class="headerlink" title="MMU 如何工作"></a>MMU 如何工作</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811426560522.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>MMU 的工作实质就是将虚拟地址转化为物理地址，其步骤如下：</p><ol><li>从 TTBR0(translation table base register) 获取基础地址。</li><li>通过虚拟地址的 Table Index 查找到相应的页表所在地址。</li><li>从页表所在地址中读取出相应物理页表数据，完成虚拟页表到物理页表的转化。</li><li>在获取的物理页表上加上对应的指令偏移则获取到最后的物理地址。</li></ol><p>下面举一个实际的例子：</p><p>该例子中，TTBR0 保存的基地址是 0x6000_4000，并且从 0x6000_4000~0x6000_8000 这一个 16k 的内存中建立了相应的页表数据，此时需要获取虚拟地址 0xc000_8130 的 物理地址。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811429476484.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><p>步骤：</p><ol><li>根据从 TTBR0 中获取的 0x6000_4000 以及对应虚拟地址 0xc000_8130 计算得到 对应的描述符物理地址为 0x6000_7000。</li><li>从描述符锁在物理地址 0x6000_7000 可以得到 section 信息为 0x6001_1c0e。</li><li>通过 0x6001_1c0e 的 Section Base address + Section Index 即获取最后的物理地址为 0x8000_8130。</li></ol><blockquote><p>为何说内核是线性映射的，因为内核虚拟地址在 0xc000<em>0000 向上位置，其对于的物理地址刚好是 0x6000_0000 向上，这部分映射的话直接映射即可。0xc00</em> -&gt; 0x600_</p></blockquote><p>MMU 做的工作如上所述，但是这一工作的前提是必须要由我们来创建页表信息。页表是需要人为维护的，这也是 __create_page_tables 所做的工作。</p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个物理地址与虚拟地址一致的映射</span></span><br><span class="line"><span class="comment"> * 为了打开 MMU 时候需要一个临时的页表。</span></span><br><span class="line"><span class="comment"> * __create_page_tables 做了两件事情:</span></span><br><span class="line"><span class="comment"> *1. 打开 mmu 把打开 mmu 代码对应到段映射到 1m 大小的地方。创建一个恒等的映射。虚拟地址=物理地址</span></span><br><span class="line"><span class="comment"> *  2. 把内核的 image 代码映射到内核到虚拟空间中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Setup the initial page tables.  We only setup the barest</span></span><br><span class="line"><span class="comment"> * amount which are required to get the kernel running, which</span></span><br><span class="line"><span class="comment"> * generally means mapping in the kernel code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * r8 = phys_offset, r9 = cpuid, r10 = procinfo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:</span></span><br><span class="line"><span class="comment"> *  r0, r3, r5-r7 corrupted</span></span><br><span class="line"><span class="comment"> *  r4 = page table (see ARCH_PGD_SHIFT in asm/memory.h)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__create_page_tables:</span><br><span class="line">pgtblr4, r8@ page table address, r4 设置成页表的基地址, phys_offset + TEXT_OFFSET(<span class="number">0x8000</span>) - PG_DIR_SIZE(<span class="number">0x4000</span>), 即为内核位置下方的 <span class="number">16</span>k</span><br><span class="line">@ r4 = <span class="number">0x6000</span>_4000 r8 = <span class="number">0x6000</span>_8000</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Clear the swapper page table</span></span><br><span class="line"><span class="comment"> * 清除 0x6000_4000 - 0x6000_8000 这段内存数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">movr0, r4@ r0 = r4</span><br><span class="line">movr3, #<span class="number">0</span>@ r3 = <span class="number">0</span></span><br><span class="line">addr6, r0, #PG_DIR_SIZE@ r6 = 页表基地址 + <span class="number">16</span>k，即页表的尾地址</span><br><span class="line"><span class="number">1</span>:strr3, [r0], #<span class="number">4</span>@ str 移动的是 <span class="number">32</span> 位的数据, 将 r3 的值写入 r0 为地址的内存, 并设置 r0 = r0 + <span class="number">4</span></span><br><span class="line">strr3, [r0], #<span class="number">4</span></span><br><span class="line">strr3, [r0], #<span class="number">4</span></span><br><span class="line">strr3, [r0], #<span class="number">4</span></span><br><span class="line">teqr0, r6@ 判断是否到页表到尾地址</span><br><span class="line">bne<span class="number">1b</span></span><br><span class="line"></span><br><span class="line">ldrr7, [r10, #PROCINFO_MM_MMUFLAGS] @ mm_mmuflags 设置 mmu 标志位</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create identity mapping to cater for __enable_mmu.</span></span><br><span class="line"><span class="comment"> * This identity mapping will be removed by paging_init().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">adrr0, __turn_mmu_on_loc@ r0 = __turn_mmu_on_loc 地址 </span><br><span class="line">ldmiar0, &#123;r3, r5, r6&#125;@ 将 r0 中的数据 弹出到 r3, r5, r6</span><br><span class="line">subr0, r0, r3@ virt-&gt;phys offset, r0 为物理地址, r3, r5, r6 为虚拟地址，此时需要将虚拟地址转化为物理地址, r0 与 r3 是 __turn_mmu_on_loc 对应的物理与虚拟地址</span><br><span class="line">addr5, r5, r0@ phys __turn_mmu_on</span><br><span class="line">addr6, r6, r0@ phys __turn_mmu_on_end</span><br><span class="line">movr5, r5, lsr #SECTION_SHIFT@ r5 = r5 &gt;&gt; <span class="number">20</span>, 取高<span class="number">12</span>位</span><br><span class="line">movr6, r6, lsr #SECTION_SHIFT@ r6 = r6 &gt;&gt; <span class="number">20</span>, 取高<span class="number">12</span>位</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:orrr3, r7, r5, lsl #SECTION_SHIFT@ flags + kernel base r3 = r7 | (r5 &lt;&lt; <span class="number">20</span>) 得到页表需要设置的数据</span><br><span class="line">strr3, [r4, r5, lsl #PMD_ORDER]@ identity mapping [r4 + r5 &lt;&lt; <span class="number">2</span>] = r3, 将 __turn_mmu_on 设置到 对应的一级页表中</span><br><span class="line">cmpr5, r6@ 是否在同一段，若不是则继续映射</span><br><span class="line">addlor5, r5, #<span class="number">1</span>@ next section</span><br><span class="line">blo<span class="number">1b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Map our RAM from the start to the end of the kernel .bss section.</span></span><br><span class="line"><span class="comment"> * 下面这部分其实是为了将内核部分数据映射</span></span><br><span class="line"><span class="comment"> * 内核虚拟地址为0xc000_0000 - 0xc112_23d7</span></span><br><span class="line"><span class="comment"> * 内核物理地址为       0x6000_0000 - 0x6112_23d7</span></span><br><span class="line"><span class="comment"> * 进行计算后对应段为   0x6000_7000 - 0x6000_7044</span></span><br><span class="line"><span class="comment"> * 0x6000_7000 如何计算: L1 基地址为 0x6000_4000 + 0xc000_0000 &gt;&gt; 18</span></span><br><span class="line"><span class="comment"> * 0x6000_7044 如何计算: L1 基地址为 0x6000_4000 + 0xc112_23d7 &gt;&gt; 18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addr0, r4, #PAGE_OFFSET &gt;&gt; (SECTION_SHIFT - PMD_ORDER)@ r0 = r4 + <span class="number">0xc000</span>_0000 &gt;&gt; <span class="number">18</span>, r0 = <span class="number">0x6000</span>_7000</span><br><span class="line">ldrr6, =(_end - <span class="number">1</span>)@ ldr 伪指令, r6 = kernel_end - <span class="number">1</span> r6 = <span class="number">0xc112</span>_23d7</span><br><span class="line">orrr3, r8, r7@ r3 = r8 | r7, r8 为 phys_offset <span class="number">0x6000</span>_0000</span><br><span class="line">addr6, r4, r6, lsr #(SECTION_SHIFT - PMD_ORDER)@ r6 = r4 + r6 &gt;&gt; <span class="number">18</span>, 与之前设置 __turn_mmu_on 段过程一样</span><br><span class="line"><span class="number">1</span>:strr3, [r0], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">addr3, r3, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">cmpr0, r6</span><br><span class="line">bls<span class="number">1b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dtb 所在两个段的映射</span></span><br><span class="line"><span class="comment"> * Then map boot params address in r2 if specified.</span></span><br><span class="line"><span class="comment"> * We map 2 sections in case the ATAGs/DTB crosses a section boundary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">movr0, r2, lsr #SECTION_SHIFT@ 将 r2=dtb dtb 左移，存放到 r0</span><br><span class="line">movsr0, r0, lsl #SECTION_SHIFT@ 再将 r0 右移获取物理内存段地址</span><br><span class="line">subner3, r0, r8@ 计算 r0 对应DARM起始地址r8偏移</span><br><span class="line">addner3, r3, #PAGE_OFFSET</span><br><span class="line">addner3, r4, r3, lsr #(SECTION_SHIFT - PMD_ORDER)</span><br><span class="line">orrner6, r7, r0</span><br><span class="line">strner6, [r3], #<span class="number">1</span> &lt;&lt; PMD_ORDER</span><br><span class="line">addner6, r6, #<span class="number">1</span> &lt;&lt; SECTION_SHIFT</span><br><span class="line">strner6, [r3]</span><br><span class="line"></span><br><span class="line">retlr</span><br><span class="line">ENDPROC(__create_page_tables)</span><br><span class="line">.ltorg</span><br><span class="line">.align</span><br><span class="line">__turn_mmu_on_loc:</span><br><span class="line">.<span class="keyword">long</span>.</span><br><span class="line">.<span class="keyword">long</span>__turn_mmu_on</span><br><span class="line">.<span class="keyword">long</span>__turn_mmu_on_end</span><br></pre></td></tr></table></figure><h2 id="运行完成后内存结构"><a href="#运行完成后内存结构" class="headerlink" title="运行完成后内存结构"></a>运行完成后内存结构</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811474554381.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title></p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>为何 __turn_mmu_on 这部分需要做一个直接映射？因为在开启 MMU 完成后 pc 指针指向的还是物理地址，但此时对 MMU 而言该地址是个虚拟地址，需要查页表，若不建立这一块直接映射，则无法继续执行。</li><li>MMU flags 03x11C0E 表示什么？是从arch/arm/mm/proc-v7.S:503这里获取的。<br><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15811475656613.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="600" alt title><br>AP=011可读性，TEXCB=00111表示Outer and Inner Write-Back，Write-Allocate。</li><li>TEXT_OFFSET 在那个文件指定？arch/arm/Makefile, 0x8000</li><li>PG_DIR_SIZE 在哪个文件指定？arch/arm/kernel/head.S, 0x4000</li><li>PAGE_OFFSET 表示内核的开始虚拟地址, 0xc000_000<h1 id="ARM-汇编指令说明"><a href="#ARM-汇编指令说明" class="headerlink" title="ARM 汇编指令说明"></a>ARM 汇编指令说明</h1></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">mrs r4, cpsr</td><td style="text-align:center">状态寄存器到通用寄存器的传送指令</td></tr><tr><td style="text-align:center">msr cpsr, r4</td><td style="text-align:center">通用寄存器到状态寄存器的传送指令</td></tr><tr><td style="text-align:center">adr r0, .test</td><td style="text-align:center">相当于 add r0, pc, #4 小范围地址读取伪指令</td></tr><tr><td style="text-align:center">ldr</td><td style="text-align:center">大范围地址读取伪指令</td></tr><tr><td style="text-align:center">str r0, [r1, #8]</td><td style="text-align:center">将r0中的字写入r1+8为地址的存储中</td></tr><tr><td style="text-align:center">cmp r0, r1</td><td style="text-align:center">相当于 r0-r1</td></tr><tr><td style="text-align:center">eor</td><td style="text-align:center">异或指令</td></tr><tr><td style="text-align:center">MCR{&lt;cond&gt;} &lt;p&gt;,&lt;opcode_1&gt;,&lt;Rd&gt;,&lt;CRn&gt;,&lt;CRm&gt;{,&lt;opcode_2&gt;}</td><td style="text-align:center">将arm寄存器数据传递到协处理器</td></tr><tr><td style="text-align:center">MRC{&lt;cond&gt;} &lt;p&gt;,&lt;opcode_1&gt;,&lt;Rd&gt;,&lt;CRn&gt;,&lt;CRm&gt;{,&lt;opcode_2&gt;}</td><td style="text-align:center">将协处理器数据传递到arm寄存器</td></tr><tr><td style="text-align:center">LDMIA R1!,{R0,R4-R6}</td><td style="text-align:center">从左到右加载,相当于 LDR R0,10000000  LDR R4,10000004… …，!表示最后地址是否写回到R1</td></tr><tr><td style="text-align:center">STMIB R1,{R4-R6}</td><td style="text-align:center">从左到右加载,相当于STR [R4],0X10000004    STR [R5],0X10000008 …..</td></tr></tbody></table></div><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文在大量参考已有知识，并通过自己调试总结后完成。</p><p><a href="https://static.docs.arm.com/ddi0406/c/DDI0406C_C_arm_architecture_reference_manual.pdf" target="_blank" rel="noopener">ARMv7 手册</a><br><a href="https://item.jd.com/12152745.html" target="_blank" rel="noopener">奔跑吧 Linux 内核</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52690132" target="_blank" rel="noopener">[kernel 启动流程] 前篇——vmlinux.lds分析</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52710290" target="_blank" rel="noopener">[kernel 启动流程] （第一章）概述</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52779230" target="_blank" rel="noopener">[kernel 启动流程] （第二章）第一阶段之——设置SVC、关闭中断</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52791202" target="_blank" rel="noopener">[kernel 启动流程] （第三章）第一阶段之——proc info的获取</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52797211" target="_blank" rel="noopener">[kernel 启动流程] （第四章）第一阶段之——dtb的验证</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52850433" target="_blank" rel="noopener">[kernel 启动流程] （第五章）第一阶段之——临时内核页表的创建</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52860186" target="_blank" rel="noopener">[kernel 启动流程] （第六章）第一阶段之——打开MMU</a><br><a href="https://blog.csdn.net/ooonebook/article/details/52861681" target="_blank" rel="noopener">[kernel 启动流程] （第七章）第一阶段之——跳转到start_kernel</a></p>]]></content>
      
      
      <categories>
          
          <category> LinuxKernel4.0-arm32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinuxKernel4.0-arm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出计算机组成原理</title>
      <link href="Linux/linux/cpu-info/"/>
      <url>Linux/linux/cpu-info/</url>
      
        <content type="html"><![CDATA[<h1 id="深入浅出计算机组成原理"><a href="#深入浅出计算机组成原理" class="headerlink" title="深入浅出计算机组成原理"></a>深入浅出计算机组成原理</h1><p>[TOC]</p><p>本博客主要用于整理<a href="https://time.geekbang.org/column/article/91427" target="_blank" rel="noopener">深入浅出计算机组成原理</a>学到的相关知识，本人深觉笔记的重要性，<strong>读书百遍其义自现，不如认真将精华记录</strong>。</p><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814844212144.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><a id="more"></a><p>计算机组成，向下可以学习数字电路，向上可以学习编译原理、操作系统、计算机网络。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814844450657.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>冯·诺依曼体系结构，也叫存储程序计算机，一个是”可编程”计算机，一个是”存储”计算机。主要由 CPU（控制器，运算器）、存储器、输入输出设备组成。</p><p>图灵机相较于冯·诺依曼机两者差别在于，图灵机侧重于计算抽象，冯·诺依曼机侧重于硬件抽象。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814844562275.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h2 id="性能与功耗"><a href="#性能与功耗" class="headerlink" title="性能与功耗"></a>性能与功耗</h2><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>响应时间（执行时间），“跑得快”。<br>吞吐率（带宽），“搬的多”。</p><p>性能指标由以下公式决定：</p><script type="math/tex; mode=display">CPU Time = InstructionNum * CPI(Cycles Per Instruction) * Clock Cycle Time</script><ol><li>InstructionNum，程序指令数，由编译器以及程序员决定。</li><li>CPI，Cycles Per Instruction，使用 Pipeline，超流水线、SIMD 等技术使一条指令需要的 CPU Cycle 尽可能少。<strong>对 CPI 优化是计算机体系结构最重要一环</strong>。</li><li>Clock Cycle Time，由计算机主频决定。</li></ol><h3 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h3><p>我们的 CPU，一般都被叫作超大规模集成电路（Very-Large-Scale Integration，VLSI）</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814844733697.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>由于功耗墙问题，通过提升主频实现性能提升越来越难，因此通过引入多核 CPU 设计的方案通过提升“吞吐率”而非“响应时间”来提升性能。<br>即<strong>通过并行提升性能</strong>。</p><p>阿姆达尔定律（Amdahl’s Law）：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814844835676.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>由于阿姆达尔定律的存在，优化后的执行时间也是有上限的，主要是不受影响的执行时间无法继续优化。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814844938312.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="提升性能方法"><a href="#提升性能方法" class="headerlink" title="提升性能方法"></a>提升性能方法</h3><ol><li>摩尔定律，提升主频。</li><li>并行计算，提升吞吐率。</li><li>加大大概率事件。</li><li>流水线提高性能，降低 CPI。</li><li>预测提升性能，分支与保险、局部性原理。</li></ol><h2 id="指令与计算"><a href="#指令与计算" class="headerlink" title="指令与计算"></a>指令与计算</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845021649.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>不同的 CPU 有不同的指令集，以 MIPS 指令集为例。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845084692.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>MIPS 指令是一个32位整数，高6位叫操作码，剩下26位有 R、I、J 三种格式。</p><p>内联函数能够减少，函数调用过程中，压栈出栈的操作。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845155899.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>为什么程序无法同时在Linux和Windows下运行？</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845225247.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>链接器会扫描所有的目标文件，把符号表所有信息收集构成全局符号表，再根据重定位表，把所有不确定要跳转地址的代码，根据符号表地址进行修正，最后把所有目标文件对应段进行合并，形成最终的可执行代码。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845328165.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>程序装载采用内存分页的方式，<code>getconf PAGE_SIZE</code> 默认为4k。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845399817.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>若全部采用静态链接，标准库需要不停地拷贝很多份。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845478677.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>此时，选择采用动态链接的方式，内存中只保存一份，虚拟内存地址与之进行映射。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845552430.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>通过查找 PLT 与 GOT（Global Offset Table） 找到动态库地址。</p><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845618406.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845678821.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845755135.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>乘法可以用加法进行代替。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845824716.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845886116.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814845950370.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>电路在物理上是并行的，因此可以加速。</p><h2 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846042755.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846297310.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>CPU 指令周期可以分为 Fetch、Decode、Execute。<br>数据通路连接<strong>操作元件（ALU）</strong>和<strong>存储元件（寄存器）</strong>，完成数据存储、处理、传输的处理器单元。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846387747.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>通过反向器实现时钟信号。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846460437.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>通过 D 触发器实现寄存器。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846537063.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>PC 寄存器。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846729075.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="CPU-优化"><a href="#CPU-优化" class="headerlink" title="CPU 优化"></a>CPU 优化</h3><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846817196.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>首先考虑的是单指令周期的处理器，由于不同指令所需时钟周期不同，因此都需要等满一个时钟周期，产生大量浪费，同时时钟⏰频率也很难提升。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846880185.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>通过将指令，按照不同的小步骤拆分，即形成流水线工作，我们不需要确保最复杂的那条指令在时钟周期里执行完成，而只要保障一个最复杂的<strong>流水线级</strong>的操作，在一个时钟周期内完成即可。</p><p>虽然，没有提升“延时”，但是提升了“吞吐量”。5条流水线，即提升5倍。像我们现代的 ARM 或者 Intel 的 CPU，流水线级数已经到了14级。</p><blockquote><p>超长流水线瓶颈，增加流水线深度，其实是有性能成本，在读写流水线寄存器时，会有开销。同时还会带来<strong>结构冒险、控制冒险等其他依赖问题</strong>。<br>为了应付各类冒险问题，采用<strong>乱序执行、分支预测</strong>等解决方案。<br>流水线越长，这一类冒险问题就更难解决。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// 指令 1</span></span><br><span class="line"><span class="keyword">int</span> b = a * <span class="number">2</span>; <span class="comment">// 指令 2</span></span><br><span class="line"><span class="keyword">float</span> c = b * <span class="number">1.0f</span>; <span class="comment">// 指令 3</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// 指令 4</span></span><br><span class="line"><span class="keyword">int</span> y = a * <span class="number">2</span>; <span class="comment">// 指令 5</span></span><br><span class="line"><span class="keyword">float</span> z = b * <span class="number">1.0f</span>; <span class="comment">// 指令 6</span></span><br><span class="line"><span class="keyword">int</span> o = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// 指令 7</span></span><br><span class="line"><span class="keyword">int</span> p = a * <span class="number">2</span>; <span class="comment">// 指令 8</span></span><br><span class="line"><span class="keyword">float</span> q = b * <span class="number">1.0f</span>; <span class="comment">// 指令 9</span></span><br><span class="line"><span class="comment">// 由于1，2，3有依赖关系，可以先执行1，4，7</span></span><br></pre></td></tr></table></figure><h4 id="冒险与预测"><a href="#冒险与预测" class="headerlink" title="冒险与预测"></a>冒险与预测</h4><blockquote><p>流水线设计必须解决三大冒险，分别是<strong>结构冒险</strong>, <strong>数据冒险</strong>, <strong>控制冒险</strong>。</p></blockquote><h5 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h5><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814846975031.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>访存与取指令都需要操作程序内存，但是我们只有一个地址译码器，会产生资源冲突，为了解决该冲突，将内存分为两部分，一个用于存放指令，一个用于存放数据。<br>把内存拆成两部分的解决方案，被称为<strong>哈佛架构</strong>，我们使用的<strong>冯·诺依曼体系结构</strong>又叫<strong>普林斯顿架构</strong>，该体系结构没有拆分内存，而是在高速缓存部分分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847056201.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h5 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h5><ol><li>先写后读，数据依赖</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 先写1 再读1</span></span><br><span class="line">  a = a + <span class="number">2</span>;</span><br><span class="line">  b = a + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先读后写，反依赖</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">  a = b + a;</span><br><span class="line">  <span class="comment">// 若下面早于上面完成</span></span><br><span class="line">  b = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>写后再写，输出依赖</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 先写1 再写1</span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用 nop 解决</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847153200.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><blockquote><p>操作数前推（操作数转发），减少 nop</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847211068.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><blockquote><p>由于不同指令不存在依赖关系，可以通过乱序执行，将没有依赖关系的指令提前，减少 nop 时间。乱序执行，有点类似于 <strong>线程池</strong>。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847277981.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h5 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h5><blockquote><p>以上假设都是基于顺序执行进行的，取指令 和 指令译码不会遇到任何停顿。当遇到 jmp 等跳转指令时，为了保证争取，不得不等待延迟。</p></blockquote><ol><li>分支预测，便是假装分支不发生，即<strong>静态预测</strong>成功率在50%，当发现错误时，就将不要的数据丢弃。</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847359425.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><ol><li>动态分支预测，即今天下雨，就猜明天也下雨。即用1比特保存当前预测结果，并用该结果作为下一次分支比较。还可以用2比特预测，叫<strong>双模态预测</strong>，状态机如下。</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847428345.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><blockquote><p>注意在不改变代码基础上，将循环少的放外面。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847608828.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h4 id="Superscalar和VLIW使CPU吞吐率超过1"><a href="#Superscalar和VLIW使CPU吞吐率超过1" class="headerlink" title="Superscalar和VLIW使CPU吞吐率超过1"></a>Superscalar和VLIW使CPU吞吐率超过1</h4><ol><li>多发射与超标量</li></ol><p>由于取指令一次只能提取一条，CPU吞吐率只能限定在1。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847689242.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>通过指令多发射设计，可以得到超标量，即并行执行多条指令。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847756606.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><ol><li>VLIW（Very Long Instruction Word）</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847823982.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847884363.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>VLIW 无法兼容，最后失败了。</p><h4 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h4><p>超长流水线，意味着在流水线中指令越多，相互依赖关系越多，不得不面临冒险。2002 年底，Intel 在的 3.06GHz 主频的 Pentium 4 CPU上，第一次引入了超线程技术。<br>超线程技术，就是在CPU中同时执行多个程序的指令。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814847976324.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>增加一份PC寄存器、指令寄存器、条件码寄存器。</p><h4 id="SIMD-加速矩阵乘法"><a href="#SIMD-加速矩阵乘法" class="headerlink" title="SIMD, 加速矩阵乘法"></a>SIMD, 加速矩阵乘法</h4><p>SIMD，Single Instruction Multiple Data。<br>SIMD 在获取数据和执行指令时，都做到了并行，一方面，再从内存读取数据的时候，SIMD是一次性读取多个数据，在SSE指令集中，CPU添加了8个16Bytes的寄存器，一个寄存器一次性可以加载4个整数。</p><p>Numpy，使用 SIMD 技术。</p><p>基于 SIMD 的向量计算指令，被称为 MMX（Matrix Math eXtensions） 指令集，即矩阵数学扩展。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848043068.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h3><h3 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848336767.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848409710.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>MMX + SIMD =&gt; GPU</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848702919.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848799771.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>SIMT, Single Instruction Multiple Threads。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848911771.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>GPU, 超线程。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814848974110.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="FPGA和ASIC"><a href="#FPGA和ASIC" class="headerlink" title="FPGA和ASIC"></a>FPGA和ASIC</h3><p>FPGA，现场可编程门阵列（Field-Programmable Gate Array）。</p><p>ASIC，（Application-Specific Integrated Circuit），专用集成电路。</p><h2 id="存储与IO"><a href="#存储与IO" class="headerlink" title="存储与IO"></a>存储与IO</h2><p>CPU Cache 使用 SRAM（Static Random-Access Memory）的芯片，只要处于通电，数据可以持续保存。<br>在CPU中有L1、L2、L3三层缓存。L1分为指令缓存和数据缓存。</p><p>内存采用 DRAM（Dynamic Random Access Memory），需要不断地“刷新”。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849059454.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849119225.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><blockquote><p>局部性原理：时间局部性和空间局部性。<br>时间局部性：如果一个数据被访问了，它在短时间内还会被再次访问。<br>空间局部性：如果一个数据被访问了，相邻数据也会很快被访问。</p></blockquote><h3 id="高速缓存L1、L2、L3"><a href="#高速缓存L1、L2、L3" class="headerlink" title="高速缓存L1、L2、L3"></a>高速缓存L1、L2、L3</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849189316.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>由于CPU与内存性能差距越来越大，因此需要缓存。</p><ol><li>直接映射</li><li>全关联</li><li>组关联</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849260712.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><blockquote><p>MESI 协议保持多核CPU缓存一致。</p></blockquote><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>利用虚拟内存技术，采用多级页表。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849424056.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p>利用 TLB 进行加速。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849486998.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849626602.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/2020/02/15814849811769.jpg?x-oss-process=image/auto-orient,1/quality,q_90/watermark,text_a2x1dHpvZGVy,color_0c0c0c,size_20,g_se,x_10,y_10" width="400" alt title></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iotop</span><br><span class="line">iostat</span><br></pre></td></tr></table></figure><h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ol><li>《计算机是怎样跑起来的》</li><li>《程序是怎样跑起来的</li><li><a href="https://www.coursera.org/learn/jisuanji-zucheng" target="_blank" rel="noopener">《Computer Organization》</a></li><li>《计算机组成与设计：硬件 / 软件接口》</li><li>《深入理解计算机系统》</li><li><a href="https://www.bilibili.com/video/av24540152/" target="_blank" rel="noopener">《深入理解计算机系统bilibili》</a></li><li><a href="https://www.youtube.com/playlist?list=PLmBgoRqEQCWy58EIwLSWwMPfkwLOLRM5R" target="_blank" rel="noopener">《深入理解计算机系统YouTube》</a></li><li>《计算机组成：结构化方法》</li><li>《计算机体系结构：量化研究方法》</li><li>《编码：隐匿在计算机软硬件背后的语言》</li><li>《程序员的自我修养：链接、装载和库》</li><li><a href="http://www.lighterra.com/papers/modernmicroprocessors/" target="_blank" rel="noopener">Modern Microprocessors</a></li><li><a href="http://norvig.com/21-days.html#answers" target="_blank" rel="noopener">Teach Yourself Programming in Ten Years</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//people/jeff/Stanford-DL-Nov-2010.pdf" target="_blank" rel="noopener">Building Software Systems at Google and<br>Lessons Learned</a></li><li><a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf" target="_blank" rel="noopener">What Every Programmer Should Know About Memory</a></li></ol><h2 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h2><p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/paper/hwViewForSwHackers.pdf" target="_blank" rel="noopener">hwViewForSwHackers.pdf</a><br><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/paper/Available-Instruction-Level-Parallelism-for-Superscalar-and-Superpipelined-Machines.pdf" target="_blank" rel="noopener">Available-Instruction-Level-Parallelism-for-Superscalar-and-Superpipelined-Machines.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travelling salesman problem</title>
      <link href="Algorithm/algorithm/travelling-salesman-problem/"/>
      <url>Algorithm/algorithm/travelling-salesman-problem/</url>
      
        <content type="html"><![CDATA[<blockquote><p>后面更新</p></blockquote><p><a href="https://leetcode-cn.com/problems/find-the-shortest-superstring/" target="_blank" rel="noopener">Leetcode 943</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索模版</title>
      <link href="Algorithm/algorithm/binary-search-template/"/>
      <url>Algorithm/algorithm/binary-search-template/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000016825704" target="_blank" rel="noopener">二分查找、二分边界查找算法的模板代码总结</a></p><h1 id="基础模版形式"><a href="#基础模版形式" class="headerlink" title="基础模版形式"></a>基础模版形式</h1><h2 id="Java-基础版本"><a href="#Java-基础版本" class="headerlink" title="Java 基础版本"></a>Java 基础版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="First-版本"><a href="#First-版本" class="headerlink" title="First 版本"></a>First 版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) end = mid;</span><br><span class="line">        <span class="keyword">else</span> start = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[start] == target) <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] == target) <span class="keyword">return</span> end;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Last-版本"><a href="#Last-版本" class="headerlink" title="Last 版本"></a>Last 版本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) end = mid;</span><br><span class="line">        <span class="keyword">else</span> start = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[end] == target) <span class="keyword">return</span> end;</span><br><span class="line">    <span class="keyword">if</span> (nums[start] == target) <span class="keyword">return</span> start;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="花花模版"><a href="#花花模版" class="headerlink" title="花花模版 (*)"></a>花花模版 (*)</h2><p><a href="https://www.bilibili.com/video/av49905587?from=search&amp;seid=13819999138899279093" target="_blank" rel="noopener">花花酱 LeetCode Binary Search II - 刷题找工作 SP 17</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [l, r)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        m = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span> (g(m)) r = m; <span class="comment">// [l, m)</span></span><br><span class="line">        <span class="keyword">else</span> l = m+<span class="number">1</span>; <span class="comment">// [m+1, r)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spinlock</title>
      <link href="uncategorized/linux/spinlock/"/>
      <url>uncategorized/linux/spinlock/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Trie</title>
      <link href="Algorithm/algorithm/trie/"/>
      <url>Algorithm/algorithm/trie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奔跑吧 Linux 内核(入门篇)学习笔记</title>
      <link href="Linux/linux/running-linux-primer/"/>
      <url>Linux/linux/running-linux-primer/</url>
      
        <content type="html"><![CDATA[<p>奔跑吧 Linux 内核（入门篇）是由笨叔叔出版的一本学习 Linux 内核的基础数据，本人于 2019-03-01 购入，期间阅读过一遍，但再回首发现自己学习到的并不多，决定讲学习过程记录下来，一方面用于学习巩固，另一方面也方便自己后期整理学习。</p><a id="more"></a><h1 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h1><h2 id="使用定制的-runninglinuxkernel"><a href="#使用定制的-runninglinuxkernel" class="headerlink" title="使用定制的 runninglinuxkernel"></a>使用定制的 runninglinuxkernel</h2><blockquote><p><a href="https://jin-yang.github.io/post/kernel-compile.html" target="_blank" rel="noopener">Linux 内核编译</a><br>Ctrl+a，再输入 x 退出 QEMU。</p></blockquote><ol><li><p>安装工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential gcc-5-arm-linux-gnueabi git</span><br></pre></td></tr></table></figure></li><li><p>确保 gcc 版本为 5.+</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -v</span><br></pre></td></tr></table></figure></li><li><p>下载 runninglinuxkernel </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/figozhang/runninglinuxkernel_4.0.git</span><br><span class="line">git checkout rlk_basic</span><br></pre></td></tr></table></figure></li><li><p>编译内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd runninglinuxkernel-4.0</span><br><span class="line">export ARCH=arm</span><br><span class="line">export CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line">make vexpress_defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></li><li><p>创建设备节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd _install_arm32</span><br><span class="line">mkdir dev</span><br><span class="line">cd dev</span><br><span class="line">sudo mknod console c 5 1</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make bzImage -j4</span><br><span class="line">make dtbs</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run.sh arm32</span><br></pre></td></tr></table></figure></li><li><p>测试主机与虚拟机共享文件，只需将共享文件复制到 kmodules 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd runninglinuxkernel-4.0/kmodules</span><br><span class="line">touch test.c</span><br></pre></td></tr></table></figure></li></ol><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c       // 预编译  test.i</span><br><span class="line">gcc -S test.c       // 编译    test.s</span><br><span class="line">gcc -c test.c       // 汇编    test.o</span><br><span class="line">gcc test.c -o test  // 链接    test</span><br></pre></td></tr></table></figure><blockquote><p>交叉编译命名规范：[arch]-[os]-[(gnu)eabi]<br>arch: 表示体系结构, ARM、MIPS<br>os: 表示目标操作系统<br>eabi: 嵌入式应用二进制接口</p></blockquote><ol><li>arm-linux-gnueabi: 用于 ARM32 的 Liunx 系统编译。</li><li>aarch-linux-gnueabi: 用于 ARM64 的 Linux 系统编译。</li></ol><h2 id="CUN-C-语法技巧"><a href="#CUN-C-语法技巧" class="headerlink" title="CUN C 语法技巧"></a>CUN C 语法技巧</h2><ol><li><p>语法表达 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="comment">// 若传入 i++, j++ 会导致 a 和 b 计算两次</span></span><br><span class="line"><span class="comment">// 因此需要使用更安全的写法 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(x, y) (&#123;        \</span></span><br><span class="line">    typeof(x) _min1 = (x);  \</span><br><span class="line">    typeof(y) -min2 = (y);  \</span><br><span class="line">    (<span class="keyword">void</span>) (&amp;_min1 == &amp;_min2);  \</span><br><span class="line">    _min1 &lt; _min2 ? _min1 : _min2;  &#125;)</span><br></pre></td></tr></table></figure></li><li><p>零长数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">line</span>) + <span class="title">this_length</span>);</span></span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure></li><li><p>标号元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GUN C 语言可以通过指定索引或结构体名来初始化，不必按照原来固定顺序进行初始化</span></span><br><span class="line"></span><br><span class="line">&lt;drivers/<span class="keyword">char</span>/mem.c&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">zero_fops</span> = &#123;</span></span><br><span class="line">    .llseek             = zero_lseek,</span><br><span class="line">    .read               = new_sync_read,</span><br><span class="line">    .write              = write_zero,</span><br><span class="line">    .read_iter          = read_iter_zero,</span><br><span class="line">    .aio_write          = aio_write_zero,</span><br><span class="line">    .mmap               = mmap_zero,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="实验2-内核链表"><a href="#实验2-内核链表" class="headerlink" title="实验2: 内核链表"></a>实验2: 内核链表</h2><p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-running-linux-primer/list_linked.c" target="_blank" rel="noopener">内核链表 点击下载</a></p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="简单模块"><a href="#简单模块" class="headerlink" title="简单模块"></a>简单模块</h2><p>Linux 内核通过内核模块来实现动态添加和删除某个功能。</p><ol><li><p>编写一个简单的内核模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ###### c 代码 结束 #######</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt; // 内核源代码，包含了 module_init module_exit </span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt; // 包含最后的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">my_test_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// 函数入口</span></span><br><span class="line">    printk(<span class="string">"my first kernel module init\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">my_test_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// 退出</span></span><br><span class="line">    printk(<span class="string">"goodbye\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_test_init);</span><br><span class="line">module_exit(my_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>); <span class="comment">// 许可证</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">"Klutzoder"</span>); <span class="comment">// 作者</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"my test kernel module"</span>); <span class="comment">// 描述</span></span><br><span class="line">MODULE_ALIAS(<span class="string">"mytest"</span>); <span class="comment">// 别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ####### c 代码 结束 #######</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ####### Makefile 开始 #######</span></span><br><span class="line">BASEINCLUDE ?= /lib/modules/`uname -r`/build</span><br><span class="line"></span><br><span class="line">mytest-objs := my_test.o</span><br><span class="line">obj-m := mytest.o</span><br><span class="line"></span><br><span class="line"># 一定要注意是  tab</span><br><span class="line">all:</span><br><span class="line">    $(MAKE) -C $(BASEINCLUDE) M=$(PWD) modules;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    $(MAKE) -C $(BASEINCLUDE) SUBDIRS=$(PWD) clean;</span><br><span class="line">    rm -f *.ko</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ####### Makefile 结束 #######</span></span><br></pre></td></tr></table></figure></li><li><p>编译后加载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file mytest.ko</span><br><span class="line">modinfo mytest.ko </span><br><span class="line">sudo insmod mytest.ko // 加载</span><br><span class="line">dmesg // 查看日志</span><br><span class="line">lsmod // 查看所有的 module</span><br><span class="line">// /sys/module 包含所有的模块</span><br><span class="line">sudo rmmod mytest // 卸载模块</span><br></pre></td></tr></table></figure></li></ol><h2 id="模块参数使用"><a href="#模块参数使用" class="headerlink" title="模块参数使用"></a>模块参数使用</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra</title>
      <link href="Algorithm/algorithm/dijkstra/"/>
      <url>Algorithm/algorithm/dijkstra/</url>
      
        <content type="html"><![CDATA[<p>本文基于 <a href="https://www.bilibili.com/video/av25829980?from=search&amp;seid=6605585063459234452" target="_blank" rel="noopener">[Python] BFS和DFS算法（第3讲）—— 从BFS到Dijkstra算法</a> 学习整理后所得。<br>对于 BFS 及 DFS 有所不了解的可以看 <a href="../dfs-bfs">BFS(Breadth First Search) 与 DFS (Depth First Search)</a></p><h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><p>Dijkstra 是在 BFS 基础上进行修改而来的，对于 BFS 遍历而言，由于其边的长度只为1，因此只需使用 Queue 即可。但是对于边有权重的图而言，需要考虑每一条边的权重。</p><p>因此，对于 Dijkstra 可以考虑使用 PriorityQueue 来代替 Queue，如此每次便可取出距离最短的点。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757897835902.jpg" width="600" alt title></p><a id="more"></a><h2 id="过程解析"><a href="#过程解析" class="headerlink" title="过程解析"></a>过程解析</h2><p>第一步：将 A:0 放入 PQ<br>第二步：从 PQ 中获取一个节点 A:0， A:0 没有被使用过，且其连接的节点为 B, C。此时将 B:5, C:1 放入 PQ 中，将 A 标记为已使用。<br>第三步：从 PQ 中获取一个节点 C:1 <code>(此时使用优先队列，所以取最近的)</code>，此时与 C 连接的节点为 A, B, D，且 A 被标记使用，需要将 B:3, D:5, E:9 放入 PQ。</p><blockquote><p>这里最关键的一步是，取出 C 点后，需要将 B:3 再放入 PQ 中，PQ 中的数据将变为 [B:5, B:3, D:5, E:9]</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无向图，注意 u, v 可以相互到达</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[][] uvw, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] c : uvw) &#123;</span><br><span class="line">map.putIfAbsent(c[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">map.putIfAbsent(c[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">map.get(c[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; c[<span class="number">2</span>], c[<span class="number">1</span>] &#125;);</span><br><span class="line">map.get(c[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; c[<span class="number">2</span>], c[<span class="number">0</span>] &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">parents[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">// 0: distance, 1: node</span></span><br><span class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] cur = pq.poll();</span><br><span class="line"><span class="keyword">if</span> (used[cur[<span class="number">1</span>]] || !map.containsKey(cur[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">used[cur[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] next : map.get(cur[<span class="number">1</span>])) &#123;</span><br><span class="line"><span class="keyword">if</span> (used[next[<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">parents[next[<span class="number">1</span>]] = cur[<span class="number">1</span>];</span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>]+next[<span class="number">0</span>], next[<span class="number">1</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(parents));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Dijkstra().solution(<span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span> &#125;, &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;, &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">&#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span> &#125;, &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span> &#125; &#125;, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-743"><a href="#LeetCode-743" class="headerlink" title="LeetCode 743"></a>LeetCode 743</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] t : times) &#123;</span><br><span class="line">            graph.putIfAbsent(t[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            graph.get(t[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;t[<span class="number">1</span>], t[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0: distance 1: Node</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, K&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (used[cur[<span class="number">1</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">            used[cur[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">            res = Math.max(res, cur[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!graph.containsKey(cur[<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] next : graph.get(cur[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[next[<span class="number">0</span>]]) <span class="keyword">continue</span>;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>]+next[<span class="number">1</span>], next[<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Segment Tree And Fenwick Tree</title>
      <link href="Algorithm/algorithm/segment-tree-and-fenwick-tree/"/>
      <url>Algorithm/algorithm/segment-tree-and-fenwick-tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文讲解的 FenwickTree 以及 Segment Tree 主要用于解决可变数组中，高效求解范围和的算法。<br>以 <a href="https://leetcode.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">Leetcode 307. Range Sum Query - Mutable</a> 为例进行分析。<br>学习资料来源于：<a href="https://www.bilibili.com/video/av31200591?from=search&amp;seid=2044302429705113819" target="_blank" rel="noopener">花花酱 Fenwick Tree / Binary Indexed Tree - 刷题找工作 SP3</a>、<a href="https://www.youtube.com/watch?v=rYBtViWXYeI&amp;list=PLLuMmzMTgVK5Hy1qcWYZcd7wVQQ1v0AjX&amp;index=4" target="_blank" rel="noopener">花花酱 Segment Tree 线段树 - 刷题找工作 SP14</a>、<a href="https://www.youtube.com/watch?v=e_bK-dgPvfM&amp;t=2s" target="_blank" rel="noopener">线段树 (segment tree)</a>，并结合自身理解进行整理。</p></blockquote><a id="more"></a><h1 id="不可变数组的范围和求解"><a href="#不可变数组的范围和求解" class="headerlink" title="不可变数组的范围和求解"></a>不可变数组的范围和求解</h1><p>对于不可变数组的范围和，我们可以通过预先处理前缀和，然后通过前缀和之间的关系求解。</p><p><a href="https://leetcode.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. Range Sum Query - Immutable</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] prefix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        prefix = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            prefix[i] = prefix[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix == <span class="keyword">null</span> || prefix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> prefix[j] - (i == <span class="number">0</span> ? <span class="number">0</span> : prefix[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于一个可变的数组如何求解前缀和呢？</p><p>譬如有一个数组 <code>[2, 5, -1, 3, 6]</code> 需要实现 <code>update</code> 与 <code>sumRange</code> 函数，此时最简单的实现便是 <code>update</code> 时直接修改 <code>O(1)</code> 时间复杂度， <code>sumRange</code> 时直接遍历计算 <code>O(n)</code> 时间复杂度，这一 naive 的解题思路看着很不错，但实际上在求和时，会有很多的重复解，这便是可以优化的一部分。</p><p>一般常见的优化手段有 <code>FenwickTree</code> 以及 <code>SegmentTree</code>，以下就分别对这两种算法进行详细介绍。</p><h1 id="FenwickTree"><a href="#FenwickTree" class="headerlink" title="FenwickTree"></a>FenwickTree</h1><p>FenwickTree 又称为 Binary Indexed Tree 这是一种特殊的数据结构，能够高效地修改元素并计算数组中的前缀和。</p><p>FenwickTree 一共包含两个函数 <code>update(i, val)</code> 和 <code>query(i)</code>。</p><p>可通过点击<a href="https://visualgo.net/en/fenwicktree" target="_blank" rel="noopener">FenwickTree可视化过程</a>链接，查看整个过程。</p><h2 id="lowBit"><a href="#lowBit" class="headerlink" title="lowBit"></a>lowBit</h2><p>在代码中如何寻找数字中的最低位，这里有一个特别方便的方法，就是通过位运算求解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int lowBit(int x) &#123;</span><br><span class="line">    return x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 x = 5 而言，其二进制位 0101，-x = ~x + 1 = 1010 + 1 = 1011；对 x &amp; (-x) = 0101 &amp; 1011 = 1即所求的最低位。</p><h2 id="update-O-log-n"><a href="#update-O-log-n" class="headerlink" title="update O(log(n))"></a>update O(log(n))</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15756916329768.jpg" width="400" alt title></p><p>在 update 过程中，每一个节点的父节点均为 <code>i+lowBit(i)</code>，每次更新 i 节点时候，均要更新该节点的所有父节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sums.length) &#123;</span><br><span class="line">        sums[i] += val;</span><br><span class="line">        i += lowBit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="query-O-log-n"><a href="#query-O-log-n" class="headerlink" title="query O(log(n))"></a>query O(log(n))</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15756919510067.jpg" width="400" alt title></p><p>在 query 过程中，每一个节点的父节点均为 <code>i-lowBit(i)</code>，若要求得 [0, i] 的和必须添加对应父节点上所有的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += sums[i];</span><br><span class="line">        i -= lowBit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode307"><a href="#LeetCode307" class="headerlink" title="LeetCode307"></a>LeetCode307</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FenwickTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            sums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lowBit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; sums.length) &#123;</span><br><span class="line">                sums[i] += val;</span><br><span class="line">                i += lowBit(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum += sums[i];</span><br><span class="line">                i -= lowBit(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> FenwickTree ft;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        ft = <span class="keyword">new</span> FenwickTree(nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ft.update(i+<span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ft.update(i+<span class="number">1</span>, val - nums[i]);</span><br><span class="line">        nums[i] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ft.query(j+<span class="number">1</span>) - ft.query(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SegmentTree"><a href="#SegmentTree" class="headerlink" title="SegmentTree"></a>SegmentTree</h1><p>Segment Tree 是一个完全二叉树，用于存储区间内对应信息的一种数据结构，该数据结构相较于 FenwickTree 而言，除了处理范围和这一问题，还能解决区间最大、区间最小、区间异或值的处理。</p><p>一般 SegmentTree 有两种实现方法，第一种是 Tree 实现，第二种类似堆使用数组。</p><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15756948931435.jpg" width="400" alt title></p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, nums[i], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (j-i)/<span class="number">2</span> + i;</span><br><span class="line">    Node left = buildSegmentTree(i, mid, nums);</span><br><span class="line">    Node right = buildSegmentTree(mid+<span class="number">1</span>, j, nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, left.sum+right.sum, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == i) &#123;</span><br><span class="line">        node.sum = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= mid) update(node.left, i, val);</span><br><span class="line">    <span class="keyword">else</span> update(node.right, i, val);</span><br><span class="line">    node.sum = node.left.sum + node.right.sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queryRange"><a href="#queryRange" class="headerlink" title="queryRange"></a>queryRange</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">queryRange</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == j) <span class="keyword">return</span> node.sum;</span><br><span class="line">    <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= mid) <span class="keyword">return</span> queryRange(node.left, i, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) <span class="keyword">return</span> queryRange(node.right, i, j);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> queryRange(node.left, i, mid) + queryRange(node.right, mid+<span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode307-1"><a href="#LeetCode307-1" class="headerlink" title="LeetCode307"></a>LeetCode307</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node left, right;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sum, start, end;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span> <span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> sum, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.sum = sum;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        root = buildSegmentTree(<span class="number">0</span>, nums.length-<span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">buildSegmentTree</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, nums[i], <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">int</span> mid = (j-i)/<span class="number">2</span> + i;</span><br><span class="line">        Node left = buildSegmentTree(i, mid, nums);</span><br><span class="line">        Node right = buildSegmentTree(mid+<span class="number">1</span>, j, nums);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(i, j, left.sum+right.sum, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update(root, i, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == i) &#123;</span><br><span class="line">            node.sum = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid) update(node.left, i, val);</span><br><span class="line">        <span class="keyword">else</span> update(node.right, i, val);</span><br><span class="line">        node.sum = node.left.sum + node.right.sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queryRange(root, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">queryRange</span><span class="params">(Node node, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.start == i &amp;&amp; node.end == j) <span class="keyword">return</span> node.sum;</span><br><span class="line">        <span class="keyword">int</span> mid = (node.end - node.start) / <span class="number">2</span> + node.start;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= mid) <span class="keyword">return</span> queryRange(node.left, i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) <span class="keyword">return</span> queryRange(node.right, i, j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> queryRange(node.left, i, mid) + queryRange(node.right, mid+<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>以数组为蓝本的线段树，相对于上面而言有一个比较不直观的地方，若通过画图显示则可以表示成以下。<br>以 [1,2,3,4,5,6,7,8,9] 作为基础数据。</p><h3 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757009281208.jpg" width="400" alt title></p><ol><li>新建数组，tree = new int[2*n];</li><li>将 nums[i] 数据写到 tree[i+n]</li><li>更新每一个数据节点</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] buildTree(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[n*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; n*<span class="number">2</span>; i++, j++) &#123;</span><br><span class="line">        tree[i] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        tree[i] = tree[i*<span class="number">2</span>] + tree[i*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="update-1"><a href="#update-1" class="headerlink" title="update"></a>update</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757011755538.jpg" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    pos += n;</span><br><span class="line">    tree[pos] = val;</span><br><span class="line">    <span class="keyword">while</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = pos, right = pos;</span><br><span class="line">        <span class="keyword">if</span> ((pos % <span class="number">2</span>) == <span class="number">0</span>) &#123; <span class="comment">// pos is left</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// pos is right</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[pos / <span class="number">2</span>] = tree[left] + tree[right];</span><br><span class="line">        pos /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sumRange"><a href="#sumRange" class="headerlink" title="sumRange"></a>sumRange</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15757016154110.jpg" width="400" alt title></p><p>在求和时候，若 left 为偶数，则可以直接考虑其父节点，若 left 为奇数则需要单独加上该节点。<br>同理，若 right 为奇数，则可以直接考虑其父节点，若 right 为偶数则需要单独加上该节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    left += n; right += n;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((left % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            sum += tree[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((right % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += tree[right--];</span><br><span class="line">        &#125;</span><br><span class="line">        left /= <span class="number">2</span>;</span><br><span class="line">        right /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-307"><a href="#LeetCode-307" class="headerlink" title="LeetCode 307"></a>LeetCode 307</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        tree = buildTree(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] buildTree(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n, j = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++, j++) &#123;</span><br><span class="line">            tree[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tree[i] = tree[i*<span class="number">2</span>] + tree[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        i += n;</span><br><span class="line">        tree[i] = val;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">0</span>) right++;</span><br><span class="line">            <span class="keyword">else</span> left--;</span><br><span class="line">            tree[i / <span class="number">2</span>] = tree[left] + tree[right];</span><br><span class="line">            i /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        i += n; j+= n;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                sum += tree[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((j % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                sum += tree[j--];</span><br><span class="line">            &#125;</span><br><span class="line">            i /= <span class="number">2</span>;</span><br><span class="line">            j /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SegmentTree </tag>
            
            <tag> FenwickTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topological Sort</title>
      <link href="Algorithm/algorithm/topological-sort/"/>
      <url>Algorithm/algorithm/topological-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h1><p>Topological Sort 算法用于解决有向无环图 (DAG, directed acyclic graph) 中的依赖解析问题。<br>在一系列有先后顺序的任务中，运用 Topological Sort 可以得到满足执行顺序限制条件的一系列任务所需执行的先后顺序。</p><p>参考文档:</p><p><a href="https://www.geeksforgeeks.org/topological-sorting/" target="_blank" rel="noopener">Topological Sort(DFS)</a><br><a href="https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/" target="_blank" rel="noopener">Topological Sort(Kahn’s)</a><br><a href="https://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/" target="_blank" rel="noopener">All Topological Sorts</a></p><p><a href="https://github.com/klutzoder/leetcodeLab/blob/master/mycode/TopoSorted.java" target="_blank" rel="noopener">参考代码</a></p><a id="more"></a><h2 id="DAG-说明"><a href="#DAG-说明" class="headerlink" title="DAG 说明"></a>DAG 说明</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15743254823090.jpg" width="400" alt title></p><p>上图是一个典型的 DAG，可以使用 Graph 类进行存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V; <span class="comment">// vertex，顶点数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; adj[]; <span class="comment">// edges, 边</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> List&lt;Integer&gt;[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adj[v].add(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Graph g = <span class="keyword">new</span> Graph(<span class="number">6</span>);</span><br><span class="line">g.addEdge(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">g.addEdge(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">g.addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">g.addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">g.addEdge(<span class="number">3</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="基于-DFS-的拓扑排序"><a href="#基于-DFS-的拓扑排序" class="headerlink" title="基于 DFS 的拓扑排序"></a>基于 DFS 的拓扑排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">topoSortByDFS</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> visited[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.V];</span><br><span class="line">    Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(g.V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.V; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) dfs(i, g, visited, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(g.V);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) res.add(stack.pop());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, Graph g, <span class="keyword">boolean</span>[] visited, Deque&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">    visited[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : g.ajd[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) dfs(i, g, visited, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kahn’s-Topological-Sort"><a href="#Kahn’s-Topological-Sort" class="headerlink" title="Kahn’s Topological Sort"></a>Kahn’s Topological Sort</h2><ol><li>入度: 设 DAG 有一个节点 v, 入度即为当前所有从其他节点出发，终点为 v 的边的数目。</li><li>出度: 设 DAG 有一个节点 v, 出度即为从 v 出发，到所有其他节点的边的数。</li><li>Kahn 算法核心思想为不断寻找入度为 0 的节点，入度为 0 表示当前节点不依赖其他节点或者当前节点依赖的节点已完成相应操作。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">topoSortByKahn</span><span class="params">(Graph g)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.V; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[v]) &#123;</span><br><span class="line">            inDegree[w]++; <span class="comment">// 每个节点的入度</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; g.V; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) queue.offer(v);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">        res.add(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[v]) &#123;</span><br><span class="line">            inDegree[w]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[w] == <span class="number">0</span>) queue.offer(w);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Find-all-TopoSort-of-DAG"><a href="#Find-all-TopoSort-of-DAG" class="headerlink" title="Find all TopoSort of DAG"></a>Find all TopoSort of DAG</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; findAllTopoSort(Graph g) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[g.V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; g.V; u++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[u]) inDegree[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.V];</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    findAllTopoSortOrder(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), g, inDegree, visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAllTopoSortOrder</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; temp, Graph g, <span class="keyword">int</span>[] inDegree, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; g.V; u++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[u] != <span class="number">0</span> || visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : g.adj[u]) inDegree[w]--;</span><br><span class="line">        temp.add(u);</span><br><span class="line">        visited[u] = <span class="keyword">true</span>;</span><br><span class="line">        findAllTopoSortOrder(res, temp, g, inDegree, visited);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w  : g.adj[u]) inDegree[w]++;</span><br><span class="line">        visited[u] = <span class="keyword">false</span>;</span><br><span class="line">        temp.remove(temp.size()-<span class="number">1</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (temp.size() == g.V) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="LeetCode-207"><a href="#LeetCode-207" class="headerlink" title="LeetCode 207"></a>LeetCode 207</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            map.putIfAbsent(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">            inDegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : map.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">                inDegree[j]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[j] == <span class="number">0</span>) queue.offer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-210"><a href="#LeetCode-210" class="headerlink" title="LeetCode 210"></a>LeetCode 210</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            map.putIfAbsent(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">            inDegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            res[size++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : map.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">                inDegree[j]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[j] == <span class="number">0</span>) queue.offer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span> ? res : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-269"><a href="#LeetCode-269" class="headerlink" title="LeetCode 269"></a>LeetCode 269</h2><p>该题目看懂题目很重要！！！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length() &amp;&amp; j &lt; words[i + <span class="number">1</span>].length(); j++) &#123;</span><br><span class="line">                <span class="comment">//如果字符相同，比较下一个</span></span><br><span class="line">                <span class="keyword">char</span> u = words[i].charAt(j), w = words[i + <span class="number">1</span>].charAt(j);</span><br><span class="line">                <span class="keyword">if</span> (u == w) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//保存第一个不同的字符顺序</span></span><br><span class="line">                graph.putIfAbsent(u, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                graph.get(u).add(w);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(inDegree, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[c-<span class="string">'a'</span>] == -<span class="number">1</span>) count++;</span><br><span class="line">                inDegree[c-<span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : graph.keySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> next : graph.get(c)) &#123;</span><br><span class="line">                inDegree[next-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[c-<span class="string">'a'</span>] == <span class="number">0</span>) queue.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Character c = queue.poll();</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">for</span> (Character next : graph.getOrDefault(c, <span class="keyword">new</span> HashSet&lt;&gt;())) &#123;</span><br><span class="line">                inDegree[next-<span class="string">'a'</span>]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[next-<span class="string">'a'</span>] == <span class="number">0</span>) queue.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(count);</span></span><br><span class="line">        <span class="comment">// System.out.println(sb.toString());</span></span><br><span class="line">        <span class="keyword">return</span> sb.length() == count ? sb.toString() : <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-1203"><a href="#LeetCode-1203" class="headerlink" title="LeetCode 1203"></a>LeetCode 1203</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortItems(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[] group, List&lt;List&lt;Integer&gt;&gt; beforeItems) &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; itemGraph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; itemInDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) itemGraph.putIfAbsent(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; groupGraph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; groupInDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : group) groupGraph.putIfAbsent(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> after = <span class="number">0</span>; after &lt; n; after++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> before : beforeItems.get(after)) &#123;</span><br><span class="line">                itemGraph.get(before).add(after);</span><br><span class="line">                itemInDegree.put(after, itemInDegree.getOrDefault(after, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> gbefore = group[before];</span><br><span class="line">                <span class="keyword">int</span> gafter = group[after];</span><br><span class="line">                <span class="keyword">if</span> (gbefore != gafter &amp;&amp; groupGraph.get(gbefore).add(gafter)) &#123;</span><br><span class="line">                    groupInDegree.put(gafter, groupInDegree.getOrDefault(gafter, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; itemList = topologicalSort(itemGraph, itemInDegree);</span><br><span class="line">        List&lt;Integer&gt; groupList = topologicalSort(groupGraph, groupInDegree);</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(itemList.toArray()));</span></span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(groupList.toArray()));</span></span><br><span class="line">        <span class="keyword">if</span> (itemList.size() == <span class="number">0</span> || groupList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : itemList) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = group[item];</span><br><span class="line">            map.putIfAbsent(g, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(g).add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> g : groupList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> item : map.get(g)) &#123;</span><br><span class="line">                res[i++] = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">topologicalSort</span><span class="params">(Map&lt;Integer, Set&lt;Integer&gt;&gt; graph, Map&lt;Integer, Integer&gt; inDegree)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : graph.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree.getOrDefault(i, <span class="number">0</span>) == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> item = queue.poll();</span><br><span class="line">            res.add(item);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(item)) &#123;</span><br><span class="line">                inDegree.put(next, inDegree.getOrDefault(next, <span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (inDegree.get(next) == <span class="number">0</span>) queue.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size() == graph.size() ? res : <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TopoSort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Union Find</title>
      <link href="Algorithm/algorithm/union-find/"/>
      <url>Algorithm/algorithm/union-find/</url>
      
        <content type="html"><![CDATA[<h1 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union Find"></a>Union Find</h1><p>并查集原理，主要参考：<br><a href="https://www.youtube.com/watch?v=YKE4Vd1ysPI&amp;t=6s" target="_blank" rel="noopener">并查集（Disjoint-set union）第1讲</a><br><a href="https://www.youtube.com/watch?v=gpmOaSBcbYA" target="_blank" rel="noopener">并查集（Disjoint-set union）第2讲</a><br><a href="https://www.youtube.com/watch?v=VJnUwsE4fWA&amp;t=4s" target="_blank" rel="noopener">花花酱 Disjoint-set/Union-find Forest</a></p><p>学习整理后完成。</p><a id="more"></a><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15732880108758.jpg" width="400" alt title></p><p>对于一个无向图，我们要如何才能找到是否存在环。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15732880663166.jpg" width="400" alt title></p><p>由图可知，我们通过构建 parent 数组，将各个节点关系使用有向图的形式进行构建。当遇到无法 union 的时候，表示两个节点具有相同的父节点，即寻找到环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parents = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        Arrays.fill(<span class="keyword">this</span>.parents, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = x;</span><br><span class="line">        <span class="keyword">while</span> (parents[root] != -<span class="number">1</span>) &#123;   </span><br><span class="line">            root = parents[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = findRoot(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = findRoot(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        parents[xRoot] = yRoot;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>以上不难看出，当数据量较大时候， <code>findRoot</code> 函数，将执行许多遍，并且都是无效的查找。如果我们在查找过程中，直接将其指向根节点，使得树深度变低，能够很好的加快查询效率。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15732885647780.jpg" width="400" alt title></p><p>此时对上面代码作出修改，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parents;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parents = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root = x;</span><br><span class="line">        <span class="keyword">while</span> (parents[root] != root) &#123;   </span><br><span class="line">            parents[root] = parents[parents[root]];</span><br><span class="line">            root = parents[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xRoot = findRoot(x);</span><br><span class="line">        <span class="keyword">int</span> yRoot = findRoot(y);</span><br><span class="line">        <span class="keyword">if</span> (xRoot == yRoot) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        parents[xRoot] = yRoot;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="LeetCode-547-Friend-Circles"><a href="#LeetCode-547-Friend-Circles" class="headerlink" title="LeetCode 547 Friend Circles"></a>LeetCode 547 Friend Circles</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = M.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) uf.union(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) set.add(uf.findRoot(i));</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-684-Redundant-Connection"><a href="#LeetCode-684-Redundant-Connection" class="headerlink" title="LeetCode 684 Redundant Connection"></a>LeetCode 684 Redundant Connection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = edges.length;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uf.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode-733-Sentence-Similarity-II"><a href="#LeetCode-733-Sentence-Similarity-II" class="headerlink" title="LeetCode 733 Sentence Similarity II"></a>LeetCode 733 Sentence Similarity II</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (words1 == <span class="keyword">null</span> || words2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (words1.length != words2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : words1) map.putIfAbsent(s, size++);</span><br><span class="line">    <span class="keyword">for</span> (String s : words2) map.putIfAbsent(s, size++);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ls : pairs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : ls) map.putIfAbsent(s, size++);</span><br><span class="line">    &#125;</span><br><span class="line">    UnionFind uf = <span class="keyword">new</span> UnionFind(size);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;String&gt; ls : pairs) &#123;</span><br><span class="line">        uf.union(map.get(ls.get(<span class="number">0</span>)), map.get(ls.get(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = uf.findRoot(map.get(words1[i]));</span><br><span class="line">        <span class="keyword">int</span> root2 = uf.findRoot(map.get(words2[i]));</span><br><span class="line">        <span class="keyword">if</span> (root1 != root2) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode Minimax (486, 877)</title>
      <link href="Leetcode/leetcode/leetcode-Minimax/"/>
      <url>Leetcode/leetcode/leetcode-Minimax/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-486-877"><a href="#Leetcode-486-877" class="headerlink" title="Leetcode 486, 877"></a>Leetcode 486, 877</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p><p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 233, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。</span><br><span class="line">最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15731385926484.jpg" width="400" alt title></p><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> score(s, <span class="number">0</span>, n-<span class="number">1</span>) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">score</span><span class="params">(s, l, r)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l &gt; r : return 0</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l </span>== r : <span class="keyword">return</span> s[l]</span><br><span class="line">    <span class="keyword">return</span> max(s[l] - score(s,l+<span class="number">1</span>,r), </span><br><span class="line">                s[r] - score(s,l,r-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>以上函数是最直观的认识，每一次都取最大的分数。<br>该算法时间复杂度 $O(2^n)$，空间复杂度为$O(n)$。</p><h3 id="Recursive-Memory"><a href="#Recursive-Memory" class="headerlink" title="Recursive + Memory"></a>Recursive + Memory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> score(s, <span class="number">0</span>, n-<span class="number">1</span>) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">score</span><span class="params">(s, l, r, m)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l &gt; r : return 0</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> l </span>== r : <span class="keyword">return</span> s[l]</span><br><span class="line">    <span class="keyword">if</span> m[l][r] : <span class="keyword">return</span> m[l][r]</span><br><span class="line">    <span class="keyword">return</span> max(s[l] - score(s,l+<span class="number">1</span>,r), </span><br><span class="line">                s[r] - score(s,l,r-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>dp[i][j] 表示 i~j 最好的分数。</p><script type="math/tex; mode=display">dp[i][j] = max\begin{cases}nums[i]-dp[i+1][j]\\nums[j]-dp[i][j-1]\\\end{cases},i = n\to 0, j = i+1 \to n</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stoneGame</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.max(nums[i] - dp[i+<span class="number">1</span>][j],</span><br><span class="line">                                nums[j] - dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Minimax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack And PC</title>
      <link href="Linux/linux/stack-and-pc/"/>
      <url>Linux/linux/stack-and-pc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>知识得来终觉浅，因此还是应该将收获的知识记录下来比较有用。<br>本文主要在 X86 体系结构下，函数栈调用的过程以及 PC 变化过程，以此对 C/C++、Java 等高级语言中的函数有一个深刻的认识。<br>本文使用 64 位编译器进行编译。主要讲函数栈调用及 PC 变化过程，其他基础知识仅提及而不深入讲解。</p></blockquote><p>参考资料：</p><ol><li><a href="https://heamon7.gitbooks.io/cscw2-newly-to-assembly/content/" target="_blank" rel="noopener">C程序的汇编</a></li><li><a href="https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf" target="_blank" rel="noopener">Introduction_to_x64_Assembly</a></li></ol><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h2><p>X64 提供了 16 个通用寄存器，分别为 <code>%rax，%rbx，%rcx，%rdx，%rsi，%rdi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15</code>。<br>在 C 语言调用时输入参数前6位依次使用 <code>rdi, rsi, rdx, rcx, r8, r9</code> 寄存器，后面的参数压栈使用。<br>在 C 语言中返回结果一律记在 <code>rax</code> 中进行返回。</p><blockquote><p>caller register: <code>rax, rcx, rdx, r8, r9, r10, r11</code><br>callee register: <code>rbx, rbp, rdi, rsi, rsp, r12, r13, r14</code></p></blockquote><p>关键寄存器说明，以下三个指针在程序运行过程中起着关键的作用。</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>说明</th></tr></thead><tbody><tr><td>rbp</td><td>基指针</td></tr><tr><td>rsp</td><td>栈指针</td></tr><tr><td>rip</td><td>程序计数器</td></tr></tbody></table></div><h2 id="GDB-基础命令"><a href="#GDB-基础命令" class="headerlink" title="GDB 基础命令"></a>GDB 基础命令</h2><p>以下只给出部分实验中需要使用到的命令，具体命令可查看相应的手册。</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>i r a</td><td>info register all，查看所有寄存器中数据</td></tr><tr><td>i r rax</td><td>info register rax， 查看指定寄存器数据</td></tr><tr><td>n</td><td>next 执行下一条指令，函数直接执行而不进入</td></tr><tr><td>s</td><td>step 进入函数内部调试</td></tr><tr><td>b func/34</td><td>breakpoint 断点</td></tr><tr><td>r</td><td>run 运行</td></tr><tr><td>disas</td><td>disassem 反汇编，将机器码转为汇编便于阅读</td></tr><tr><td>si，ni</td><td>针对汇编</td></tr></tbody></table></div><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><ol><li><p>编译，将 C 语言编译为汇编代码。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S add.c -o add.s</span><br></pre></td></tr></table></figure></li><li><p>链接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g add.c -o add</span><br></pre></td></tr></table></figure></li><li><p>相关参数</p><ul><li>-o：指定生成的输出文件；</li><li>-E：仅执行编译预处理；</li><li>-S：将C代码转换为汇编代码；</li><li>-Wall：显示警告信息；</li><li>-c：仅执行编译操作，不进行连接操作。</li><li>-g：表示在生成的目标文件中带调试信息</li></ul></li></ol><h2 id="Linux-X64-内存空间结构"><a href="#Linux-X64-内存空间结构" class="headerlink" title="Linux X64 内存空间结构"></a>Linux X64 内存空间结构</h2><p>在 X64 系统架构中，只使用 48 根地址线，虚拟内存空间划分时将 <code>0xFFFF0000~00000000——0xFFFFFFFF~FFFFFFFF</code> 划分给内核使用，<code>0x00000000~00000000——0x0000FFFF~FFFFFFFF</code> 划分给进程使用。</p><p>进程分布图如下所示：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727708191411.jpg" width="600" alt title></p><h1 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h1><blockquote><p>实验均在 Linux 系统中进行</p></blockquote><h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C 代码"></a>C 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = sub(a, b);</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, res;</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    res = add(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h2><p>通过调用 <code>gcc -S add.c -o add.s</code> 可获得相应的汇编代码如下所示。</p><blockquote><p>去除无关对齐代码后！！！自己编译后的代码有很多的对齐代码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.file <span class="string">"add.c"</span></span><br><span class="line">.text</span><br><span class="line">.globl sub</span><br><span class="line">.type sub, @function</span><br><span class="line">sub:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq %rsp, %rbp</span><br><span class="line">    movl %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    subl <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    popq %rbp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl add</span><br><span class="line">.type add, @function</span><br><span class="line">add:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq %rsp, %rbp</span><br><span class="line">    subq $<span class="number">8</span>, %rsp</span><br><span class="line">    movl %edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl %esi, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl <span class="number">-4</span>(%rbp), %eax</span><br><span class="line">    movl %edx, %esi</span><br><span class="line">    movl %eax, %edi</span><br><span class="line">    call sub</span><br><span class="line">    movl %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl <span class="number">-4</span>(%rbp), %edx</span><br><span class="line">    movl <span class="number">-8</span>(%rbp), %eax</span><br><span class="line">    addl %edx, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">.globl main</span><br><span class="line">.type main, @function</span><br><span class="line">main:</span><br><span class="line">    pushq %rbp</span><br><span class="line">    movq %rsp, %rbp</span><br><span class="line">    subq $<span class="number">32</span>, %rsp</span><br><span class="line">    movl %edi, <span class="number">-20</span>(%rbp)</span><br><span class="line">    movq $rsi, <span class="number">-32</span>(%rbp)</span><br><span class="line">    movl $<span class="number">3</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">    movl $<span class="number">2</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">    movl <span class="number">-8</span>(%rbp), %edx</span><br><span class="line">    movl <span class="number">-12</span>(%rbp), %eax</span><br><span class="line">    movl %edx, %esi</span><br><span class="line">    movl %eax, %edi</span><br><span class="line">    call add</span><br><span class="line">    movl %eax, <span class="number">-4</span>(%rbp)</span><br><span class="line">    movl $<span class="number">0</span>, %eax</span><br><span class="line">    leav</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="C-与汇编联合编译"><a href="#C-与汇编联合编译" class="headerlink" title="C 与汇编联合编译"></a>C 与汇编联合编译</h2><blockquote><p>实验所需要的三个文件在下面提供下载，可直接点击下载，并在同一个文件夹中。以便实验室用。</p></blockquote><p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/main.c" target="_blank" rel="noopener">main.c 点击下载</a></p><p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/add.s" target="_blank" rel="noopener">add.s 点击下载</a></p><p><a href="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/makefile" target="_blank" rel="noopener">makefile 点击下载</a></p><h1 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h1><ol><li>下载 main.c, add.s, makefile 到同一文件夹中。</li><li>执行 <code>make</code> 命令完成代码编译链接，生产 test 执行文件。ps: <code>make clean</code> 用于清理。</li></ol><h2 id="运行到-add-函数调用前"><a href="#运行到-add-函数调用前" class="headerlink" title="运行到 add 函数调用前"></a>运行到 add 函数调用前</h2><ol><li>gdb --tui ./test</li><li>b main</li><li>r</li><li>b 16</li><li>c</li><li>disas 查看当前运行到的汇编位置，并用 ni 执行一条汇编，一点点执行，直到运行到 <code>0x000000000040054d &lt;+39&gt;: callq 0x400582 &lt;add&gt;</code></li></ol><p>此时查看堆栈寄存器 <code>rbp, rsp</code> 数据以及 程序计数器(pc)寄存器 <code>rip</code> 数据。</p><ul><li><p>查看 rbp, <code>i r rbp</code></p><p> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727700739966.jpg" width="600" alt title></p></li><li><p>查看 rsp, <code>i r rsp</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727700466006.jpg" width="600" alt title></p></li><li><p>查看 rip, <code>i r rip</code><br>   <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727722408396.jpg" width="600" alt title></p></li><li><p>查看当前上下文汇编代码, <code>disas</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function main:</span><br><span class="line">        0x0000000000400526 &lt;+0&gt;:     push   %rbp</span><br><span class="line">        0x0000000000400527 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">        0x000000000040052a &lt;+4&gt;:     sub    $0x20,%rsp</span><br><span class="line">        0x000000000040052e &lt;+8&gt;:     mov    %edi,-0x14(%rbp)</span><br><span class="line">        0x0000000000400531 &lt;+11&gt;:    mov    %rsi,-0x20(%rbp)</span><br><span class="line">        0x0000000000400535 &lt;+15&gt;:    movl   $0x3,-0xc(%rbp)</span><br><span class="line">        0x000000000040053c &lt;+22&gt;:    movl   $0x2,-0x8(%rbp)</span><br><span class="line">        0x0000000000400543 &lt;+29&gt;:    mov    -0x8(%rbp),%edx</span><br><span class="line">        0x0000000000400546 &lt;+32&gt;:    mov    -0xc(%rbp),%eax</span><br><span class="line">        0x0000000000400549 &lt;+35&gt;:    mov    %edx,%esi</span><br><span class="line">        0x000000000040054b &lt;+37&gt;:    mov    %eax,%edi</span><br><span class="line">    =&gt;  0x000000000040054d &lt;+39&gt;:    callq  0x400582 &lt;add&gt;</span><br><span class="line">        0x0000000000400552 &lt;+44&gt;:    mov    %eax,-0x4(%rbp)</span><br></pre></td></tr></table></figure></li></ul><p>从上面查到的几个信息中，我们可以看到 rbp=0x00007fffffffe460; rsp=0x00007fffffffe440; rip=0x000000000040054d<br>这与我们认知的程序的代码分布一致。栈由高地址空间0x0000FFFFFFFFFFFF 向下扩展，代码段由低地址空间向上排列。<br>在这里为何 rsp 比 rbp 小0x20，这与 <code>sub $0x20, %rsp</code> 这一指令相关，该指令通过计算当前栈帧所需栈大小从而预留使用空间，当然此时 0x20 是要大于实际所需要空间大小的。<br>通过计算实际 main 函数中，只有 a(int)、b(int)、res(int)、argc(int)、argv(char <em>)，int 使用 4 bytes，char </em> 使用 8 bytes，实际只需要 24 bytes即可，但此时却分配 32 bytes，这与<code>内存对齐</code>有关，如果对 Cache 相关知识有一定理解的话，应该能够明白是怎么回事。</p><p>此时有必要将当前整个栈结构画出来，可以通过 <code>x/20x 0x00007fffffffe440</code> 查看相应的内存数据。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727731848845.jpg" width="600" alt title></p><p>画成栈图如下所示：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727730260019.jpg" width="300" alt title></p><ol><li>当前 rip: 400543, 下一条pc是 400552。<code>要注意调用 call 函数后是如何压栈的！！！！！记住400552这条数据！！！！</code></li><li>各个参数对应的内存位置在图中已标出，很明显能够发现有部分空余空间没事使用。验证之前提到的，为了内存对齐存在内存浪费。</li></ol><h2 id="调用-callq-add，进入-add-函数"><a href="#调用-callq-add，进入-add-函数" class="headerlink" title="调用 callq add，进入 add 函数"></a>调用 callq add，进入 add 函数</h2><ol><li>s </li></ol><p>此时，我们重新看一下栈内存的数据，栈指针信息，以及 pc 信息。</p><ul><li><p>查看 rbp, <code>i r rbp</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727736800515.jpg" width="600" alt title></p></li><li><p>查看 rsp, <code>i r rsp</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727736963729.jpg" width="600" alt title></p></li><li><p>查看 rip, <code>i r rip</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727737126609.jpg" width="600" alt title></p></li><li><p>查看栈内存数据, <code>x/20x 0x00007fffffffe430</code><br>  <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727737676013.jpg" width="600" alt title></p></li></ul><p>画成栈图如下所示：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727739632434.jpg" width="300" alt title></p><ol><li>callq add, 相当于执行 pushq nextpc; jmp add</li><li>callq add, 将下一条需要执行的 PC 压入栈中！！</li></ol><h2 id="add-栈帧初始化"><a href="#add-栈帧初始化" class="headerlink" title="add 栈帧初始化"></a>add 栈帧初始化</h2><p>所谓 add 栈帧初始化，就是将 rbp、rsp 进行整理，为 add 函数执行做准备。主要指令如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp      <span class="comment">// 将rbp压栈</span></span><br><span class="line">movq %rsp, %rbp <span class="comment">// rsp 与 rbp 指向同一地址</span></span><br><span class="line">subq $<span class="number">8</span>, %rsp   <span class="comment">// 计算 add 所需内存空间</span></span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727747048766.jpg" width="600" alt title></p><p>执行完以上三条指令后，新的栈图如下：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727747316115.jpg" width="300" alt title></p><h2 id="运行到-sub-函数运行前"><a href="#运行到-sub-函数运行前" class="headerlink" title="运行到 sub 函数运行前"></a>运行到 sub 函数运行前</h2><ol><li>b 26</li><li>c</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727750724409.jpg" width="600" alt title></p><p>新的栈图如下：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727751660036.jpg" width="300" alt title></p><h2 id="调用-callq-sub-进入-sub-函数"><a href="#调用-callq-sub-进入-sub-函数" class="headerlink" title="调用 callq sub, 进入 sub 函数"></a>调用 callq sub, 进入 sub 函数</h2><ol><li>s</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727754090560.jpg" width="600" alt title></p><p>新的栈图如下：</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727756659616.jpg" width="300" alt title></p><h2 id="sub-栈帧初始化"><a href="#sub-栈帧初始化" class="headerlink" title="sub 栈帧初始化"></a>sub 栈帧初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp      <span class="comment">// 将rbp压栈</span></span><br><span class="line">movq %rsp, %rbp <span class="comment">// rsp 与 rbp 指向同一地址</span></span><br></pre></td></tr></table></figure><blockquote><p>这里有一点要特别注意，在 add 中，我们会使用 <code>subq $8, %rsp</code> 初始化一个栈空间，但在这里没有进行这一操作，原因在于 add 函数中需要调用 sub 函数，而 sub 函数中不需要调用任何函数。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727759037491.jpg" width="600" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727759536263.jpg" width="300" alt title></p><h2 id="运行到-sub-popq-rbp-之前"><a href="#运行到-sub-popq-rbp-之前" class="headerlink" title="运行到 sub popq %rbp 之前"></a>运行到 sub popq %rbp 之前</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727762610279.jpg" width="600" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727762661166.jpg" width="300" alt title></p><h2 id="popq-rbp"><a href="#popq-rbp" class="headerlink" title="(*) popq %rbp"></a>(*) popq %rbp</h2><p>由于当前 rsp, rbp 都指向 0x00007fff~ffffe418，此时调用 <code>popq %rbp</code> 相当于执行 以下两条指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq +8(%rsp), %rbp</span><br><span class="line">addq $8, %rsp</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727767223708.jpg" width="300" alt title></p><h2 id="ret-退出-sub-函数"><a href="#ret-退出-sub-函数" class="headerlink" title="(*) ret 退出 sub 函数"></a>(*) ret 退出 sub 函数</h2><p>ret 实际做的就是恢复 rip 指向原函数需要执行的代码。相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq +8(%rsp), %rip</span><br><span class="line">addq $8, %rsp</span><br><span class="line">jmp %rip</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727770628739.jpg" width="300" alt title></p><p>此时 <code>rsp, rbp</code> 恢复到调用 sub 函数之前的状态。</p><h2 id="leaveq"><a href="#leaveq" class="headerlink" title="(*) leaveq"></a>(*) leaveq</h2><p>leaveq 相当于以下两条指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq %rbp, %rsp</span><br><span class="line">popq %rbp</span><br></pre></td></tr></table></figure></p><p>与上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pushq %rbp</span><br><span class="line">movq %rsp, %rbp</span><br></pre></td></tr></table></figure></p><p>对应。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727776222080.jpg" width="300" alt title></p><h2 id="ret-退出-add-函数"><a href="#ret-退出-add-函数" class="headerlink" title="(*) ret 退出 add 函数"></a>(*) ret 退出 add 函数</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727788240846.jpg" width="300" alt title></p><h1 id="实验整体过程"><a href="#实验整体过程" class="headerlink" title="实验整体过程"></a>实验整体过程</h1><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-stack-and-pc/15727788811916.jpg" alt title></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可能以上的过程写的比较繁杂，但是如果细细看，并且能够将最后整个栈过程完整画出来的话，应该能够对函数调用有一个十分深刻的印象。<br>PS：如果需要的话，后期我可以录制一个视频，详细讲解下相关的知识，以做备份。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer CPU</title>
      <link href="Linux/linux/computer-cpu/"/>
      <url>Linux/linux/computer-cpu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍 CPU 如何一步一步进行优化，最终成为当前这样的体系架构。<br>本文知识主要来源于 <a href="https://time.geekbang.org/column/article/91427" target="_blank" rel="noopener">深入浅出计算机组成原理</a> 、<code>计算机体系结构（量化研究方法）</code> 、<code>计算机组成与设计硬件/软件接口</code>。</p></blockquote><h1 id="CPU-性能与功耗"><a href="#CPU-性能与功耗" class="headerlink" title="CPU 性能与功耗"></a>CPU 性能与功耗</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ol><li>响应时间（执行时间），表示程序运行所需要的时间，体现了 CPU 运行速度。</li><li>吞吐率（带宽），表示程序运行能够处理的数据，体现了 CPU 处理数据的能力。</li></ol><p><code>响应时间</code>可以由以下公式决定：</p><script type="math/tex; mode=display">CPU时间 = 指令数 \times  CPI \times  时钟频率</script><ul><li>指令数：Instruction Num，由编译器以及程序员决定。</li><li>CPI(Cycles Per Instruction)：每个指令周期，通过 PipeLine、超流水线 等技术使得一条指令所需 CPU Cycle 尽可能地低。<em>对 CPI 的优化是计算机体系结构中最重要的一环</em>。</li><li>时钟频率：Clock Cycle Time，由计算机主频决定。</li></ul><p><code>吞掉量</code>通过超标量(Superscalar)、超线程、SIMD 等技术在不改变<code>响应时间</code>基础上，使得系统在相同时间内能够处理更多的数据。</p><a id="more"></a><h2 id="功耗"><a href="#功耗" class="headerlink" title="功耗"></a>功耗</h2><p>我们的 CPU，一般被被叫做超大规模集成电路(Very Large Scale Integration, VLSI)，CPU 实际是由大量的集成电路组成。<code>功耗</code>公式如下:</p><script type="math/tex; mode=display">功耗  \approx 1/2 \times 负载电容 \times 电压^{2} \times 晶体管数量</script><p>提高 CPU 主频则需要加大电压、增加晶体管，这将导致功耗不断上升，所有元器件均有熔点，因此我们不能不断地增大功耗。这就是<code>功耗墙</code>的来源。</p><p>既然，我们无法通过不断增加频率来提高 CPU 的“响应时间”，因此有人就提出了提高“吞吐率”使 CPU 在相同时间内能够处理更多的数据，即<code>通过并行提升性能</code>。</p><p>但是程序的并行度也不是能够一直提升的，这就涉及到 <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank" rel="noopener">Amdahl’s Law</a>，即优化后的执行时间也是有上限的，该部分主要受无法并行化的代码所花费时间的影响。</p><script type="math/tex; mode=display">优化后的执行时间 = 受优化影响的执行时间/加倍速度 + 不受影响的执行时间</script><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728507499351.jpg" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728508178762.jpg" width="400" alt title></p><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><h1 id="CPU-的优化"><a href="#CPU-的优化" class="headerlink" title="CPU 的优化"></a>CPU 的优化</h1><h2 id="单指令周期-CPU"><a href="#单指令周期-CPU" class="headerlink" title="单指令周期 CPU"></a>单指令周期 CPU</h2><p>对于 CPU 而言，每次都需要处理一条指令，该部分指令由时钟频率驱动，一个 Cycle 即执行一条指令。由于不同指令所需实际执行时间不同，浮点数乘法所消耗的时间一定大于简单的移动指令。<br>因此单指令周期的 CPU，都需要等待满一个时钟周期，浪费了等待时间，同时限制了时钟频率的提升。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728512154282.jpg" width="400" alt title></p><h2 id="PipeLine"><a href="#PipeLine" class="headerlink" title="PipeLine"></a>PipeLine</h2><p>为了提高 CPU 的时钟频率，通过将指令按照不同的小步骤进行拆分，即形成了<code>流水线</code>工作。</p><p>此时不再需要确保最复杂的那条指令在一个时钟周期内完成，而只需要保证最复杂的<code>流水线级</code>的操作在一个时钟周期内完成即可。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728514408821.jpg" width="400" alt title></p><p>通过 PipeLine 处理后，可以大大提升 CPU 主频，提升运行速度。现代的 ARM 或者 Intel 的 CPU，流水线级数可以到14级。</p><blockquote><p>超长流水线瓶颈，增加流水线深度，其实是有性能成本，在读写流水线寄存器时，会有开销。同时还会带来<strong>结构冒险、数据冒险、控制冒险等其他依赖问题</strong>。<br>为了应付各类冒险问题，采用<strong>乱序执行、分支预测</strong>等解决方案。<br>流水线越长，这一类冒险问题就更难解决。</p></blockquote><h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><p>所谓结构冒险，就是在访问内存和取指令的时候，都需要操作程序内存，但是我们只有<em>一个地址译码器</em>，此时便会产生资源冲突。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728518021525.jpg" width="400" alt title></p><p>为了解决该冲突，可以将内存分为两部分，一个用于存放<code>指令</code>，另一个存放<code>数据</code>。</p><p>把内存拆成两部分的解决方案，被称为<strong>哈佛架构</strong>，我们使用的<strong>冯·诺依曼体系结构</strong>又叫<strong>普林斯顿架构</strong>，该体系结构没有拆分内存，而是在高速缓存部分分成<strong>指令缓存</strong>和<strong>数据缓存</strong>。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728519505058.jpg" width="400" alt title></p><h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><ul><li><p>先写后读，数据依赖</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 先写1 再读1</span></span><br><span class="line">    a = a + <span class="number">2</span>;</span><br><span class="line">    b = a + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先读后写，反依赖</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    a = b + a;</span><br><span class="line">    <span class="comment">// 若下面早于上面完成</span></span><br><span class="line">    b = a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写后再读，输出依赖</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 先写1 再写1</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>使用 nop 保证有数据依赖的执行在上一条执行后继续。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728523442480.jpg" width="400" alt title></p></li><li><p>操作数转发，将前一条指令执行结果直接作为后一条指令的输入。减少 nop。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728524636993.jpg" width="400" alt title></p></li><li><p>由于不同指令不存在依赖关系，可以通过乱序执行，将没有依赖关系的指令提前，减少 nop 时间。乱序执行，有点类似于 <strong>线程池</strong>。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728579747159.jpg" width="300" alt title></p></li></ol><h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p>以上假设都是基于代码都是顺序执行的，<code>取指令</code> 和 <code>指令译码</code> 不会遇到任何停顿，当遇到跳转指令时，为了保证争取，不得不等待造成延迟。</p><p>当有判断或跳转时，便于要分支预测的来提高运行效率，否则就需要通过 nop 直至此时判断完成。</p><ol><li><p>分支预测，便是假装分支不发生，即<strong>静态预测</strong>成功率在50%，当发现错误时，就将不要的数据丢弃。<br> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728583136389.jpg" width="400" alt title></p></li><li><p>动态分支预测，即今天下雨，就猜明天也下雨。即用1比特保存当前预测结果，并用该结果作为下一次分支比较。还可以用2比特预测，叫<strong>双模态预测</strong>。</p></li></ol><blockquote><p>注意在不改变代码基础上，将循环少的放在外面。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728584085043.jpg" width="400" alt title></p><h2 id="Superscalar-和-VLIW使得-CPU-吞吐率大于1"><a href="#Superscalar-和-VLIW使得-CPU-吞吐率大于1" class="headerlink" title="Superscalar 和 VLIW使得 CPU 吞吐率大于1"></a>Superscalar 和 VLIW使得 CPU 吞吐率大于1</h2><h3 id="Superscalar"><a href="#Superscalar" class="headerlink" title="Superscalar"></a>Superscalar</h3><p>超标量(Superscalar)，即多发射的结构，是在原有 PipeLine 基础上，通过增加多条流水线，达到一次取多条指令执行。如此并能使得 CPU 吞吐率高于 1。</p><p>此时需要增加的只有两个部分：修改取指令一次多个；增加多个译码器。译码完成的代码即可分发器被分发到各个执行 ALU 单元。</p><p>通过指令多发射设计，可以得到超标量，即并行执行多条指令。</p><p> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728597977989.jpg" width="400" alt title></p><p> <img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728598026707.jpg" width="400" alt title></p><h3 id="VLIW"><a href="#VLIW" class="headerlink" title="VLIW"></a>VLIW</h3><p>VLIW(Very Long Instruction Word)，通过将指令打包，使得一次执行时能够执行多条指令，从而提升吞吐率。</p><blockquote><p>但是该方法由于无法向前兼容，最后导致失败。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728599785703.jpg" width="400" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728599874568.jpg" width="400" alt title></p><h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超长流水线，意味着在流水线中指令越多，相互依赖关系越多，不得不面临冒险。2002 年底，Intel 在的 3.06GHz 主频的 Pentium 4 CPU上，第一次引入了超线程技术。<br>超线程技术，就是在CPU中同时执行多个程序的指令。<br>增加一份PC寄存器、指令寄存器、条件码寄存器。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728604457643.jpg" width="400" alt title></p><h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>SIMD，Single Instruction Multiple Data。<br>SIMD 在获取数据和执行指令时，都做到了并行，一方面，再从内存读取数据的时候，SIMD是一次性读取多个数据，在SSE指令集中，CPU添加了8个16Bytes的寄存器，一个寄存器一次性可以加载4个整数。</p><p>Numpy，使用 SIMD 技术。</p><p>基于 SIMD 的向量计算指令，被称为 MMX（Matrix Math eXtensions） 指令集，即矩阵数学扩展。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cpu/15728604706569.jpg" width="400" alt title></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>单指令周期 CPU 需要保证最耗时的指令在一个时钟周期内完成，限制主频发展。因此改进成 PipeLine。</p></li><li><p>PipeLine 可以分为 <code>IF、ID、EX、MEM、WB</code>， 只需要保证最复杂的<code>流水线级</code>的操作在一个时钟周期内完成即可，极大提升了主频发展。<br>但是 PipeLine 会导致 <code>结构冒险、数据冒险、控制冒险</code> 等。<br>结构冒险，通过 <code>D-L1 Cache、I-L1 Cache</code> 防止冲突。<br>数据冒险，通过增加 <code>nop、数据转发、乱序执行</code> 等手段防止冒险出现。<br>控制冒险，通过 <code>分支预测</code> 防止。</p></li><li><p>为了使 CPU 吞吐率高于 1，采用 Superscalar 和 VLIW 技术。<br>Superscalar 利用 IF 一次取多条指令，并由多个 ID 译码，并分发给 ALU，从而达到多条流水线同时执行的效率。<br>VLIW 将多个指令打包成一个指令，从而在执行时，同时执行多条，但是由于无法向前兼容最终淘汰。</p></li><li><p>Superscalar 导致多条流水线间的依赖关系过于复杂，不得不面临冒险。为减少冲突因此提出超线程手段，通过增加一份 <code>PC寄存器、指令寄存器、条件码寄存器</code> 使得一个 CPU 可以同时运行两个无关的线程代码。</p></li><li><p>SIMD，Single Instruction Multiple Data。通过一条指令操作多条数据，从而增加吞吐率，该技术也促使了 GPU 相关的发展。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode The Skyline Problem 218</title>
      <link href="Leetcode/leetcode/leetcode-The-Skyline-Problem-218/"/>
      <url>Leetcode/leetcode/leetcode-The-Skyline-Problem-218/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-218-The-Skyline-Problem"><a href="#Leetcode-218-The-Skyline-Problem" class="headerlink" title="Leetcode 218. The Skyline Problem"></a>Leetcode 218. The Skyline Problem</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15721814780081.jpg" width="300" height="200" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15721814871884.jpg" width="300" height="200" alt title></p><p>每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。</p><a id="more"></a><p>例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。</p><p>输出是以 [ [x1,y1], [x2, y2], [x3, y3], … ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p><p>例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。</p><p>说明:</p><p>任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。<br>输入列表已经按左 x 坐标 Li  进行升序排列。<br>输出列表必须按 x 位排序。<br>输出天际线中不得有连续的相同高度的水平线。例如 […[2 3], [4 5], [7 5], [11 5], [12 7]…] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[…[2 3], [4 5], [12 7], …]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15721815671065.jpg" width="600" height="300" alt title></p><ol><li>将 [2,9,10] 转化为 [2,-10], [9,10]</li><li>从左往右排序</li><li>从左往右扫描线，每次从 PriorityQueue 中取出当前最高的点，与前一个点比较，如果是新的点则加入，否则下一次循环。</li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; heights = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] build: buildings) &#123;</span><br><span class="line">        heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;build[<span class="number">0</span>], -build[<span class="number">2</span>]&#125;);</span><br><span class="line">        heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;build[<span class="number">1</span>], build[<span class="number">2</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(heights, (a,b)-&gt; a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">    pq.offer(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] h: heights) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pq.offer(-h[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pq.remove(h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = pq.peek();</span><br><span class="line">        <span class="keyword">if</span> (cur != prev) &#123;</span><br><span class="line">            res.add(Arrays.asList(h[<span class="number">0</span>], cur));</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> Line Sweep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode house rob 198, 213, 337</title>
      <link href="Leetcode/leetcode/leetcode-house-rob-198-213-337/"/>
      <url>Leetcode/leetcode/leetcode-house-rob-198-213-337/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-198-House-Rob-I"><a href="#Leetcode-198-House-Rob-I" class="headerlink" title="Leetcode 198. House Rob I"></a>Leetcode 198. House Rob I</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>输入: [2,7,9,3,1]<br>输出: 12<br>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><a id="more"></a><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15719260481158.jpg" width="600" height="400" alt="HouseRobI" title="HouseRobI"></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> notRob = <span class="number">0</span>, curRob = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> preRob = Math.max(notRob, curRob);</span><br><span class="line">        curRob = notRob + num;</span><br><span class="line">        notRob = preRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(curRob, notRob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-213-House-Rob-II"><a href="#Leetcode-213-House-Rob-II" class="headerlink" title="Leetcode 213. House Rob II"></a>Leetcode 213. House Rob II</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>输入: [1,2,3,1]<br>输出: 4<br>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15719265087693.jpg" width="600" height="400" alt="HouseRobII" title="HouseRobII"></p><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length-<span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> notRob = <span class="number">0</span>, curRob = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> preRob = Math.max(notRob, curRob);</span><br><span class="line">        curRob = notRob + nums[i];</span><br><span class="line">        notRob = preRob;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(curRob, notRob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-337-House-Rob-III"><a href="#Leetcode-337-House-Rob-III" class="headerlink" title="Leetcode 337. House Rob III"></a>Leetcode 337. House Rob III</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p>输入: [3,2,3,null,3,null,1]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15719272795222.jpg" width="600" height="400" alt="HouseRobI" title="HouseRobI"></p><h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = helper(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] helper(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span>[] left = helper(root.left);</span><br><span class="line">    <span class="keyword">int</span>[] right = helper(root.right);</span><br><span class="line">    <span class="keyword">int</span> notRob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> curRob = left[<span class="number">0</span>] + right[<span class="number">0</span>] + root.val;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;notRob, curRob&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode best time to buy and sell stock 121,122,123,188,714</title>
      <link href="Leetcode/leetcode/leetcode-best-time-to-buy-and-sell-stock-121-122-123-188/"/>
      <url>Leetcode/leetcode/leetcode-best-time-to-buy-and-sell-stock-121-122-123-188/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">股票相关解答说明</a></p></blockquote><h1 id="Leetcode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#Leetcode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Leetcode 121. Best Time to Buy and Sell Stock"></a>Leetcode 121. Best Time to Buy and Sell Stock</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>[7,1,5,3,6,4]<br>5</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于只能买卖一次，因此每次都减去至今为止最小的买入价格就行。<br>[7, 1, 5, 3, 6, 4] - [7, 1, 1, 1, 1, 1]<br>至今最小可以使用一个变量 curMin 进行记录。</p><a id="more"></a><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curMin = prices[<span class="number">0</span>], res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        res = Math.max(res, prices[i]-curMin);</span><br><span class="line">        curMin = Math.min(curMin, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Leetcode 122. Best Time to Buy and Sell Stock II"></a>Leetcode 122. Best Time to Buy and Sell Stock II</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>[7,1,5,3,6,4]<br>7</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于没有买卖次数限制，因此只要后面比前面大就进行交易即可。</p><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        res += prices[i] &gt; prices[i-<span class="number">1</span>] ? prices[i]-prices[i-<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123. Best Time to Buy and Sell Stock III"></a>Leetcode 123. Best Time to Buy and Sell Stock III</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>参考188</p><h2 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[k][i] = max(dp[k][i-1], dp[k-1][j] + prices[i] - prices[j]) j from 0 to i-1</span></span><br><span class="line"><span class="comment">// dp[k][i] = max(dp[k][i-1], tempMax + prices[i]), tempMax = dp[k-1][j]-prices[j] </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][prices.length];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tempMax = dp[k-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[k][i] = Math.max(dp[k][i-<span class="number">1</span>], prices[i] + tempMax);</span><br><span class="line">            tempMax = Math.max(tempMax, dp[k-<span class="number">1</span>][i] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>][prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Leetcode-188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Leetcode 188. Best Time to Buy and Sell Stock IV"></a>Leetcode 188. Best Time to Buy and Sell Stock IV</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://www.youtube.com/watch?v=oDhu5uGq_ic&amp;t=1332s" target="_blank" rel="noopener">Buy/Sell Stock With K transactions To Maximize Profit Dynamic Programming</a></p><script type="math/tex; mode=display">dp[k][i], k 表示交易次数，i 表示第几天。\\dp[k][i] = max\begin{cases}dp[k][i-1] \qquad & 在第 i 天没有交易 \\prices[i]-prices[j]+dp[k-1][j] \qquad & 在第 j 天进行交易， j := 0 to i-1\end{cases} \\</script><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15715799404340.jpg" width="300" alt title></p><p>可以将上面的动态规划公式进行修改得到：</p><script type="math/tex; mode=display">dp[k][i] = max\begin{cases}dp[k][i-1] \qquad & 在第 i 天没有交易 \\max(dp[k-1][j]-prices[j]) + prices[i] \qquad & 在第 j 天进行交易， j := 0 to i-1\end{cases} \\</script><h2 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[k][i] = j不买 dp[k][i-1]</span></span><br><span class="line"><span class="comment">//          = j买  max(dp[k-1][j] + p[i] - p[j]) j = 0..i-1</span></span><br><span class="line"><span class="comment">//          = j买  max(dp[k-1][j] - p[j]) + p[i] j = 0..i-1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || prices.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>][prices.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">1</span>; kk &lt;= k; kk++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp[kk-<span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;       </span><br><span class="line">            dp[kk][i] = Math.max(dp[kk][i-<span class="number">1</span>], temp+prices[i]);</span><br><span class="line">            temp = Math.max(temp, dp[kk-<span class="number">1</span>][i] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k][prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Leetcode 309. Best Time to Buy and Sell Stock with Cooldown"></a>Leetcode 309. Best Time to Buy and Sell Stock with Cooldown</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是对 <a href="#Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II">LeetCode 122</a> 的扩展。</p><h2 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h2><h1 id="Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#Leetcode-714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee"></a>Leetcode 714. Best Time to Buy and Sell Stock with Transaction Fee</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题是对 <a href="#Leetcode-122-Best-Time-to-Buy-and-Sell-Stock-II">LeetCode 122</a> 的扩展。</p><h2 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h2><blockquote><p>cash 表示未持有股票的现金部分。<br>hold 表示持有股票。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cash = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        cash = Math.max(cash, hold+prices[i]-fee);</span><br><span class="line">        hold = Math.max(hold, cash-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP讲解</title>
      <link href="Algorithm/algorithm/kmp/"/>
      <url>Algorithm/algorithm/kmp/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><h3 id="正常的匹配方式"><a href="#正常的匹配方式" class="headerlink" title="正常的匹配方式"></a>正常的匹配方式</h3><p>正常的匹配，从左往右一个一个进行匹配，当匹配失败的时候，P向右移动一格。若<code>T:aaaaaaaaaab, P:aaaaab</code> 此时将花费大量的时间。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15661394871016.jpg" width="400" alt title></p><a id="more"></a><h3 id="KMP准备"><a href="#KMP准备" class="headerlink" title="KMP准备"></a>KMP准备</h3><p>(1) 获取前缀表</p><p>获取前缀表为三步：</p><ol><li>找所有前缀</li><li>求最大公共前后缀</li><li>向下移动一位，因为最后一位对KMP而言并没有什么用处</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15661399032962.jpg" width="400" alt title></p><p>(2) 匹配过程</p><p>在KMP匹配过程中，若匹配不成功，则找前缀所在索引进行移动，即紫色代表的索引位，若是-1，则向右移动一位。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15661401739842.jpg" width="400" alt title></p><h2 id="KMP代码讲解"><a href="#KMP代码讲解" class="headerlink" title="KMP代码讲解"></a>KMP代码讲解</h2><h3 id="Prefix-Table"><a href="#Prefix-Table" class="headerlink" title="Prefix Table"></a>Prefix Table</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/algorithm/15661408553798.jpg" width="400" alt title></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] prefixTable(String p) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[p.length()];</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; p.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(i) == p.charAt(len) &#123;</span><br><span class="line">            prefix[i++] = len++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// a b a b c a b a a</span></span><br><span class="line">            <span class="comment">// 0 0 1 2 0 1 2 3 ?</span></span><br><span class="line">            <span class="comment">// len = 3</span></span><br><span class="line">            <span class="comment">// 此时不等</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>) len = prefix[len-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 防止最开始不走</span></span><br><span class="line">            <span class="keyword">else</span> prefix[i++] = len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] movePrefixTable(<span class="keyword">int</span>[] prefix) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prefix.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) prefix[i] = prefix[i-<span class="number">1</span>];</span><br><span class="line">    prefix[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是求解 PrefixTable 的方法</p><h3 id="KMP-Search"><a href="#KMP-Search" class="headerlink" title="KMP Search"></a>KMP Search</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String t, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] prefix = prefixTable(p);</span><br><span class="line">    movePrefix(prefix);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; t.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length() - <span class="number">1</span> &amp;&amp; s.charAt(i) == p.charAt(j)) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span> (t.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = prefix[j];</span><br><span class="line">            <span class="keyword">if</span> (j == -<span class="number">1</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对看看多理解，不行先背下来，多回忆就能理解了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-001-005</title>
      <link href="Leetcode/leetcode/leetcode-001-005/"/>
      <url>Leetcode/leetcode/leetcode-001-005/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-001-Two-Sum"><a href="#Leetcode-001-Two-Sum" class="headerlink" title="Leetcode 001 Two Sum"></a>Leetcode 001 Two Sum</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出数字数组，找出能使和为target的两个索引，例：<br>nums = [2, 7, 11, 15], target = 9, 因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以 return [0, 1]</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>该题直接采用简单map即可解决。时间复杂度为O(n)，空间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> remain = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remain)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(remain), i&#125;;</span><br><span class="line">            &#125; </span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="Leetcode-002-Add-Two-Numbers"><a href="#Leetcode-002-Add-Two-Numbers" class="headerlink" title="Leetcode 002 Add Two Numbers"></a>Leetcode 002 Add Two Numbers</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个List，对其相加，例：<br>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>7 -&gt; 0 -&gt; 8</p><h2 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h2><p>在做 LinkedList 题时，一般都会使用 dummy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="keyword">int</span> v2 = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = v1 + v2 + carry;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-003-Longest-Substring-Without-Repeating-Characters"><a href="#Leetcode-003-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Leetcode 003 Longest Substring Without Repeating Characters"></a>Leetcode 003 Longest Substring Without Repeating Characters</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 “abcabcbb”, 最长的子串长度。</p><h2 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h2><p>利用 Set 做 Sliding Window。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j))) &#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答2"><a href="#解答2" class="headerlink" title="解答2"></a>解答2</h2><p>利用 Map 进行跳转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答3"><a href="#解答3" class="headerlink" title="解答3"></a>解答3</h2><p>在方法2的基础上进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring3</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(map[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Leetcode-004-Median-of-Two-Sorted-Arrays"><a href="#Leetcode-004-Median-of-Two-Sorted-Arrays" class="headerlink" title="Leetcode 004 Median of Two Sorted Arrays"></a>Leetcode 004 Median of Two Sorted Arrays</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出已排序的 nums1, nums2 求这两个数组的中位数。</p><p>nums1 = [1, 4]<br>nums2 = [2, 6]<br>return 3.0</p><h2 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alg4_MedianofTwoSortedArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 暂时不考虑只有一个为null的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums1.length &gt; nums2.length) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums1.length + nums2.length;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> cut1 = <span class="number">0</span>, cut2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cut1 &lt;= nums1.length) &#123;</span><br><span class="line">            cut1 = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            cut2 = len / <span class="number">2</span> - cut1;</span><br><span class="line">            <span class="keyword">double</span> l1 = (cut1 == <span class="number">0</span>) ? Integer.MIN_VALUE : nums1[cut1 - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> r1 = (cut1 == nums1.length) ? Integer.MAX_VALUE : nums1[cut1];</span><br><span class="line">            <span class="keyword">double</span> l2 = (cut2 == <span class="number">0</span>) ? Integer.MIN_VALUE : nums2[cut2 - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">double</span> r2 = (cut2 == nums2.length) ? Integer.MAX_VALUE : nums2[cut2];</span><br><span class="line">            <span class="keyword">if</span> (l1 &gt; r2) end = cut1 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l2 &gt; r1) start = cut1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    l1 = l1 &gt; l2 ? l1 : l2;</span><br><span class="line">                    r1 = r1 &lt; r2 ? r1 : r2;</span><br><span class="line">                    <span class="keyword">return</span> (l1 + r1) / <span class="number">2.0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> r1 &lt; r2 ? r1 : r2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/leetcode/15657965662530.jpg" width="400" alt title></p><p>以偶数为例子:<br>nums1 = [1, 4, 5, 8]<br>nums2 = [2, 6]<br>all = [1, 2, 4, 5, 6, 8]<br>以上的中位数为 mid(4, 5)，那么此时如果有一个cut则在 4, 5之间，halfLen = (nums1.length + nums2.length) / 2<br>现在我们只考虑 nums1 如何切分，当我们确定了i的位置，j的位置也就确定了，因为i+j = halfLen。<br>那么在什么情况下会满足合适的切分呢？<br>当l1 &lt; r2 &amp;&amp; l2 &lt; r1 的时候，满足切分，小的都分到了左边，大的都分到了右侧。</p><ol><li>l1 &gt; r2 此时，i偏右，需要向左移动，end = i - 1</li><li>l2 &gt; r1 此时，i偏左，需要向右一定，start = i + 1</li></ol><h1 id="Leetcode-005-Longest-Palindromic-Substring"><a href="#Leetcode-005-Longest-Palindromic-Substring" class="headerlink" title="Leetcode 005 Longest Palindromic Substring"></a>Leetcode 005 Longest Palindromic Substring</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定字符串，求最大回文子串。</p><h2 id="解答1-1"><a href="#解答1-1" class="headerlink" title="解答1"></a>解答1</h2><p>dp求解, baaab，dp[0][4]满足回文的前提是，s[0]==s[4]且dp[1][3]也是回文。<br>但需要注意，当 j-i &lt;= 2 时，只要s[i] == s[j]必定是回文aba举例，dp[0][2]=true<br>公式如下：</p><script type="math/tex; mode=display">dp[i][j] = s[i]==s[j] && (j-i <= 2 || dp[i+1][j-1] )</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++) &#123;</span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答2-1"><a href="#解答2-1" class="headerlink" title="解答2"></a>解答2</h2><p>中心扩散法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String h1 = helper(s, i, i);</span><br><span class="line">            String h2 = helper(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h1.length() &gt; res.length()) res = h1;</span><br><span class="line">            <span class="keyword">if</span> (h2.length() &gt; res.length()) res = h2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意left&gt;=0</span></span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left+<span class="number">1</span>, right);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆(HEAP)讲解</title>
      <link href="Algorithm/algorithm/heap/"/>
      <url>Algorithm/algorithm/heap/</url>
      
        <content type="html"><![CDATA[<h1 id="堆-HEAP-介绍"><a href="#堆-HEAP-介绍" class="headerlink" title="堆(HEAP)介绍"></a>堆(HEAP)介绍</h1><blockquote><p>堆(HEAP)必须要是<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">完全二叉树</a>，同时满足父节点的内容大于(或小于)子节点。<br>堆的底层数据结构为一维数组，此时若当前节点为$i$，则其父子节点索引可直接通过以下公式直接计算得到。</p><script type="math/tex; mode=display">\begin{cases}parent = (i-1)/2 \\left = 2i + 1 \\right = 2i + 2\end{cases}</script></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/image/15630054884395.jpg" width="500" height="400" alt="大顶堆" title="大顶堆"></p><a id="more"></a><h2 id="Heapify-操作"><a href="#Heapify-操作" class="headerlink" title="Heapify 操作"></a>Heapify 操作</h2><p>若给定的数据中，root节点无法保证为堆结构，此时需要对其进行heapfiy操作，保持堆结构。</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/image/15630045649595.jpg" width="600" height="400" alt="Heapify" title="Heapify"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] tree, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recursive exit</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = i;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; tree[left] &gt; tree[max]) &#123;</span><br><span class="line">        max = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) &#123;</span><br><span class="line">        max = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">        swap(tree, max, i);</span><br><span class="line">        heapify(tree, n, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>heapify Time: $O(lgn)$</p></blockquote><h2 id="Init-Heapify-操作"><a href="#Init-Heapify-操作" class="headerlink" title="Init Heapify 操作"></a>Init Heapify 操作</h2><p>若给定完全二叉树，初始状态无序，此时需要对其进行初始化，使其成为Heap。其Heapify顺序如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastParent = (tree.length-<span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lastParent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(tree, tree.length, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/image/15630049706370.jpg" width="500" height="400" alt="builldHeap" title="builldHeap"></p><p>每次调用heapify的Time: $O(lgn)$，需要$O(n)$调用，因此可估为$O(nlgn)$，但这样的计算并不严谨。</p><p>由于不同高度，调用heapify的时间不同，高度为h的堆最多包涵$\lceil n/2^{h+1}\rceil$，在一个高度为h的节点上运行heapify的Time: $O(h)$，所以可以将BuildHeap的代价表示如下：</p><script type="math/tex; mode=display">T(n) = \sum_{h=0}^{\lfloor lgn \rfloor} \lceil \frac{n}{2^{h+1}} \rceil O(h) = O(n \sum_{h=0}^{\lfloor lgn \rfloor} \frac{h}{2^h})   \\\sum_{h=0}^{\infty}\frac{h}{2^h} = \frac{1/2}{(1-1/2)^2} = 2\\T(n)=O(n \sum_{h=0}^{\infty}\frac{h}{2^h}) = O(n)</script><h2 id="HeapSort"><a href="#HeapSort" class="headerlink" title="HeapSort"></a>HeapSort</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] tree)</span> </span>&#123;</span><br><span class="line">    buildHeap(tree);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tree.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(tree, i, <span class="number">0</span>);</span><br><span class="line">        heapify(tree, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 数组作为堆</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; </span><br><span class="line"><span class="comment">// 元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 比较器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br></pre></td></tr></table></figure><h2 id="offer-add-siftUp"><a href="#offer-add-siftUp" class="headerlink" title="offer, add, siftUp"></a>offer, add, siftUp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> offer(e); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="comment">// 大于数组长度则增长</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">    grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 自下而上</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 利用自定义的比较器</span></span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="comment">// x &gt;= e, 小顶堆，直到parent &lt; 当前</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/image/15630122392440.jpg" width="600" height="400" alt="siftUp" title="siftUp"></p><h2 id="poll-siftDown"><a href="#poll-siftDown" class="headerlink" title="poll, siftDown"></a>poll, siftDown</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 自上向下</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// left &gt; right, 取右边, 取小</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// x 比任何一个都小, 则退出</span></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/image/15630129612496.jpg" width="600" height="400" alt="siftDown" title="siftDown"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><p><a href="https://www.youtube.com/watch?v=j-DqQcNPGbE&amp;t=447s" target="_blank" rel="noopener">堆排序(Heapsort)</a></p></li><li><p><a href="https://www.youtube.com/watch?v=HqPJF2L5h9U&amp;t=19s" target="_blank" rel="noopener">2.6.3 Heap - Heap Sort - Heapify - Priority Queues</a></p></li><li><a href="https://www.youtube.com/watch?v=HI97KDV23Ig" target="_blank" rel="noopener">Algorithms lecture 13— Build max heap algorithm and analysis</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS(Breadth First Search) 与 DFS (Depth First Search)</title>
      <link href="Algorithm/algorithm/dfs-bfs/"/>
      <url>Algorithm/algorithm/dfs-bfs/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS-Breadth-First-Search-与-DFS-Depth-First-Search"><a href="#BFS-Breadth-First-Search-与-DFS-Depth-First-Search" class="headerlink" title="BFS(Breadth First Search) 与 DFS (Depth First Search)"></a>BFS(Breadth First Search) 与 DFS (Depth First Search)</h1><blockquote><p>BFS与DFS的主要应用场景在<code>图</code>和<code>树</code>之中。</p></blockquote><h2 id="BFS与DFS"><a href="#BFS与DFS" class="headerlink" title="BFS与DFS"></a>BFS与DFS</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/image/15624842276413.jpg" width="400" alt title></p><blockquote><p>上面的图可以转化为以下的数据结构。 </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">"A"</span>: [<span class="string">"B"</span>, <span class="string">"C"</span>],</span><br><span class="line">    <span class="string">"B"</span>: [<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>],</span><br><span class="line">    <span class="string">"C"</span>: [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>],</span><br><span class="line">    <span class="string">"D"</span>: [<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>],</span><br><span class="line">    <span class="string">"E"</span>: [<span class="string">"C"</span>, <span class="string">"D"</span>],</span><br><span class="line">    <span class="string">"F"</span>: [<span class="string">"D"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>BFS算法，利用 Queue 进行遍历，顺序为ABCDEF</li><li>DFS算法，利用 Stack 进行遍历，顺序为ABDFEC</li></ol><a id="more"></a><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Map&lt;String, List&lt;String&gt; graph, String start)</span> </span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(start);</span><br><span class="line">    Set&lt;String&gt; used = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.pop();</span><br><span class="line">        List&lt;String&gt; neighbors = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (String w : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used.contains(w)) <span class="keyword">continue</span>;</span><br><span class="line">            queue.offer(w);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Map&lt;String, List&lt;String&gt; graph, String start)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack.push(start);</span><br><span class="line">    Set&lt;String&gt; used = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        String cur = queue.pop();</span><br><span class="line">        List&lt;String&gt; neighbors = graph.get(cur);</span><br><span class="line">        <span class="keyword">for</span> (String w : neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used.contains(w)) <span class="keyword">continue</span>;</span><br><span class="line">            stack.push(w);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树DFS-Traversal"><a href="#二叉树DFS-Traversal" class="headerlink" title="二叉树DFS Traversal"></a>二叉树DFS Traversal</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="144-Binary-Tree-Preorder-Traversal-Easy"><a href="#144-Binary-Tree-Preorder-Traversal-Easy" class="headerlink" title="144. Binary Tree Preorder Traversal (Easy)"></a>144. Binary Tree Preorder Traversal (Easy)</h2><h3 id="Recursive"><a href="#Recursive" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) dfs(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) dfs(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        res.add(cur.val);</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) stack.push(cur.right);</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="589-N-ary-Tree-Preorder-Traversal-Easy"><a href="#589-N-ary-Tree-Preorder-Traversal-Easy" class="headerlink" title="589. N-ary Tree Preorder Traversal (Easy)"></a>589. N-ary Tree Preorder Traversal (Easy)</h2><h3 id="Recursive-1"><a href="#Recursive-1" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.children == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            dfs(child, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iteration-1"><a href="#Iteration-1" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Node cur = root;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) stack.push(cur);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span> (cur.children == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur.children.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.push(cur.children.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="94-Binary-Tree-Inorder-Traversal-Medium"><a href="#94-Binary-Tree-Inorder-Traversal-Medium" class="headerlink" title="94. Binary Tree Inorder Traversal (Medium)"></a>94. Binary Tree Inorder Traversal (Medium)</h2><h3 id="Recursive-2"><a href="#Recursive-2" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) dfs(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) dfs(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iteration-2"><a href="#Iteration-2" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="145-Binary-Tree-Postorder-Traversal-Hard"><a href="#145-Binary-Tree-Postorder-Traversal-Hard" class="headerlink" title="145. Binary Tree Postorder Traversal (Hard)"></a>145. Binary Tree Postorder Traversal (Hard)</h2><h3 id="Recursive-3"><a href="#Recursive-3" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) dfs(root.left, res);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) dfs(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iteration-3"><a href="#Iteration-3" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123; <span class="comment">// left</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode temp = stack.peek().right;</span><br><span class="line">                <span class="keyword">if</span> (temp != <span class="keyword">null</span>) cur = temp; <span class="comment">// right have node</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// right don't have node</span></span><br><span class="line">                    temp = stack.pop();</span><br><span class="line">                    res.add(temp.val);</span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temp == stack.peek().right) &#123;</span><br><span class="line">                        temp = stack.pop();</span><br><span class="line">                        res.add(temp.val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="590-N-ary-Tree-Postorder-Traversal-Easy"><a href="#590-N-ary-Tree-Postorder-Traversal-Easy" class="headerlink" title="590. N-ary Tree Postorder Traversal (Easy)"></a>590. N-ary Tree Postorder Traversal (Easy)</h2><h3 id="Recursive-4"><a href="#Recursive-4" class="headerlink" title="Recursive"></a>Recursive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.children != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">                dfs(child, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iteration-4"><a href="#Iteration-4" class="headerlink" title="Iteration"></a>Iteration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child : cur.children) stack.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树BFS-Traversal"><a href="#二叉树BFS-Traversal" class="headerlink" title="二叉树BFS Traversal"></a>二叉树BFS Traversal</h1><h2 id="102-Binary-Tree-Level-Order-Traversal-Medium"><a href="#102-Binary-Tree-Level-Order-Traversal-Medium" class="headerlink" title="102. Binary Tree Level Order Traversal (Medium)"></a>102. Binary Tree Level Order Traversal (Medium)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                curLevel.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(curLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="107-Binary-Tree-Level-Order-Traversal-II-Easy"><a href="#107-Binary-Tree-Level-Order-Traversal-II-Easy" class="headerlink" title="107. Binary Tree Level Order Traversal II (Easy)"></a>107. Binary Tree Level Order Traversal II (Easy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                curLevel.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>, curLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="429-N-ary-Tree-Level-Order-Traversal-Easy"><a href="#429-N-ary-Tree-Level-Order-Traversal-Easy" class="headerlink" title="429. N-ary Tree Level Order Traversal (Easy)"></a>429. N-ary Tree Level Order Traversal (Easy)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                Node cur = queue.poll();</span><br><span class="line">                curLevel.add(cur.val);</span><br><span class="line">                <span class="keyword">for</span> (Node child : cur.children) &#123;</span><br><span class="line">                    queue.offer(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(curLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树-Depth"><a href="#二叉树-Depth" class="headerlink" title="二叉树 Depth"></a>二叉树 Depth</h1><h2 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) ? left + right + <span class="number">1</span> : Math.min(left, right)+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h2><h3 id="DFS-2"><a href="#DFS-2" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left)+<span class="number">1</span>, maxDepth(root.right)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFS-2"><a href="#BFS-2" class="headerlink" title="BFS"></a>BFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="559-Maximum-Depth-of-N-ary-Tree"><a href="#559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="559. Maximum Depth of N-ary Tree"></a>559. Maximum Depth of N-ary Tree</h2><h3 id="DFS-3"><a href="#DFS-3" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            depth = Math.max(depth, maxDepth(child));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS-4"><a href="#DFS-4" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        Node cur = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = queue.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (Node child : cur.children) &#123;</span><br><span class="line">                    queue.offer(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.youtube.com/watch?v=oLtvUWpAnTQ&amp;t=78s" target="_blank" rel="noopener">BFS和DFS算法(第1讲)</a></li><li><a href="https://www.youtube.com/watch?v=bD8RT0ub--0" target="_blank" rel="noopener">BFS和DFS算法(第2讲)</a></li><li><a href="https://www.youtube.com/watch?v=9wV1VxlfBlI" target="_blank" rel="noopener">BFS和DFS算法(第3讲)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer Cache</title>
      <link href="Linux/linux/computer-cache/"/>
      <url>Linux/linux/computer-cache/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计算机体系结构中，内存资源相对于 CPU 而言是十分稀有的，存储技术的发展相对 CPU 而言也是非常缓慢的，当 CPU 在 Moore 定律基础上以指数级增长时，存储技术还在线性缓慢增长，因此为使存储技术能够适应 CPU 如此快速的发展，在现代计算机中都会存在一级、二级、三级缓存，使得CPU能够快速的获取指令与数据。<br>本人在学习<code>内存管理、并发与同步</code>过程中，一直在思考，何为<code>原子操作、内存屏障</code>解决了何问题？以及<code>缓存一致性</code>、<code>内存一致性</code>都是什么？<br>因此，不才经过搜索网上大量资料，学习后整理以下文章，以作分享。</p></blockquote><h1 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h1><blockquote><p>首先，希望通过几个例子，与大家分享一下有哪些地方出现了与计算机缓存相关的的知识点。</p></blockquote><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(lock <span class="string">"cmpxchgb %2,%1"</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">"=a"</span> (__ret), <span class="string">"+m"</span> (*__ptr) <span class="comment">// output</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">"q"</span> (__new), <span class="string">"0"</span> (__old)    <span class="comment">// input</span></span></span></span><br><span class="line"><span class="function"><span class="params">            : <span class="string">"memory"</span>)</span></span>;                  <span class="comment">// clobbered</span></span><br></pre></td></tr></table></figure><p>如果大家看过内核有关<a href="https://elixir.bootlin.com/linux/v5.0/source/tools/arch/x86/include/asm/cmpxchg.h#L41" target="_blank" rel="noopener">lock</a>代码的话就会看到上面这一条汇编指令。在这条简单的汇编代码中，包含了关键词<code>volatile</code>, <code>lock</code>, <code>cmpxchgb</code>。<br>其中<code>cmpxchgb</code>很简单就是用<code>__old</code>与<code>__ptr</code>内存中的数据做比较，如果相同则将<code>__new</code>赋给<code>__ptr</code>，返回<code>__new</code>；否则保持<code>__ptr</code>值不变，返回<code>__ptr</code>指向内容。<br>让我想不通的一点是为何需要<code>volatile</code>, <code>lock</code>以及这两个关键词所起到的作用是什么？</p><blockquote><p><code>volatile</code>为了防止gcc优化代码。<br><code>lock</code>添加内存屏障，早期也采用<code>锁总线</code>技术。<br>这边的话先给出回答，后面会详细解释。</p></blockquote><a id="more"></a><h2 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h2><p>自旋锁Spinlock是内核中保证原子操作的常用手段，高性能的Spinlock能够极大提高内核效率，因此有大量对于Spinlock的研究，相关知识大家可以通过搜索<a href="https://xurongyang.github.io/2017/01/17/SpinLock%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">SpinLock实现</a>等关键词获得。所有对于Spinlock的优化都是为了解决<code>CPU cacheline bouncing</code>这一问题。<br>同时，为了更高效的使用Spinlock都会采用<code>Cache line 对齐</code>，使得Spinlock能够独占<code>Cache line</code>，如内存管理中<a href="https://elixir.bootlin.com/linux/v4.0/source/include/linux/mmzone.h#L476" target="_blank" rel="noopener">Zone</a>添加<code>ZONE_PADDING</code>以做对齐使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="keyword">spinlock_t</span>lock;</span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="keyword">spinlock_t</span>lru_lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Cache line</code>是缓存最小的单位。<br><code>CPU cacheline bouncing</code>产生原因是不同Core访问同一内存地址数据时，实际都是从自身L1 Cache获取，此时需要由<code>cache coherence protocol</code> 来保证每一Core从各自Cache看到正确的数据，当竞争严重时，将产生大量的<code>cache coherence message</code>，从而产生大量的<code>cache traffic</code>，降低锁的伸缩性。</p></blockquote><h2 id="行遍历与列遍历"><a href="#行遍历与列遍历" class="headerlink" title="行遍历与列遍历"></a>行遍历与列遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 行遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        sum += num[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        sum += num[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们学习计算机原理，或者其他相关课程时，老师一再强调行遍历要比列遍历高效，在没必要的情况下请使用行遍历。<br>这是由于，数据在内存中，需要以页的形式缓存到L3，再到L2，在缓存到L1的 Cache Line，如果二维数组一行数据特别大，进行遍历的时候，需要频繁的从缓存中换出当前行数据，再读取下一行。如果采用行遍历会处理掉读入的整行数据；而采用列遍历时只会处理读入的整行数据中的某一个数据后缓存则无效。</p><h2 id="多线程执行时的低效"><a href="#多线程执行时的低效" class="headerlink" title="多线程执行时的低效"></a>多线程执行时的低效</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result[P];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; P; p++) &#123;</span><br><span class="line">    pool.run([&amp;,p]) &#123;</span><br><span class="line">        result[p] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> chunkSize = DIM/P + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = p * chunkSize;</span><br><span class="line">        <span class="keyword">int</span> end = min(start+chunkSize, DIM);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            ++result[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.join(); <span class="comment">// wait all task</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; i++) sum+= result[i];</span><br></pre></td></tr></table></figure><p>上面是一个典型的低效使用多线程的写法，<code>result</code>数组被多个线程所持有，在每个Core对<code>result[i]</code>进行操作的时候，都需要与其他所有Core同步这一变化，从而导致<code>CPU cacheline bouncing</code>，解决方式而很简单，每个线程持有自己的私有变量，等对当前私有变量处理完成后再赋给<code>result[i]</code>，此时缓存同步便极大降低。</p><blockquote><p>相关知识可以看：<a href="https://www.youtube.com/watch?v=WDIkqP4JbkE&amp;list=PLqeV3qe6DIFbHWuY5-jo6_AoTAeIM99g0&amp;index=6&amp;t=522s" target="_blank" rel="noopener">Scott Meyers: Cpu Caches and Why You Care</a></p></blockquote><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><blockquote><p>内存屏障主要分三类：编译器优化 / 缓存优化 / CPU乱序执行</p></blockquote><p><a href="https://blog.csdn.net/GugeMichael/article/details/8207519" target="_blank" rel="noopener">C/C++ — 编程中的内存屏障(Memory Barriers)</a></p><p><a href="https://blog.csdn.net/ctthuangcheng/article/details/8893579" target="_blank" rel="noopener">优化屏障和内存屏障</a></p><h2 id="cache-对齐"><a href="#cache-对齐" class="headerlink" title="cache 对齐"></a>cache 对齐</h2><p><a href="http://blog.kongfy.com/2017/01/%E5%A4%9A%E6%A0%B8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84cache-line%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">多核并发编程中的cache line对齐问题</a></p><p><a href="https://blog.csdn.net/zhang_shuai_2011/article/details/38119657" target="_blank" rel="noopener">Cpu cache 与内存对齐</a></p><blockquote><p>数据跨越两个 cache line，就意味着两次 load 或者两次 store。如果数据结构是 cache line 对齐的，就有可能减少一次读写。数据结构的首地址cache line对齐，意味着可能有内存浪费（特别是数组这样连续分配的数据结构），所以需要在空间和时间两方面权衡。</p></blockquote><p>比如现在有个变量 int x; 占用4个字节,它的起始地址是 0x1234567F，那么它占用的内存范围就在 0x1234567F-0x12345682 之间。如果现在Cache Line长度为32个字节，那么每次内存同 Cache 进行数据交换时，都必须取起始地址时32(0x20)倍数的内存位置开始的一段长度为32的内存同 Cache Line 进行交换.<br>比如 0x1234567F 落在范围 0x12345660~0x1234567F 上，但是 0x12345680~0x12345682 落在范围 0x12345680~0x1234569F上，也就是说，为了将4个字节的整数变量 0x1234567F~0x12345682 装入 Cache ,我们必须调入两条 Cache Line 的数据。<br>但是如果 int x 的起始地址按4的倍数对齐，比如是 0x1234567C~0x1234567F ,那么必然会落在一条Cache Line 上，所以每次访问变量x就最多只需要装入一条 Cache Line 的数据了。比如现在一般的 malloc() 函数，返回的内存地址会已经是<code>8字节对齐</code>的，这个就是为了能够让大部分程序有更好的性能。</p><h1 id="CPU架构图"><a href="#CPU架构图" class="headerlink" title="CPU架构图"></a>CPU架构图</h1><h2 id="x86微处理器经典架构"><a href="#x86微处理器经典架构" class="headerlink" title="x86微处理器经典架构"></a>x86微处理器经典架构</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726990357597.jpg" width="600" alt="x86微处理器经典架构" title="x86微处理器经典架构"></p><p>附: <a href="https://blog.csdn.net/zdy0_2004/article/details/78998810" target="_blank" rel="noopener">首发：Meltdown漏洞分析与实践</a></p><ol><li>经典处理器架构的流水线是5级流水线：取值(IF),译码(ID),执行(EX),数据内存访问(MEM),写会(WB)</li><li><p>现在处理器在设计上都采用了<code>超标量体系结构(Superscalar Architecture)</code>和<code>乱序执行(Out-of-Order, OOO)</code>技术，极大提高了处理器计算能力。</p><p> <code>超标量技术</code>能够在一个时钟周期内执行多个指令。<br> ALU: Arithmetic-logic unit, 算法逻辑单元<br> AGU: Address generation unit, 地址生成单元</p></li><li>CPU执行过程，采用<code>顺序提交指令</code>, <code>乱序执行</code>, <code>最后顺序提交结果</code>的过程。</li></ol><blockquote><p>不进行乱序优化时，处理器的指令执行过程如下：</p><ul><li>指令获取。</li><li>如果输入的运算对象是可以获取的（比如已经存在于寄存器中），这条指令会被发送到合适的功能单元。如果一个或者更多的运算对象在当前的时钟周期中是不可获取的（通常需要从主内存获取），处理器会开始等待直到它们是可以获取的。</li><li>指令在合适的功能单元中被执行。</li><li>功能单元将运算结果写回寄存器。</li></ul><p>乱序优化下的执行过程如下：</p><ul><li>指令获取。</li><li>指令被发送到一个指令序列（也称执行缓冲区或者保留站）中。</li><li><code>指令将在序列中等待，直到它的数据运算对象是可以获取的。然后，指令被允许在先进入的、旧的指令之前离开序列缓冲区。（此处表现为乱序）</code></li><li>指令被分配给一个合适的功能单元并由之执行。</li><li>结果被放到一个序列中。</li><li><code>仅当所有在该指令之前的指令都将他们的结果写入寄存器后，这条指令的结果才会被写入寄存器中。（重整乱序结果）</code></li></ul><p>当然，为了实现乱序优化，还需要很多技术的支持，如寄存器重命名、分枝预测等，但大致了解到这里就足够。后文的注释中会据此给出内存屏障的实现方案</p></blockquote><h2 id="CPU存储架构"><a href="#CPU存储架构" class="headerlink" title="CPU存储架构"></a>CPU存储架构</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726992590858.jpg" width="400" alt="CPU 与 Cache 比较" title></p><p>附:<a href="https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips" target="_blank" rel="noopener">How L1 and L2 CPU Caches Work, and Why They’re an Essential Part of Modern Chips</a></p><blockquote><p>CPU速度与内存速度差距越来越大，若CPU需要等待内存响应极大地降低了CPU效率，因此引入了缓存机制。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726993283119.jpg" width="400" alt title></p><p>附:<a href="https://blog.csdn.net/huayushuangfei/article/details/80718111" target="_blank" rel="noopener">从CPU缓存看volatile为什么不能保证原子性</a></p><blockquote><p>有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。<br>一般方案有两种：<code>缓存一致性协议</code> or <code>总线锁机制</code><br>由于总线锁在一个CPU锁住总线后，其他CPU会阻塞等待，效率较低，因此现在的体系结构中一般采用<code>缓存一致性协议</code>保证数据一致性。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726994394105.jpg" width="600" alt title></p><blockquote><p>现有的CPU主要有3级缓存，以i7为例，包含16个寄存器，32KB一级缓存（L1指令缓存，L1数据缓存），256KB二级缓存，2-20MB三级缓存</p><p>Linux查看缓存命令：cat /sys/devices/system/cpu/cpu0/cache/index0/size<br>以线上机器为例，32K，256K，20M<br>L1: 8way, 64sets, 64bytes cacheline<br>L2: 8way, 512sets, 64bytes cacheline<br>L3: 20way, 16384sets, 64bytes cacheline<br>附: <a href="https://blog.csdn.net/u013920085/article/details/50010925" target="_blank" rel="noopener">linux查看CPU高速缓存(cache)信息</a></p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726995196414.jpg" width="600" alt title></p><p>附:<a href="https://www.jianshu.com/p/cfe8456aa43a" target="_blank" rel="noopener">CPU Cache 缓存学习笔记</a></p><blockquote><p>不同的缓存执行效率不一样，L1大概在4ns，L2大概在11ns，L3大概在14ns</p></blockquote><h1 id="Cache-line-相关"><a href="#Cache-line-相关" class="headerlink" title="Cache line 相关"></a>Cache line 相关</h1><p>以上知道了Cache的存在，那么Cache是如何进行分布的呢？</p><p><a href="https://zhuanlan.zhihu.com/p/37132953" target="_blank" rel="noopener">冬瓜哥彪悍图解Cache组关联</a><br><a href="https://my.oschina.net/fileoptions/blog/1630855" target="_blank" rel="noopener">Cache直接映射、组相连映射以及全相连映射</a><br><a href="https://blog.csdn.net/Xlong_Du/article/details/6394166" target="_blank" rel="noopener">Arm核920T性能优化之Cache</a><br><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache — 程序猿需要知道的那些事</a></p><p>假设：主存容量1MB，每块512Byte，分成2048块。Cache容量8KB，每块512B，分成16块。</p><h2 id="全关联-full-associative"><a href="#全关联-full-associative" class="headerlink" title="全关联(full-associative)"></a>全关联(full-associative)</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726995813548.jpg" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726995902129.jpg" width="600" alt title></p><blockquote><p>全关联的架构，主存中每一块都可以映射到Cache中的任意一块。Cache利用率高，但是需要一大堆的<code>比较器</code>，硬件设计、实现困难，因此只存在于小容量Cache中。</p></blockquote><h2 id="直接映射-direct-mapping"><a href="#直接映射-direct-mapping" class="headerlink" title="直接映射(direct-mapping)"></a>直接映射(direct-mapping)</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726996491542.jpg" alt title></p><blockquote><p>直接映射的架构，N%16 即为对应的Cache块。<br>这种架构硬件设计简单，成本低转化快，但是不够灵活，每个主存块只能对应一个固有的位置，容易产生<code>冲突</code>。<br>例如一个程序需要重复使用内存0块和16块数据，即使其他缓存1-15块空闲，也只能使用0块缓存进行切换。降低命中率。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726996733629.jpg" alt width="600" title></p><h2 id="多路组相联-set-associative"><a href="#多路组相联-set-associative" class="headerlink" title="多路组相联(set-associative)"></a>多路组相联(set-associative)</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726997015652.jpg" alt title><br><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726997248751.jpg" width="600" alt title><br><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726997336478.jpg" width="600" alt title></p><blockquote><p>直接映射相当于一路组相联。<br>主存中的各块与Cache的组号之间有固定的映射关系，但可自由映射到对应组中的任意一块。<br>多路组关联，缓存控制器每收到一个请求就会并行去所有Way中，将同一行号Tag都读出来然后与请求比较，2路组关联会浪费50%能耗。因为需要将所有Way 中对应行数据读出。为减少功耗，将Tag与Data 分离。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726997569022.jpg" width="600" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726997794543.jpg" width="600" alt title></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726998087556.jpg" width="600" alt title></p><p>8way, 64set, 64byte = 32KB<br>由于该处理器处理64G内存，分页为4k，总共有$64G/4k=2^{24}$个页面，需要24位进行标记(12-35位进行4KB对齐)<br>4k/64Byte=64(6-11位表示选中set)</p><blockquote><p>以物理地址0x800010a0为例，<code>1000 0000 0000 0000 0001 | 0000 10|10 0000</code><br>0x800010a0必定在第二组中，至于在哪一路，则需要通过tag标签进行查找。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726998561757.jpg" width="600" alt title></p><blockquote><p>由于我们只需要去查看某一组中的8路，所以查找匹配标记是非常迅速的；事实上，从电学角度讲，所有的标记是同时进行比对的，我用箭头来表示这一点。如果此时正好有一条具有匹配标签的有效缓存线，我们就获得一次缓存命中（cache hit）</p></blockquote><h2 id="为什么Set段设置在低位"><a href="#为什么Set段设置在低位" class="headerlink" title="为什么Set段设置在低位"></a>为什么Set段设置在低位</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726998943077.jpg" width="600" alt title></p><p><a href="http://cenalulu.github.io/linux/all-about-cpu-cache/" target="_blank" rel="noopener">关于CPU Cache — 程序猿需要知道的那些事</a></p><h1 id="Cache-coherence"><a href="#Cache-coherence" class="headerlink" title="Cache coherence"></a>Cache coherence</h1><p><a href="https://www.youtube.com/watch?v=OLGEtXV4U3I&amp;list=PLqeV3qe6DIFbHWuY5-jo6_AoTAeIM99g0&amp;index=3&amp;t=1983s" target="_blank" rel="noopener">MIT 6.004 L21: Cache Coherence</a></p><p><a href="https://zhuanlan.zhihu.com/p/25876351" target="_blank" rel="noopener">缓存/内存Coherence模型</a></p><p>以上介绍的主要是在单个CPU中的Cache结构，那么在多CPU体系下，Cache是如何分布的呢？</p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726999313709.jpg" width="400" alt title></p><blockquote><p>在I7中，每个CPU拥有自己独立的32KB一级缓存（L1指令缓存，L1数据缓存），256KB二级缓存，2-20MB三级缓存。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15726999599089.jpg" width="300" alt title></p><blockquote><p>那么在多CPU中是如何保证数据一致性的？即cache coherence 协议是什么。</p></blockquote><h2 id="snoopy-cache-amp-snooping-based-coherence"><a href="#snoopy-cache-amp-snooping-based-coherence" class="headerlink" title="snoopy cache &amp; snooping based coherence"></a>snoopy cache &amp; snooping based coherence</h2><p><a href="https://en.wikipedia.org/wiki/Snoopy_cache" target="_blank" rel="noopener">Wiki-Snoopy cache</a></p><blockquote><p>In computing a snoopy cache is a type of memory cache that performs bus sniffing. The technique was introduced by Ravishankar and Goodman in 1983.[1]</p><p>Such caches are used in systems where many processors or computers share the same memory and each has its own cache. In such systems processor ‘A’ may read a value from memory, then processor ‘B’ does the same. If either of the processors now change the value by writing back to memory they will invalidate the other processor’s cached value.</p><p>In order to prevent this and maintain cache coherence, snoopy caches monitor (‘snoop on’) the memory bus to detect any writes to values that they are holding, including changes coming from other processors or distributed computers.</p><p>However, this approach can only work in computer architectures like SGI Challenge and SGI Onyx where a single memory bus is shared between all processors</p><p>翻译一下大概意思是：<br>snoopy cache 能够监控总线，这类缓存用于多处理器在自己的cache中分享相同的内存，如果A从内存中读取数据，然后B也读取了相同的数据，如果此时任何一个处理器修改了当前数据，并回写到内存，将会无效化其他的处理器。<br>为保证缓存一致性，snoopy cache会监控所有自己已有数据的回写信号，包括其他处理器甚至分布式系统。<br><code>然而这种设计只有在所有处理器共享同一总线下才能使用。</code></p></blockquote><p><code>相关的硬件设计无法找到...</code></p><p><a href="http://www.cs.ucr.edu/~ravi/Papers/NWConf/ravishankar_83.pdf" target="_blank" rel="noopener">Ravishankar, Chinya; Goodman, James (February 28, 1983)</a></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727001282154.jpg" width="400" alt title></p><h2 id="A-Simple-Protocol-Valid-InValid-VI"><a href="#A-Simple-Protocol-Valid-InValid-VI" class="headerlink" title="A Simple Protocol: Valid/InValid(VI)"></a>A Simple Protocol: Valid/InValid(VI)</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727001632025.jpg" width="600" alt title></p><blockquote><p><code>Every Write updates main memory</code><br><code>Every Write requires broadcast &amp; snoop</code> </p></blockquote><h2 id="MSI-Modified-Shared-Invalid"><a href="#MSI-Modified-Shared-Invalid" class="headerlink" title="MSI(Modified-Shared-Invalid)"></a>MSI(Modified-Shared-Invalid)</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727002117003.jpg" width="600" alt title></p><blockquote><p>顺序写内存。<br>优势：使用回写的方式，每次Write不需要立即写到main memory<br><a href="https://baike.baidu.com/item/MSI%E5%8D%8F%E8%AE%AE/22688302?fr=aladdin" target="_blank" rel="noopener">MSI协议</a><br>问题：1. 当多个私有缓存中都含有同一个共享数据块时，采用写无效策略的MSI 协议会进行<code>多次的写作废操作</code>，增加流量负载;<br>2.其次，总线作为互斥资源其带宽有限，即总线的扩展性差；<br>3.MSI 协议是通过广播的方式发送一致性消息，存在于总线上的消息对于一些处理器核来说是不需要的，即<code>总线的有效利用率</code>受到影响.</p></blockquote><h2 id="MESI-Modified-Exclusive-Shared-Invalid"><a href="#MESI-Modified-Exclusive-Shared-Invalid" class="headerlink" title="MESI(Modified-Exclusive-Shared-Invalid)"></a>MESI(Modified-Exclusive-Shared-Invalid)</h2><p><a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="noopener">MESI protocol</a></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727002430322.jpg" width="600" alt title></p><h2 id="MOESI-MESIF"><a href="#MOESI-MESIF" class="headerlink" title="MOESI, MESIF"></a>MOESI, MESIF</h2><p><a href="https://www.ydaobo.com/wenzhang/12847.html" target="_blank" rel="noopener">Cache一致性：MOESI/MESIF协议</a></p><blockquote><p>MESI一致性协议中，一个CPU核先在L1 Cache中写入一个数据，然后另一个CPU请求读写此数据。则共享数据需要先写回L2 Cache，然后再发送给另一个CPU，需要两次操作。并且，在另一个CPU中更改后，最终还需要再次写回L2 Cache。这段操作中，完全可以减少一次数据传输和L2 Cache的写入。为此，需要加入一个Owner状态。<br>不对这两个协议进行具体分析。</p></blockquote><h1 id="Cache-line-回写与替换"><a href="#Cache-line-回写与替换" class="headerlink" title="Cache line 回写与替换"></a>Cache line 回写与替换</h1><blockquote><p><code>首先需要明确一点，由于cache的最小单位是cache line(cache block)，因此无论是读取回写还是替换都是以cache line 作为单位的。</code></p><ol><li>多个CPU中如何保证数据一致？是由cache1回写到cache2在回写到cache3再到主存？还是cache1直接回写到主存？什么时候回写？</li><li>cache line 什么时候进行替换，按什么替换.</li></ol></blockquote><h2 id="cache-line-回写"><a href="#cache-line-回写" class="headerlink" title="cache line 回写"></a>cache line 回写</h2><p><a href="https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-91-12.pdf" target="_blank" rel="noopener">Cache Write Policies and Performance</a></p><ol><li><p>Cache hit<br>1.1 直写策略 (VI, MSI)<br>1.2 回写 (MESI, cache line 换出回写到内存)</p></li><li><p>Cache miss<br>2.1 write allocate policy(先调入chache)<br>2.2 no write allocate policy(直接写到main memory)</p></li></ol><p>直写策略，设计简单，但需要频繁的占用总线。<br>回写，设计困难，极大减少总线占用。</p><h2 id="cache-line-替换"><a href="#cache-line-替换" class="headerlink" title="cache line 替换"></a>cache line 替换</h2><p><a href="https://blog.csdn.net/xinanzhung/article/details/21984635" target="_blank" rel="noopener">Cache 替换策略</a></p><ol><li><p>最不经常使用（LFU）算法<br>LFU（Least Frequently Used，最不经常使用）算法将一段时间内被访问次数最少的那个块替换出去。每块设置一个计数器，从0开始计数，每访问一次，被访块的计数器就增1。当需要替换时，将计数值最小的块换出，同时将<code>所有块的计数器</code>都清零。</p></li><li><p>近期最少使用（LRU）算法<br>LRU（Least Recently Used，近期最少使用）算法是把CPU近期最少使用的块替换出去。这种替换方法需要随时记录Cache中各块的使用情况，以便确定哪个块是近期最少使用的块。每块也设置一个计数器，<code>Cache每命中一次，命中块计数器清零</code>，其他各块计数器增1。当需要替换时，将<code>计数值最大的块换出</code>。<br>需要复杂算法维护，Cache的命中率高。</p></li><li><p>随机替换<br>效率高，不需要复杂算法，Cache命中率低。</p></li></ol><h1 id="memory-consistency"><a href="#memory-consistency" class="headerlink" title="memory consistency"></a>memory consistency</h1><p><a href="http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a></p><p><a href="http://www2.in.tum.de/hp/file?fid=1276" target="_blank" rel="noopener">Introducing Caches: The MESI Protocol</a></p><p><a href="https://blog.csdn.net/linpeng123l/article/details/52461680" target="_blank" rel="noopener">Memory Barriers（内存屏障）: a Hardware View for Software Hackers 阅读笔记</a></p><p><a href="http://wudaijun.com/2018/09/distributed-consistency/" target="_blank" rel="noopener">一致性杂谈</a></p><p>Memory Consistency的概念，与Cache Coherence不同的是，<code>Memory Consistency关注的是多个变量</code>，而非单个变量；Memory Model是多处理器和编译器优化导致存储器操作被多个处理器观察到的顺序不一致的问题，而Cache Coherence对程序员来说是透明的。</p><h2 id="内存一致性模型的概念"><a href="#内存一致性模型的概念" class="headerlink" title="内存一致性模型的概念"></a>内存一致性模型的概念</h2><p><a href="https://blog.csdn.net/force_eagle/article/details/7743063" target="_blank" rel="noopener">内存一致性模型(Memory Consistency Models)</a></p><p><a href="https://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-7.pdf" target="_blank" rel="noopener">Shared MemoryConsistency Models:A Tutorial</a></p><p><a href="https://zhuanlan.zhihu.com/p/35386457" target="_blank" rel="noopener">多处理器编程：从缓存一致性到内存模型</a></p><p><a href="https://en.wikipedia.org/wiki/Consistency_model" target="_blank" rel="noopener">Consistency model</a></p><ol><li><p>严格一致性内存模型 / 内存严格一致性模型 (Strict Consistency)<br>在严格的内存一致性模型下，任何对内存的读取，都会返回最近一次对该内存的修改，在没有缓存的情况下，所有操作通过总线直接与内存相连，这种形式的内存模型便是<code>严格一致性内存模型</code></p><blockquote><p>该模型只存在于理论中，实际中不使用。</p></blockquote></li><li><p>顺序一致性 / 内存顺序一致性模型 / 顺序一致性内存模型（Sequential Consistency）<br>对于Memory Order来说，最重要的是Sequential Consistency。它的意思是，每个线程按照程序次序执行，多个线程的执行结果，和将所有操作顺序执行的结果一样。换句话说，将所有线程的操作按照某一个顺序依次执行，结果和原来一样，但这个顺序未必是时间顺序。</p></li><li><p>缓存一致性（Cache Coherence）<br>许多研究者几乎将缓存一致性(Cache Coherence)看作是顺序一致性的同义词；但是它们不是的，这也许让人感到惊讶。顺序一致性要求一个从<code>全局（也就是所以内存）一致性</code>的角度看待内存操作，缓存一致性仅仅要求一个<code>局部的（也就是单个cache）一致性</code>。这里有一个例子，它给出的场景符合缓存一致性，但是不符合顺序一致性：</p></li></ol><h2 id="缓存一致性的优化"><a href="#缓存一致性的优化" class="headerlink" title="缓存一致性的优化"></a>缓存一致性的优化</h2><p>上面介绍了<code>Cache</code>, <code>Cache line</code>, <code>Cache coherence</code>, 这些都由硬件工程师为我们实现了，如果按上面模型的话，我们在开发过程中最需要关注的其实只有Cache line频繁miss这一问题。 <code>0.2 spinlock，0.3 行遍历比列遍历高效，0.4 多线程执行时的低效</code>这三个问题都可以找到对应的答案以及解决方案。<br>内存屏障，至此只解决两个问题<code>1.编译器优化，2.CPU优化</code></p><blockquote><p><code>#define barrier() __asm__ __volatile__(&quot;&quot; ::: &quot;memory&quot;)</code><br>以上内存屏障就是为了解决<code>1.编译器优化，2.CPU优化</code>问题</p><p>但实际硬件工程师在设计CPU的时候不仅仅局限于以上的设计，以上模型有一个问题<code>同步</code>执行。CPU将数据写入到cache line同时需要发送Invalidate给其他CPU，并且等待其他CPU置位返回acknowledgement消息后，本次写才完成。</p></blockquote><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727003690920.jpg" width="600" alt title></p><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727003886349.jpg" width="300" alt title></p><h2 id="store-buffer"><a href="#store-buffer" class="headerlink" title="store buffer"></a>store buffer</h2><h3 id="store-buffer引入"><a href="#store-buffer引入" class="headerlink" title="store buffer引入"></a>store buffer引入</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727004212201.jpg" width="300" alt title></p><blockquote><p>在这种模型中，CPU0将数据写入store buffer后立即发送一个Invalidate给CPU1,等CPU1无效化cache line返回ack后即完成操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU0        </span><br><span class="line">a = 1</span><br><span class="line">b = a+1</span><br><span class="line">assert b==2</span><br></pre></td></tr></table></figure><ol><li>cpu0 执行 a = 1</li><li>cpu0 发现 a 不在 cache line, 因此发送Read Invalidate , 同时将a=1写入Store Buffer</li><li>cpu1 接收 Read Invalidate, 并响应</li><li>cpu0 执行 b = a+1</li><li>cpu0 收到 cpu1返回数据a=0，放入cache line</li><li><code>cpu0 load a from cache line，为0</code></li><li>cpu0 执行 b = 0+1</li><li>assert fails</li></ol><h3 id="store-buffer-改进"><a href="#store-buffer-改进" class="headerlink" title="store buffer 改进"></a>store buffer 改进</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727004560821.jpg" width="300" alt title></p><blockquote><p>之前主要问题是cpu0只从cache line 中获取数据，未感知store buffer，因此添加一种从Store Buffer获取数据的机制就能解决上述问题。</p></blockquote><h3 id="sotre-buffer-在多cpu中的问题"><a href="#sotre-buffer-在多cpu中的问题" class="headerlink" title="sotre buffer 在多cpu中的问题"></a>sotre buffer 在多cpu中的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void cpu0(void) &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cpu1(void) &#123;</span><br><span class="line">    while (b == 0) contine;</span><br><span class="line">    assert(a == 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cpu0 包含 b的cache line</span><br><span class="line">// cpu1 包含 a的cache line</span><br></pre></td></tr></table></figure><blockquote><p>没有编译器优化和cpu优化，即均<code>按顺序执行</code></p></blockquote><ol><li>cpu0 执行 a = 1, a不在cache line, 存入store buffer</li><li>cpu0 执行 b = 1, b在cache line, 直接替换</li><li>cpu1 执行 while (b == 0), b不在 cache line 发送 Read Invalidate</li><li>cpu0 接收到 cpu1发送的Read b Invalidate，将b=1发送给cpu1</li><li>cpu1 接收到 b=1 存入cache line</li><li>cpu1 结束while死循环</li><li>cpu1 执行a==1 fail</li><li>cpu0 将store buffer内的a=1写入cache line,并发送Read Invalidate给cpu1, 此时已晚啦。</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727005038294.jpg" width="600" alt title></p><h3 id="写屏障-smp-wmb"><a href="#写屏障-smp-wmb" class="headerlink" title="写屏障 smp_wmb"></a>写屏障 smp_wmb</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void cpu0(void) &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    smp_wmb()</span><br><span class="line">    b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cpu1(void) &#123;</span><br><span class="line">    while (b == 0) contine;</span><br><span class="line">    assert(a == 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cpu0 包含 b的cache line</span><br><span class="line">// cpu1 包含 a的cache line</span><br></pre></td></tr></table></figure><blockquote><p><code>smp_mb()将导致cpu flush its store buffer</code></p></blockquote><ol><li>cpu0 执行 a = 1, 在缓存中，置于store buffer</li><li><code>cpu0 执行 smp_mp(), 将stpre buffer数据刷到 cache line，同时发送给cpu1 Read InValidate</code></li><li>cpu1 接收到Read InValidate并返回ack </li><li>cpu0 执行 b = 1, b在cache line, 直接替换</li><li>cpu1 执行b==1，读取cpu0的b存入cache line</li><li>cpu1 结束while死循环</li><li>cpu1 执行a==1, 此时a无效，读取cpu0的a缓存</li></ol><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727005338677.jpg" width="600" alt title></p><blockquote><p>现在还有一个问题，无效状态确认必须等到其他cpu都完成后才能返回，16个CPU的话相当于每次都需要等到其他15个CPU将相应位置位无效后才返回继续执行。<br>有没有方法减少这样的同步？？加入<code>Invalidate Queue</code></p></blockquote><h2 id="Invalidate-Queue"><a href="#Invalidate-Queue" class="headerlink" title="Invalidate Queue"></a>Invalidate Queue</h2><h3 id="Invalidate-Queue引入"><a href="#Invalidate-Queue引入" class="headerlink" title="Invalidate Queue引入"></a>Invalidate Queue引入</h3><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727005667008.jpg" width="300" alt title></p><blockquote><p>引入无效队列，可以把收到的无效通知置于此，立即返回。</p></blockquote><h3 id="Invalidate-Queue-在多cpu中的问题"><a href="#Invalidate-Queue-在多cpu中的问题" class="headerlink" title="Invalidate Queue 在多cpu中的问题"></a>Invalidate Queue 在多cpu中的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void cpu0(void) &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    smp_wmb()</span><br><span class="line">    b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cpu1(void) &#123;</span><br><span class="line">    while (b == 0) contine;</span><br><span class="line">    assert(a == 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cpu0 包含 b的cache line</span><br><span class="line">// cpu1 包含 a的cache line</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727005909427.jpg" width="600" alt title></p><h3 id="读屏障-smp-rmb"><a href="#读屏障-smp-rmb" class="headerlink" title="读屏障 smp_rmb"></a>读屏障 smp_rmb</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void cpu0(void) &#123;</span><br><span class="line">    a = 1;</span><br><span class="line">    smp_wmb();</span><br><span class="line">    b = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cpu1(void) &#123;</span><br><span class="line">    while (b == 0) contine;</span><br><span class="line">    smp_rmb();</span><br><span class="line">    assert(a == 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cpu0 包含 b的cache line</span><br><span class="line">// cpu1 包含 a的cache line</span><br></pre></td></tr></table></figure><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727007447223.jpg" width="600" alt title></p><h2 id="lock与屏障相关"><a href="#lock与屏障相关" class="headerlink" title="lock与屏障相关"></a>lock与屏障相关</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727007800762.jpg" width="600" alt title></p><p><a href="https://zhuanlan.zhihu.com/p/33626920" target="_blank" rel="noopener">为什么我们需要内存屏障？</a></p><p><a href="https://www.jianshu.com/p/64240319ed60" target="_blank" rel="noopener">一文解决内存屏障</a></p><p>至此，从cache-&gt;cache line-&gt;cache coherency-&gt;memory consistency-&gt;memory barrier</p><p>lock到底起到什么作用，在cache line中有数据的时候，并非<code>锁总线</code>, 而是通过添加内存屏障保证内存一致性，有些解释认为lock起到<code>锁定缓存</code>。</p><p>在x86架构中，lock前缀作为一个特殊的信号，执行了如下几个过程:</p><ol><li>对总线和cache line上锁</li><li>强制lock信号之前的指令，都在之前被执行，并invalidate queue。</li><li>执行lock后的指令。</li><li>释放对总线和cache line上的锁</li><li>强制所有lock信号后的指令，都在之后执行，并同步store buffer。</li></ol><blockquote><p>因此lock信号虽然不是内存屏障，但具有mfence(全屏障)的语义，与内存屏障相比，lock信号要额外对总线和cache line上锁，成本更高</p></blockquote><h2 id="Java-voliate相关"><a href="#Java-voliate相关" class="headerlink" title="Java voliate相关"></a>Java voliate相关</h2><p><img src="https://klutzoder-blog.oss-cn-beijing.aliyuncs.com/blog/linux/media-cache/15727008118796.jpg" width="300" alt title></p><h3 id="voliate-汇编代码"><a href="#voliate-汇编代码" class="headerlink" title="voliate 汇编代码"></a>voliate 汇编代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pac kage design;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="comment">// 0x00000001176dff3b: mov    0x68(%r10),%r11d</span></span><br><span class="line">        <span class="comment">// 0x00000001176dff3f: inc    %r11d</span></span><br><span class="line">        <span class="comment">// 0x00000001176dff42: mov    %r11d,0x68(%r10)</span></span><br><span class="line">        <span class="comment">// 0x00000001176dff46: lock addl $0x0,(%rsp)</span></span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>编译<br>javac design/VolatileTest</p></li><li><p>字节码反汇编<br>javap -c -l design.VolatileTest </p></li><li><p>机器码反编译<br>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp design.VolatileTest &gt; test.asm</p></li></ol><h3 id="voliate-原理"><a href="#voliate-原理" class="headerlink" title="voliate 原理"></a>voliate 原理</h3><blockquote><p>如果不保证，仍以x86架构为例，JVM对volatile变量的处理如下：</p></blockquote><ol><li>在写volatile变量v之后，插入一个<code>sfence</code>。这样，sfence之前的所有store（包括写v）不会被重排序到sfence之后，sfence之后的所有store不会被重排序到sfence之前，禁用跨sfence的store重排序；且sfence之前修改的值都会被写回缓存，并标记其他CPU中的缓存失效。</li><li>在读volatile变量v之前，插入一个<code>lfence</code>。这样，lfence之后的load（包括读v）不会被重排序到lfence之前，lfence之前的load不会被重排序到lfence之后，禁用跨lfence的load重排序；且lfence之后，会首先刷新无效缓存，从而得到最新的修改值，与sfence配合保证内存可见性。</li></ol><blockquote><p>内存屏障解决了多个问题：<code>1.编译器优化</code>，<code>2.cpu优化</code>，<code>3.缓存相关优化</code>，以此保证<code>内存一致性</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 516</title>
      <link href="Leetcode/leetcode/leetcode-516/"/>
      <url>Leetcode/leetcode/leetcode-516/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本页主要更新与Palindromic相关的动态规划问题</p></blockquote><h1 id="Leetcode-516-Longest-Palindromic-Subsequence"><a href="#Leetcode-516-Longest-Palindromic-Subsequence" class="headerlink" title="Leetcode 516 Longest Palindromic Subsequence"></a>Leetcode 516 Longest Palindromic Subsequence</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定字符串s, 寻找该字符串中最长回文的子序列。假设最长长度为1000.</p><p>例: s = “bbbab” res = 4 </p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><p>$<br>首先介绍一种Time: O(n^2), Space: O(n^2) \<br>dp[i][j] 表示 s[i..j]中最长回文子串长度。 \<br>dp[i][j] = \begin{cases}<br>1 \qquad &amp; i = j \<br>dp[i+1][j-1]+2 \qquad &amp; s[i]==s[j]\<br>max(dp[i+1][j], dp[i][j-1]) \qquad &amp; s[i]!=s[j]\<br>\end{cases} \<br>$<br>至此整个算法核心部分已经解决。 </p><a id="more"></a><h2 id="求解结果"><a href="#求解结果" class="headerlink" title="求解结果"></a>求解结果</h2><h3 id="DP-1"><a href="#DP-1" class="headerlink" title="DP"></a>DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(); <span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 错误的思路:</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     dp[i][i] = 1;</span></span><br><span class="line">    <span class="comment">//     for (int j = i-1; j &gt;= 0; j--) &#123;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 若使用以上形式遍历, 由于 dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line">    <span class="comment">// 当i=n-1，或j=0时，都会越界。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿s = “bbbab” 举例：</p><script type="math/tex; mode=display"> \begin{matrix}   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 1 \\  \end{matrix} =>   \begin{matrix}   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 1 & 1 \\   0 & 0 & 0 & 0 & 1 \\  \end{matrix} =>   \begin{matrix}   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 0 & 0 & 0 \\   0 & 0 & 1 & 1 & 3 \\   0 & 0 & 0 & 1 & 1 \\   0 & 0 & 0 & 0 & 1 \\  \end{matrix} =>\begin{matrix}   0 & 0 & 0 & 0 & 0 \\   0 & 1 & 2 & 2 & 3 \\   0 & 0 & 1 & 1 & 3 \\   0 & 0 & 0 & 1 & 1 \\   0 & 0 & 0 & 0 & 1 \\  \end{matrix} =>   \begin{matrix}   1 & 2 & 3 & 3 & 4 \\   0 & 1 & 2 & 2 & 3 \\   0 & 0 & 1 & 1 & 3 \\   0 & 0 & 0 & 1 & 1 \\   0 & 0 & 0 & 0 & 1 \\  \end{matrix}</script><blockquote><p>由以上可知，当前状态只与前一状态相关，因此只需要int[] pre, int[] cur用于空间优化，从$O(n^2)$优化到$O(n)$</p></blockquote><h3 id="DP优化"><a href="#DP优化" class="headerlink" title="DP优化"></a>DP优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length(); <span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">int</span>[] pre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cur[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                cur[j] = pre[j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur[j] = Math.max(pre[j], cur[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Palindromic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治(Divid And Conquer)</title>
      <link href="Algorithm/algorithm/divid-and-conquer/"/>
      <url>Algorithm/algorithm/divid-and-conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="分治-Divide-and-Conquer"><a href="#分治-Divide-and-Conquer" class="headerlink" title="分治(Divide and Conquer)"></a>分治(Divide and Conquer)</h1><p><a href="https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/" target="_blank" rel="noopener">Divide and Conquer Algorithm | Introduction</a> </p><blockquote><p>一个典型的分治分为三步：</p><ol><li>Divide: 将原问题分解为相同类型的子问题 </li><li>Conquer: 递归地解决这些子问题 </li><li>Combine: 组合子问题的解作为原问题的解 </li></ol></blockquote><p>最常见的分治算法包括： </p><ol><li>Binary Search </li><li>QuickSort </li><li>MergeSort </li><li>Closest Pair of Points </li></ol><a id="more"></a><h2 id="1-Binary-Search"><a href="#1-Binary-Search" class="headerlink" title="1. Binary Search"></a>1. Binary Search</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; </span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>); </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123; </span><br><span class="line">                right = mid - <span class="number">1</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                left = mid + <span class="number">1</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们的循环条件中包含了 left == right的情况，则我们必须在每次循环中改变 left 和 right的指向，以防止进入死循环 </li></ol><h2 id="2-QuickSort"><a href="#2-QuickSort" class="headerlink" title="2. QuickSort"></a>2. QuickSort</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123; </span><br><span class="line">        <span class="keyword">int</span> pi = partition(arr, low, high); </span><br><span class="line">        quickSort(arr, low, pi-<span class="number">1</span>); </span><br><span class="line">        quickSort(arr, pi+<span class="number">1</span>, high); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序遍历法 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> pivot = arr[high]; </span><br><span class="line">    <span class="keyword">int</span> i = low - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; j++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123; </span><br><span class="line">            i++; </span><br><span class="line">            swap(arr, i, j); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    swap(arr, i+<span class="number">1</span>, highg); </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 填坑法 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> pivot = arr[low]; </span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123; </span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;   </span><br><span class="line">        arr[low] = arr[high]; </span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++; </span><br><span class="line">        arr[high] = arr[low]; </span><br><span class="line">    &#125; </span><br><span class="line">    arr[low] = pivot; </span><br><span class="line">    <span class="keyword">return</span> low; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-MergeSort"><a href="#3-MergeSort" class="headerlink" title="3. MergeSort"></a>3. MergeSort</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>; </span><br><span class="line">        mergeSort(arr, low, mid); </span><br><span class="line">        mergeSort(arr, mid+<span class="number">1</span>, high); </span><br><span class="line">        merge(arr, low, mid, high); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> len1 = mid - low + <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> len2 = high - mid; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] arr1 = copy2Temp(arr, low, len1); </span><br><span class="line">    <span class="keyword">int</span>[] arr2 = copy2Temp(arr, mid+<span class="number">1</span>, len2); </span><br><span class="line">    <span class="comment">// merge the temp arrays </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 &amp;&amp; j &lt; len2) &#123; </span><br><span class="line">        <span class="keyword">if</span> (arr1[i] &lt;= arr2[j]) &#123; </span><br><span class="line">            arr[low++] = arr1[i++]; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">             arr[low++] = arr2[j++]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1) arr[low++] = arr1[i++]; </span><br><span class="line">    <span class="keyword">while</span> (j &lt; len2) arr[low++] = arr2[j++]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Closest-Pair-of-Points"><a href="#4-Closest-Pair-of-Points" class="headerlink" title="4. Closest Pair of Points"></a>4. Closest Pair of Points</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dist</span><span class="params">(Point point1, Point point2)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> xdist = point1.x - point2.x; </span><br><span class="line">    <span class="keyword">int</span> ydist = point1.y - point2.y; </span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(xdist * xdist + ydist * ydist); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">bruteForce</span><span class="params">(Point[] points, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">double</span> min = Double.MAX_VALUE; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; high; j++) &#123; </span><br><span class="line">            min = Math.min(min, dist(points[i], points[j])); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">stripClosest</span><span class="params">(Point[] strip, <span class="keyword">int</span> len, <span class="keyword">double</span> d)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">double</span> min = d; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len &amp;&amp; Math.abs(strip[j].y - strip[i].y) &lt; d; j++) </span><br><span class="line">            min = Math.min(min, dist(strip[i], strip[j])); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point[] points)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 排序根据x轴排序 </span></span><br><span class="line">    Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;Point&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> o1.x - o2.x; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> closest(points, <span class="number">0</span>, points.length); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">closest</span><span class="params">(Point[] points, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (high - low &lt;= <span class="number">3</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> bruteForce(points, low, high); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按x轴一分为二 </span></span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">double</span> d1 = closest(points, low, mid); </span><br><span class="line">    <span class="keyword">double</span> d2 = closest(points, mid + <span class="number">1</span>, high); </span><br><span class="line">    <span class="keyword">double</span> d = Math.min(d1, d2); </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 中间地带谁最小 </span></span><br><span class="line">    Point[] strip = <span class="keyword">new</span> Point[high - low]; </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) </span><br><span class="line">      <span class="keyword">if</span> (Math.abs(points[i].x - points[mid].x) &lt; d) </span><br><span class="line">          strip[j++] = points[i]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(d, stripClosest(strip, j, d)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Divid and conquer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
